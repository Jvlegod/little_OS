
F:/OS_lab/little_os/build/source/kernel/kernel.elf:     file format elf32-i386
F:/OS_lab/little_os/build/source/kernel/kernel.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010000

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x000033ac memsz 0x000033ac flags r-x
    LOAD off    0x00005000 vaddr 0x00014000 paddr 0x00014000 align 2**12
         filesz 0x00000040 memsz 0x00006800 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000032c8  00010000  00010000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       000000e4  000132c8  000132c8  000042c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000040  00014000  00014000  00005000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00005800  00015000  00015000  00005040  2**12
                  ALLOC
  4 .debug_line   00001bc4  00000000  00000000  00005040  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005f1b  00000000  00000000  00006c04  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001a68  00000000  00000000  0000cb1f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000260  00000000  00000000  0000e588  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000143b  00000000  00000000  0000e7e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      00000011  00000000  00000000  0000fc23  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00001620  00000000  00000000  0000fc34  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
000132c8 l    d  .rodata	00000000 .rodata
00014000 l    d  .data	00000000 .data
00015000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 CMakeFiles/kernel.dir/init/start.S.obj
00010013 l       .text	00000000 reload_gdt
00000000 l    df *ABS*	00000000 Timer.c
000102c2 l     F .text	0000001f outb
00000000 l    df *ABS*	00000000 debug.c
00010399 l     F .text	00000007 hlt
00000000 l    df *ABS*	00000000 gdt.c
0001040f l     F .text	00000030 lgdt
00000000 l    df *ABS*	00000000 first_proc.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 irq.c
00010621 l     F .text	00000007 hlt
00010628 l     F .text	00000007 cli
0001062f l     F .text	00000007 sti
00010636 l     F .text	0000001d inb
00010653 l     F .text	0000001f outb
00010672 l     F .text	00000028 lidt
00000000 l    df *ABS*	00000000 bitmap.c
00000000 l    df *ABS*	00000000 memory.c
00000000 l    df *ABS*	00000000 pagetable.c
00010f6e l     F .text	00000011 rcr0
00010f7f l     F .text	0000000c wcr0
00010f8b l     F .text	0000000c wcr3
00014000 l     O .data	00000040 kernel_map.2023
00000000 l    df *ABS*	00000000 sync.c
00000000 l    df *ABS*	00000000 syscall.c
000115cd l     F .text	00000007 hlt
00000000 l    df *ABS*	00000000 task.c
0001176b l     F .text	0000000c wcr3
00011777 l     F .text	00000030 lgdt
000117a7 l     F .text	0000000c ltr
00015000 l     O .bss	00000004 global_pid.2589
00000000 l    df *ABS*	00000000 klib.c
00000000 l    df *ABS*	00000000 klist.c
00000000 l    df *ABS*	00000000 kmath.c
00000000 l    df *ABS*	00000000 log.c
00012cb4 l     F .text	0000001d inb
00012cd1 l     F .text	0000001f outb
00000000 l    df *ABS*	00000000 tss.c
00012dcf l     F .text	0000000c ltr
00012ddb l     F .text	0000001a far_jmp
00010cc7 g     F .text	0000003a bitmap_get_bit
00010a48 g     F .text	0000000a irq_handler_breakpoint
00018000 g     O .bss	00000018 addr_manager
00012d7d g     F .text	0000002e write_serial
00010ade g     F .text	0000000a irq_handler_virtual_exception
00010a66 g     F .text	0000000a irq_handler_invalid_opcode
00011289 g     F .text	0000010e copy_pagetable
00010a7a g     F .text	0000000a irq_handler_double_fault
0001110c g     F .text	00000067 vaddr2paddr
000119cc g     F .text	0000002a thread_set_sleep
000170a0 g     O .bss	00000800 gdt_table
00011a7f g     F .text	0000005c kthread_init
00012bd1 g     F .text	00000034 klist_find
0001321a g     F .text	00000040 task_set_ready
00011cb7 g     F .text	00000023 thread_schedule
00010d01 g     F .text	0000001b bitmap_is_set
00010a70 g     F .text	0000000a irq_handler_device_unfound
00012acd g     F .text	00000041 klist_append
00012bb0 g     F .text	0000000b klist_len
00010244 g       .text	00000000 exception_handler_virtual_exception
00012292 g     F .text	00000011 update_tss_esp0
00010113 g       .text	00000000 exception_handler_device_unfound
00012cf0 g     F .text	00000075 log_init
000115ff g     F .text	00000114 sys_fork
0001a800 g       .bss	00000000 free_addr
00012374 g     F .text	0000003b kmemset
00018020 g     O .bss	00000044 task_manager
00014000 g       .data	00000000 sdata
00010dc3 g     F .text	0000003f kfree_pages
00010ab6 g     F .text	0000000a irq_handler_float_point_error
00010ae8 g     F .text	0000001e irq_enable
0001002b g       .text	00000000 exception_handler_unknown
0001009f g       .text	00000000 exception_handler_breakpoint
00012810 g     F .text	00000027 kstrlen
000126b8 g     F .text	000000a0 kitoa_s
000115f4 g     F .text	0000000b sys_read
00010a34 g     F .text	0000000a irq_handler_debug
000117b3 g     F .text	00000016 tss_init
0001019c g       .text	00000000 exception_handler_general_protection
000121a6 g     F .text	000000ec proc_switch
00011adb g     F .text	00000077 kthread_create
00012b0e g     F .text	00000040 klist_pop
00010be7 g     F .text	000000e0 bitmap_set_bit
000128a8 g     F .text	0000016f kswap
000115c7 g     F .text	00000006 sem_destroy
00012864 g     F .text	00000044 kintlen
00010130 g       .text	00000000 exception_handler_double_fault
00010349 g     F .text	0000002b pic_send_eoi
00012837 g     F .text	0000002d karr_strlen
00010181 g       .text	00000000 exception_handler_stack_segment_fault
000105b3 g       .text	00000000 first_task_entry
0001069a g     F .text	000000b6 pic_enable
0001051d g     F .text	00000096 gdt_init
000127bb g     F .text	00000055 kreverse_charstr
00013294 g     F .text	00000034 task_FIFO
00012a58 g     F .text	00000038 klist_init
000100bc g       .text	00000000 exception_handler_overflow
00010374 g     F .text	00000025 irq_handler_timer
000102ad g       .text	00000000 simple_switch
00011480 g     F .text	000000c2 thread_sem_wait
00012469 g     F .text	0000024f klog_vsprintf
000101d2 g       .text	00000000 exception_handler_float_point_error
00010a5c g     F .text	0000000a irq_handler_bound_range
00011d62 g     F .text	000000b3 proc_dispatch
00015010 g     O .bss	00002000 stack
00010a84 g     F .text	0000000a irq_handler_invalid_tss
00010bd1 g     F .text	00000016 bitmap_get_bytes
00011973 g     F .text	00000041 proc_set_ready
00011397 g     F .text	00000067 create_page_table
00012eed g     F .text	0000015b init_tss
00010ad4 g     F .text	0000000a irq_handler_SIMD
00012df5 g     F .text	000000f8 tss_task_init
000122a3 g     F .text	00000012 switch_pgdir
00013129 g     F .text	0000006e task_time_ticks
000100d9 g       .text	00000000 exception_handler_bound_range
00012bc6 g     F .text	0000000b klist_get_last_node
00018080 g     O .bss	00000068 tss
00012b4e g     F .text	00000062 klist_remove
00013048 g     F .text	000000a8 init_task
00010000 g       .text	00000000 stext
0001014b g       .text	00000000 exception_handler_invalid_tss
00011e15 g     F .text	00000034 thread_FIFO
00012313 g     F .text	0000000a cur_proc
000102eb g     F .text	0000005e timer_init
000113fe g     F .text	0000000e pagetable_init
00010aca g     F .text	0000000a irq_handler_machine_check
0001171e g     F .text	0000000b sys_putchar
000105b8 g     F .text	00000017 first_proc
00010048 g       .text	00000000 exception_handler_divider
000133ac g       .rodata	00000000 etext
0001048b g     F .text	00000092 gdt_segment_set
000115e9 g     F .text	0000000b sys_write
00011a68 g     F .text	00000017 kthread
00010b24 g     F .text	00000024 get_irq_status
000105cf g     F .text	0000003a kernel_init
0001140c g     F .text	0000004a get_v2p
00011456 g     F .text	0000002a sem_init
00011173 g     F .text	00000116 pagetable_destroy
00010a3e g     F .text	0000000a irq_handler_NMI
00012c1d g     F .text	00000097 kdecimalToHexadecimal
00010000 g       .text	00000000 _start
000100f6 g       .text	00000000 exception_handler_invalid_opcode
00010000 g       .text	00000000 kernel_end
00012a17 g     F .text	00000041 kstrcpy
000123f2 g     F .text	00000077 klog_printf
0001020a g       .text	00000000 exception_handler_machine_check
00000000 g       *ABS*	00000000 kernel_base
00011cfd g     F .text	00000065 thread_dispatch
000131fa g     F .text	00000020 task_set_general
00010a28 g     F .text	00000006 irq_handler_unknown
00010a52 g     F .text	0000000a irq_handler_overflow
000103a0 g     F .text	0000006f panic
00010261 g       .text	00000000 exception_handler_timer
00012758 g     F .text	00000063 kreverse_intstr
00010972 g     F .text	00000044 irq_install
00010b48 g     F .text	00000013 irq_enter_protection
00012330 g     F .text	00000015 fork
0001235a g     F .text	0000001a first_proc_init
000102e1 g     F .text	0000000a SYSTEM_READ_TIMER
00011729 g     F .text	00000042 syscall_init
00010b06 g     F .text	0000001e irq_disable
0001091c g     F .text	00000056 irq_segment_set
00012d65 g     F .text	00000018 is_transmit_empty
00010eea g     F .text	0000003a total_mem_size
00010609 g     F .text	00000018 main
000118d1 g     F .text	00000020 proc_set_general
00012a90 g     F .text	0000003d klist_push
00011713 g     F .text	0000000b sys_malloc
00013271 g     F .text	00000023 task_schedule
00013197 g     F .text	00000063 task_dispatch
00018100 g     O .bss	00000078 thread_manager
0001310b g     F .text	00000014 switch_to_tss
000118b1 g     F .text	00000020 thread_set_general
00010f24 g     F .text	0000004a alloc_init
00010a98 g     F .text	0000000a irq_handler_stack_segment_fault
00010aac g     F .text	0000000a irq_handler_page_fault
00010f97 g     F .text	000000c8 create_kernel_table
00010a8e g     F .text	0000000a irq_handler_segment_not_present
000101b7 g       .text	00000000 exception_handler_page_fault
0001325a g     F .text	00000017 task_set_block
00011b52 g     F .text	0000007e thread_start
000109b6 g     F .text	00000072 pic_init
00018180 g     O .bss	000000a0 proc_manager
000130f0 g     F .text	0000001b task_switch_from_to
00010750 g     F .text	000001cc irq_init
00017020 g     O .bss	00000004 ticks
00010b5b g     F .text	00000017 irq_leave_protection
00010e4c g     F .text	0000003d ualloc_pages
00011cda g     F .text	00000023 proc_schedule
000122fc g     F .text	00000017 alloc_pid
00010065 g       .text	00000000 exception_handler_debug
0001231d g     F .text	00000013 proc_ifkernel
00010b72 g     F .text	0000001a irq_set_status
00012dab g     F .text	00000024 write_serial_end
00017040 g     O .bss	00000050 syscall_table
00010227 g       .text	00000000 exception_handler_SIMD
00012c05 g     F .text	00000018 klist_empty
000119b4 g     F .text	00000018 thread_set_block
0001311f g     F .text	0000000a cur_task
000101ef g       .text	00000000 exception_handler_aligment_check
00019000 g     O .bss	00001000 kernel_table
00010b8c g     F .text	00000045 bitmap_init
00011f71 g     F .text	00000235 proc_start
000123af g     F .text	00000043 kmemcpy
00010166 g       .text	00000000 exception_handler_segment_not_present
00010082 g       .text	00000000 exception_handler_NMI
00010d1c g     F .text	000000a7 bitmap_alloc_nbits
000119f6 g     F .text	00000072 main_thread_init
00010e89 g     F .text	00000061 memory_init
000117c9 g     F .text	0000001e switch_thread_from_to
00011932 g     F .text	00000041 thread_set_ready
00010a2e g     F .text	00000006 irq_handler_divider
00011cad g     F .text	0000000a cur_thread
00011e49 g     F .text	00000034 proc_FIFO
0001027e g       .text	00000000 syscall_handler
0001a000 g     O .bss	00000800 idt_table
00010e02 g     F .text	0000004a kalloc_pages
00011bd0 g     F .text	000000dd task_init
00010aa2 g     F .text	0000000a irq_handler_general_protection
000117e7 g     F .text	000000ca tss_desc_set
0001043f g     F .text	0000004c gdt_alloc_seg
00011e7d g     F .text	00000047 thread_time_ticks
000115d4 g     F .text	00000015 sys_getpid
00011542 g     F .text	00000085 thread_sem_post
000118f1 g     F .text	00000041 thread_push_ready
00010ac0 g     F .text	0000000a irq_handler_aligment_check
000122b5 g     F .text	00000047 proc_time_ticks
00011ece g     F .text	000000a3 proc_init
00011ec4 g     F .text	0000000a thread_get_manager
00012345 g     F .text	00000015 get_pid
00012bbb g     F .text	0000000b klist_get_first_node
0001105f g     F .text	000000ad find_pte



Disassembly of section .text:

00010000 <_start>:
#include "comm/selector_define.h"
    .text
    .extern kernel_init, main
    .global _start
_start:
    push %ebp
   10000:	55                   	push   %ebp
    mov %esp, %ebp
   10001:	89 e5                	mov    %esp,%ebp
    // mov 0xC(%ebp), %eax
    // push %eax
    mov 0x8(%ebp), %eax
   10003:	8b 45 08             	mov    0x8(%ebp),%eax
    push %eax
   10006:	50                   	push   %eax

    call kernel_init
   10007:	e8 c3 05 00 00       	call   105cf <kernel_init>

    jmp $KERNEL_SELECTOR_CS, $reload_gdt
   1000c:	ea 13 00 01 00 08 00 	ljmp   $0x8,$0x10013

00010013 <reload_gdt>:
reload_gdt:
    mov $KERNEL_SELECTOR_DS, %ax
   10013:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
   10017:	8e d8                	mov    %eax,%ds
	mov %ax, %ss
   10019:	8e d0                	mov    %eax,%ss
	mov %ax, %es
   1001b:	8e c0                	mov    %eax,%es
	mov %ax, %fs
   1001d:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
   1001f:	8e e8                	mov    %eax,%gs

    mov $(stack + KERNEL_STACK_SIZE), %esp
   10021:	bc 10 70 01 00       	mov    $0x17010,%esp

    jmp main
   10026:	e9 de 05 00 00       	jmp    10609 <main>

0001002b <exception_handler_unknown>:
        
        iret
.endm

// 软件中断
exception_handler unknown, -1, 0
   1002b:	6a 00                	push   $0x0
   1002d:	6a ff                	push   $0xffffffff
   1002f:	60                   	pusha  
   10030:	1e                   	push   %ds
   10031:	06                   	push   %es
   10032:	0f a0                	push   %fs
   10034:	0f a8                	push   %gs
   10036:	54                   	push   %esp
   10037:	e8 ec 09 00 00       	call   10a28 <irq_handler_unknown>
   1003c:	5c                   	pop    %esp
   1003d:	0f a9                	pop    %gs
   1003f:	0f a1                	pop    %fs
   10041:	07                   	pop    %es
   10042:	1f                   	pop    %ds
   10043:	61                   	popa   
   10044:	83 c4 08             	add    $0x8,%esp
   10047:	cf                   	iret   

00010048 <exception_handler_divider>:
exception_handler divider, 0, 0
   10048:	6a 00                	push   $0x0
   1004a:	6a 00                	push   $0x0
   1004c:	60                   	pusha  
   1004d:	1e                   	push   %ds
   1004e:	06                   	push   %es
   1004f:	0f a0                	push   %fs
   10051:	0f a8                	push   %gs
   10053:	54                   	push   %esp
   10054:	e8 d5 09 00 00       	call   10a2e <irq_handler_divider>
   10059:	5c                   	pop    %esp
   1005a:	0f a9                	pop    %gs
   1005c:	0f a1                	pop    %fs
   1005e:	07                   	pop    %es
   1005f:	1f                   	pop    %ds
   10060:	61                   	popa   
   10061:	83 c4 08             	add    $0x8,%esp
   10064:	cf                   	iret   

00010065 <exception_handler_debug>:
exception_handler debug, 1, 0
   10065:	6a 00                	push   $0x0
   10067:	6a 01                	push   $0x1
   10069:	60                   	pusha  
   1006a:	1e                   	push   %ds
   1006b:	06                   	push   %es
   1006c:	0f a0                	push   %fs
   1006e:	0f a8                	push   %gs
   10070:	54                   	push   %esp
   10071:	e8 be 09 00 00       	call   10a34 <irq_handler_debug>
   10076:	5c                   	pop    %esp
   10077:	0f a9                	pop    %gs
   10079:	0f a1                	pop    %fs
   1007b:	07                   	pop    %es
   1007c:	1f                   	pop    %ds
   1007d:	61                   	popa   
   1007e:	83 c4 08             	add    $0x8,%esp
   10081:	cf                   	iret   

00010082 <exception_handler_NMI>:
exception_handler NMI, 2, 0
   10082:	6a 00                	push   $0x0
   10084:	6a 02                	push   $0x2
   10086:	60                   	pusha  
   10087:	1e                   	push   %ds
   10088:	06                   	push   %es
   10089:	0f a0                	push   %fs
   1008b:	0f a8                	push   %gs
   1008d:	54                   	push   %esp
   1008e:	e8 ab 09 00 00       	call   10a3e <irq_handler_NMI>
   10093:	5c                   	pop    %esp
   10094:	0f a9                	pop    %gs
   10096:	0f a1                	pop    %fs
   10098:	07                   	pop    %es
   10099:	1f                   	pop    %ds
   1009a:	61                   	popa   
   1009b:	83 c4 08             	add    $0x8,%esp
   1009e:	cf                   	iret   

0001009f <exception_handler_breakpoint>:
exception_handler breakpoint, 3, 0
   1009f:	6a 00                	push   $0x0
   100a1:	6a 03                	push   $0x3
   100a3:	60                   	pusha  
   100a4:	1e                   	push   %ds
   100a5:	06                   	push   %es
   100a6:	0f a0                	push   %fs
   100a8:	0f a8                	push   %gs
   100aa:	54                   	push   %esp
   100ab:	e8 98 09 00 00       	call   10a48 <irq_handler_breakpoint>
   100b0:	5c                   	pop    %esp
   100b1:	0f a9                	pop    %gs
   100b3:	0f a1                	pop    %fs
   100b5:	07                   	pop    %es
   100b6:	1f                   	pop    %ds
   100b7:	61                   	popa   
   100b8:	83 c4 08             	add    $0x8,%esp
   100bb:	cf                   	iret   

000100bc <exception_handler_overflow>:
exception_handler overflow, 4, 0
   100bc:	6a 00                	push   $0x0
   100be:	6a 04                	push   $0x4
   100c0:	60                   	pusha  
   100c1:	1e                   	push   %ds
   100c2:	06                   	push   %es
   100c3:	0f a0                	push   %fs
   100c5:	0f a8                	push   %gs
   100c7:	54                   	push   %esp
   100c8:	e8 85 09 00 00       	call   10a52 <irq_handler_overflow>
   100cd:	5c                   	pop    %esp
   100ce:	0f a9                	pop    %gs
   100d0:	0f a1                	pop    %fs
   100d2:	07                   	pop    %es
   100d3:	1f                   	pop    %ds
   100d4:	61                   	popa   
   100d5:	83 c4 08             	add    $0x8,%esp
   100d8:	cf                   	iret   

000100d9 <exception_handler_bound_range>:
exception_handler bound_range, 5, 0
   100d9:	6a 00                	push   $0x0
   100db:	6a 05                	push   $0x5
   100dd:	60                   	pusha  
   100de:	1e                   	push   %ds
   100df:	06                   	push   %es
   100e0:	0f a0                	push   %fs
   100e2:	0f a8                	push   %gs
   100e4:	54                   	push   %esp
   100e5:	e8 72 09 00 00       	call   10a5c <irq_handler_bound_range>
   100ea:	5c                   	pop    %esp
   100eb:	0f a9                	pop    %gs
   100ed:	0f a1                	pop    %fs
   100ef:	07                   	pop    %es
   100f0:	1f                   	pop    %ds
   100f1:	61                   	popa   
   100f2:	83 c4 08             	add    $0x8,%esp
   100f5:	cf                   	iret   

000100f6 <exception_handler_invalid_opcode>:
exception_handler invalid_opcode, 6, 0
   100f6:	6a 00                	push   $0x0
   100f8:	6a 06                	push   $0x6
   100fa:	60                   	pusha  
   100fb:	1e                   	push   %ds
   100fc:	06                   	push   %es
   100fd:	0f a0                	push   %fs
   100ff:	0f a8                	push   %gs
   10101:	54                   	push   %esp
   10102:	e8 5f 09 00 00       	call   10a66 <irq_handler_invalid_opcode>
   10107:	5c                   	pop    %esp
   10108:	0f a9                	pop    %gs
   1010a:	0f a1                	pop    %fs
   1010c:	07                   	pop    %es
   1010d:	1f                   	pop    %ds
   1010e:	61                   	popa   
   1010f:	83 c4 08             	add    $0x8,%esp
   10112:	cf                   	iret   

00010113 <exception_handler_device_unfound>:
exception_handler device_unfound, 7, 0
   10113:	6a 00                	push   $0x0
   10115:	6a 07                	push   $0x7
   10117:	60                   	pusha  
   10118:	1e                   	push   %ds
   10119:	06                   	push   %es
   1011a:	0f a0                	push   %fs
   1011c:	0f a8                	push   %gs
   1011e:	54                   	push   %esp
   1011f:	e8 4c 09 00 00       	call   10a70 <irq_handler_device_unfound>
   10124:	5c                   	pop    %esp
   10125:	0f a9                	pop    %gs
   10127:	0f a1                	pop    %fs
   10129:	07                   	pop    %es
   1012a:	1f                   	pop    %ds
   1012b:	61                   	popa   
   1012c:	83 c4 08             	add    $0x8,%esp
   1012f:	cf                   	iret   

00010130 <exception_handler_double_fault>:
exception_handler double_fault, 8, 1
   10130:	6a 08                	push   $0x8
   10132:	60                   	pusha  
   10133:	1e                   	push   %ds
   10134:	06                   	push   %es
   10135:	0f a0                	push   %fs
   10137:	0f a8                	push   %gs
   10139:	54                   	push   %esp
   1013a:	e8 3b 09 00 00       	call   10a7a <irq_handler_double_fault>
   1013f:	5c                   	pop    %esp
   10140:	0f a9                	pop    %gs
   10142:	0f a1                	pop    %fs
   10144:	07                   	pop    %es
   10145:	1f                   	pop    %ds
   10146:	61                   	popa   
   10147:	83 c4 08             	add    $0x8,%esp
   1014a:	cf                   	iret   

0001014b <exception_handler_invalid_tss>:
exception_handler invalid_tss, 10, 1
   1014b:	6a 0a                	push   $0xa
   1014d:	60                   	pusha  
   1014e:	1e                   	push   %ds
   1014f:	06                   	push   %es
   10150:	0f a0                	push   %fs
   10152:	0f a8                	push   %gs
   10154:	54                   	push   %esp
   10155:	e8 2a 09 00 00       	call   10a84 <irq_handler_invalid_tss>
   1015a:	5c                   	pop    %esp
   1015b:	0f a9                	pop    %gs
   1015d:	0f a1                	pop    %fs
   1015f:	07                   	pop    %es
   10160:	1f                   	pop    %ds
   10161:	61                   	popa   
   10162:	83 c4 08             	add    $0x8,%esp
   10165:	cf                   	iret   

00010166 <exception_handler_segment_not_present>:
exception_handler segment_not_present, 11, 1
   10166:	6a 0b                	push   $0xb
   10168:	60                   	pusha  
   10169:	1e                   	push   %ds
   1016a:	06                   	push   %es
   1016b:	0f a0                	push   %fs
   1016d:	0f a8                	push   %gs
   1016f:	54                   	push   %esp
   10170:	e8 19 09 00 00       	call   10a8e <irq_handler_segment_not_present>
   10175:	5c                   	pop    %esp
   10176:	0f a9                	pop    %gs
   10178:	0f a1                	pop    %fs
   1017a:	07                   	pop    %es
   1017b:	1f                   	pop    %ds
   1017c:	61                   	popa   
   1017d:	83 c4 08             	add    $0x8,%esp
   10180:	cf                   	iret   

00010181 <exception_handler_stack_segment_fault>:
exception_handler stack_segment_fault, 12, 1
   10181:	6a 0c                	push   $0xc
   10183:	60                   	pusha  
   10184:	1e                   	push   %ds
   10185:	06                   	push   %es
   10186:	0f a0                	push   %fs
   10188:	0f a8                	push   %gs
   1018a:	54                   	push   %esp
   1018b:	e8 08 09 00 00       	call   10a98 <irq_handler_stack_segment_fault>
   10190:	5c                   	pop    %esp
   10191:	0f a9                	pop    %gs
   10193:	0f a1                	pop    %fs
   10195:	07                   	pop    %es
   10196:	1f                   	pop    %ds
   10197:	61                   	popa   
   10198:	83 c4 08             	add    $0x8,%esp
   1019b:	cf                   	iret   

0001019c <exception_handler_general_protection>:
exception_handler general_protection, 13, 1
   1019c:	6a 0d                	push   $0xd
   1019e:	60                   	pusha  
   1019f:	1e                   	push   %ds
   101a0:	06                   	push   %es
   101a1:	0f a0                	push   %fs
   101a3:	0f a8                	push   %gs
   101a5:	54                   	push   %esp
   101a6:	e8 f7 08 00 00       	call   10aa2 <irq_handler_general_protection>
   101ab:	5c                   	pop    %esp
   101ac:	0f a9                	pop    %gs
   101ae:	0f a1                	pop    %fs
   101b0:	07                   	pop    %es
   101b1:	1f                   	pop    %ds
   101b2:	61                   	popa   
   101b3:	83 c4 08             	add    $0x8,%esp
   101b6:	cf                   	iret   

000101b7 <exception_handler_page_fault>:
exception_handler page_fault, 14, 1
   101b7:	6a 0e                	push   $0xe
   101b9:	60                   	pusha  
   101ba:	1e                   	push   %ds
   101bb:	06                   	push   %es
   101bc:	0f a0                	push   %fs
   101be:	0f a8                	push   %gs
   101c0:	54                   	push   %esp
   101c1:	e8 e6 08 00 00       	call   10aac <irq_handler_page_fault>
   101c6:	5c                   	pop    %esp
   101c7:	0f a9                	pop    %gs
   101c9:	0f a1                	pop    %fs
   101cb:	07                   	pop    %es
   101cc:	1f                   	pop    %ds
   101cd:	61                   	popa   
   101ce:	83 c4 08             	add    $0x8,%esp
   101d1:	cf                   	iret   

000101d2 <exception_handler_float_point_error>:
exception_handler float_point_error, 16, 0
   101d2:	6a 00                	push   $0x0
   101d4:	6a 10                	push   $0x10
   101d6:	60                   	pusha  
   101d7:	1e                   	push   %ds
   101d8:	06                   	push   %es
   101d9:	0f a0                	push   %fs
   101db:	0f a8                	push   %gs
   101dd:	54                   	push   %esp
   101de:	e8 d3 08 00 00       	call   10ab6 <irq_handler_float_point_error>
   101e3:	5c                   	pop    %esp
   101e4:	0f a9                	pop    %gs
   101e6:	0f a1                	pop    %fs
   101e8:	07                   	pop    %es
   101e9:	1f                   	pop    %ds
   101ea:	61                   	popa   
   101eb:	83 c4 08             	add    $0x8,%esp
   101ee:	cf                   	iret   

000101ef <exception_handler_aligment_check>:
exception_handler aligment_check, 17, 1
   101ef:	6a 11                	push   $0x11
   101f1:	60                   	pusha  
   101f2:	1e                   	push   %ds
   101f3:	06                   	push   %es
   101f4:	0f a0                	push   %fs
   101f6:	0f a8                	push   %gs
   101f8:	54                   	push   %esp
   101f9:	e8 c2 08 00 00       	call   10ac0 <irq_handler_aligment_check>
   101fe:	5c                   	pop    %esp
   101ff:	0f a9                	pop    %gs
   10201:	0f a1                	pop    %fs
   10203:	07                   	pop    %es
   10204:	1f                   	pop    %ds
   10205:	61                   	popa   
   10206:	83 c4 08             	add    $0x8,%esp
   10209:	cf                   	iret   

0001020a <exception_handler_machine_check>:
exception_handler machine_check, 18, 0
   1020a:	6a 00                	push   $0x0
   1020c:	6a 12                	push   $0x12
   1020e:	60                   	pusha  
   1020f:	1e                   	push   %ds
   10210:	06                   	push   %es
   10211:	0f a0                	push   %fs
   10213:	0f a8                	push   %gs
   10215:	54                   	push   %esp
   10216:	e8 af 08 00 00       	call   10aca <irq_handler_machine_check>
   1021b:	5c                   	pop    %esp
   1021c:	0f a9                	pop    %gs
   1021e:	0f a1                	pop    %fs
   10220:	07                   	pop    %es
   10221:	1f                   	pop    %ds
   10222:	61                   	popa   
   10223:	83 c4 08             	add    $0x8,%esp
   10226:	cf                   	iret   

00010227 <exception_handler_SIMD>:
exception_handler SIMD, 19, 0
   10227:	6a 00                	push   $0x0
   10229:	6a 13                	push   $0x13
   1022b:	60                   	pusha  
   1022c:	1e                   	push   %ds
   1022d:	06                   	push   %es
   1022e:	0f a0                	push   %fs
   10230:	0f a8                	push   %gs
   10232:	54                   	push   %esp
   10233:	e8 9c 08 00 00       	call   10ad4 <irq_handler_SIMD>
   10238:	5c                   	pop    %esp
   10239:	0f a9                	pop    %gs
   1023b:	0f a1                	pop    %fs
   1023d:	07                   	pop    %es
   1023e:	1f                   	pop    %ds
   1023f:	61                   	popa   
   10240:	83 c4 08             	add    $0x8,%esp
   10243:	cf                   	iret   

00010244 <exception_handler_virtual_exception>:
exception_handler virtual_exception, 20, 0
   10244:	6a 00                	push   $0x0
   10246:	6a 14                	push   $0x14
   10248:	60                   	pusha  
   10249:	1e                   	push   %ds
   1024a:	06                   	push   %es
   1024b:	0f a0                	push   %fs
   1024d:	0f a8                	push   %gs
   1024f:	54                   	push   %esp
   10250:	e8 89 08 00 00       	call   10ade <irq_handler_virtual_exception>
   10255:	5c                   	pop    %esp
   10256:	0f a9                	pop    %gs
   10258:	0f a1                	pop    %fs
   1025a:	07                   	pop    %es
   1025b:	1f                   	pop    %ds
   1025c:	61                   	popa   
   1025d:	83 c4 08             	add    $0x8,%esp
   10260:	cf                   	iret   

00010261 <exception_handler_timer>:

// 硬件中断
exception_handler timer, 0x20, 0
   10261:	6a 00                	push   $0x0
   10263:	6a 20                	push   $0x20
   10265:	60                   	pusha  
   10266:	1e                   	push   %ds
   10267:	06                   	push   %es
   10268:	0f a0                	push   %fs
   1026a:	0f a8                	push   %gs
   1026c:	54                   	push   %esp
   1026d:	e8 02 01 00 00       	call   10374 <irq_handler_timer>
   10272:	5c                   	pop    %esp
   10273:	0f a9                	pop    %gs
   10275:	0f a1                	pop    %fs
   10277:	07                   	pop    %es
   10278:	1f                   	pop    %ds
   10279:	61                   	popa   
   1027a:	83 c4 08             	add    $0x8,%esp
   1027d:	cf                   	iret   

0001027e <syscall_handler>:
// 系统调用处理函数
    .text
.extern syscall_table
.global syscall_handler
syscall_handler:
    push $0 // 压入erro code
   1027e:	6a 00                	push   $0x0
    push $0x80 // 压入中断向量码
   10280:	68 80 00 00 00       	push   $0x80
    pusha
   10285:	60                   	pusha  
    push %ds
   10286:	1e                   	push   %ds
    push %es
   10287:	06                   	push   %es
    push %fs
   10288:	0f a0                	push   %fs
    push %gs
   1028a:	0f a8                	push   %gs
    push %edx // 系统调用的第3个参数
   1028c:	52                   	push   %edx
    push %ecx // 系统调用的第2个参数
   1028d:	51                   	push   %ecx
    push %ebx // 系统调用的第1个参数
   1028e:	53                   	push   %ebx
    
    push %esp
   1028f:	54                   	push   %esp

    mov $syscall_table, %ebx
   10290:	bb 40 70 01 00       	mov    $0x17040,%ebx
    mov (%ebx, %eax, 4), %eax
   10295:	8b 04 83             	mov    (%ebx,%eax,4),%eax
    call *%eax
   10298:	ff d0                	call   *%eax
    
    pop %esp
   1029a:	5c                   	pop    %esp
    
    add $(0xC), %esp
   1029b:	83 c4 0c             	add    $0xc,%esp

    pop %gs
   1029e:	0f a9                	pop    %gs
    pop %fs
   102a0:	0f a1                	pop    %fs
    pop %es
   102a2:	07                   	pop    %es
    pop %ds
   102a3:	1f                   	pop    %ds
    mov %eax, 0x1C(%esp)
   102a4:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    popa
   102a8:	61                   	popa   
    add $0x8, %esp // 跳过err code和中断向量码
   102a9:	83 c4 08             	add    $0x8,%esp
    iret
   102ac:	cf                   	iret   

000102ad <simple_switch>:
// 转换
    .text
    .global simple_switch
simple_switch:
// simple_switch(stack1的地址的地址, stack2的地址)
    mov 4(%esp), %eax
   102ad:	8b 44 24 04          	mov    0x4(%esp),%eax
    mov 8(%esp), %edx
   102b1:	8b 54 24 08          	mov    0x8(%esp),%edx

    push %esi
   102b5:	56                   	push   %esi
    push %edi
   102b6:	57                   	push   %edi
    push %ebx
   102b7:	53                   	push   %ebx
    push %ebp
   102b8:	55                   	push   %ebp
    mov %esp, (%eax)
   102b9:	89 20                	mov    %esp,(%eax)

    mov %edx, %esp
   102bb:	89 d4                	mov    %edx,%esp
    pop %ebp
   102bd:	5d                   	pop    %ebp
    pop %ebx
   102be:	5b                   	pop    %ebx
    pop %edi
   102bf:	5f                   	pop    %edi
    pop %esi
   102c0:	5e                   	pop    %esi

    ret
   102c1:	c3                   	ret    

000102c2 <outb>:
 *
 * @param port
 * @param data
 */
static inline void outb(uint16_t port, uint8_t data)
{
   102c2:	55                   	push   %ebp
   102c3:	89 e5                	mov    %esp,%ebp
   102c5:	83 ec 08             	sub    $0x8,%esp
   102c8:	8b 55 08             	mov    0x8(%ebp),%edx
   102cb:	8b 45 0c             	mov    0xc(%ebp),%eax
   102ce:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   102d2:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[data], %[port]"
   102d5:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   102d9:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   102dd:	ee                   	out    %al,(%dx)
                         :
                         : [data] "a"(data), [port] "d"(port));
}
   102de:	90                   	nop
   102df:	c9                   	leave  
   102e0:	c3                   	ret    

000102e1 <SYSTEM_READ_TIMER>:
volatile long ticks;
extern irq_desc_t idt_table[IDT_SIZE];
extern proc_manager_t proc_manager;

long SYSTEM_READ_TIMER(void)
{
   102e1:	55                   	push   %ebp
   102e2:	89 e5                	mov    %esp,%ebp
    return ticks;
   102e4:	a1 20 70 01 00       	mov    0x17020,%eax
}
   102e9:	5d                   	pop    %ebp
   102ea:	c3                   	ret    

000102eb <timer_init>:

void timer_init()
{
   102eb:	55                   	push   %ebp
   102ec:	89 e5                	mov    %esp,%ebp
   102ee:	83 ec 08             	sub    $0x8,%esp
    // set 8253 timer-chip
    outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
   102f1:	6a 34                	push   $0x34
   102f3:	6a 43                	push   $0x43
   102f5:	e8 c8 ff ff ff       	call   102c2 <outb>
   102fa:	83 c4 08             	add    $0x8,%esp
    outb(IO_TIMER1, COUNTER_VALUE(IRQ_FREQUENCY) & 0xFF);
   102fd:	68 9b 00 00 00       	push   $0x9b
   10302:	6a 40                	push   $0x40
   10304:	e8 b9 ff ff ff       	call   102c2 <outb>
   10309:	83 c4 08             	add    $0x8,%esp
    outb(IO_TIMER1, (COUNTER_VALUE(IRQ_FREQUENCY) >> 8) & 0xFF);
   1030c:	6a 2e                	push   $0x2e
   1030e:	6a 40                	push   $0x40
   10310:	e8 ad ff ff ff       	call   102c2 <outb>
   10315:	83 c4 08             	add    $0x8,%esp

    // initialize time counter 'ticks' to zero
    ticks = 0;
   10318:	c7 05 20 70 01 00 00 	movl   $0x0,0x17020
   1031f:	00 00 00 
    irq_install(IRQ_Timer, (irq_handler_t)ENTRY(timer));
   10322:	83 ec 08             	sub    $0x8,%esp
   10325:	68 61 02 01 00       	push   $0x10261
   1032a:	6a 20                	push   $0x20
   1032c:	e8 41 06 00 00       	call   10972 <irq_install>
   10331:	83 c4 10             	add    $0x10,%esp
    pic_enable(IRQ_Timer);
   10334:	83 ec 0c             	sub    $0xc,%esp
   10337:	6a 20                	push   $0x20
   10339:	e8 5c 03 00 00       	call   1069a <pic_enable>
   1033e:	83 c4 10             	add    $0x10,%esp
    /* 打开中断 */
    irq_enable();
   10341:	e8 a2 07 00 00       	call   10ae8 <irq_enable>
}
   10346:	90                   	nop
   10347:	c9                   	leave  
   10348:	c3                   	ret    

00010349 <pic_send_eoi>:

void pic_send_eoi(int pic_num)
{
   10349:	55                   	push   %ebp
   1034a:	89 e5                	mov    %esp,%ebp
    pic_num -= PIC_START;
   1034c:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if (pic_num >= 8)
   10350:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   10354:	7e 0f                	jle    10365 <pic_send_eoi+0x1c>
    {
        outb(PIC_S_CTRL, 1 << 5);
   10356:	6a 20                	push   $0x20
   10358:	68 a0 00 00 00       	push   $0xa0
   1035d:	e8 60 ff ff ff       	call   102c2 <outb>
   10362:	83 c4 08             	add    $0x8,%esp
    }

    outb(PIC_M_CTRL, 1 << 5);
   10365:	6a 20                	push   $0x20
   10367:	6a 20                	push   $0x20
   10369:	e8 54 ff ff ff       	call   102c2 <outb>
   1036e:	83 c4 08             	add    $0x8,%esp
}
   10371:	90                   	nop
   10372:	c9                   	leave  
   10373:	c3                   	ret    

00010374 <irq_handler_timer>:

/* 定时器中断 */
void irq_handler_timer(trap_frame_t *trapframe)
{
   10374:	55                   	push   %ebp
   10375:	89 e5                	mov    %esp,%ebp
   10377:	83 ec 08             	sub    $0x8,%esp
    ticks++;
   1037a:	a1 20 70 01 00       	mov    0x17020,%eax
   1037f:	83 c0 01             	add    $0x1,%eax
   10382:	a3 20 70 01 00       	mov    %eax,0x17020
    // proc_manager.irq_state = irq_enter_protection();
    // proc_time_ticks(); /* 进程调度 */
    // irq_leave_protection(proc_manager.irq_state);

    /* 手动结束中断 */
    pic_send_eoi(IRQ_Timer);
   10387:	6a 20                	push   $0x20
   10389:	e8 bb ff ff ff       	call   10349 <pic_send_eoi>
   1038e:	83 c4 04             	add    $0x4,%esp
    task_time_ticks();
   10391:	e8 93 2d 00 00       	call   13129 <task_time_ticks>
   10396:	90                   	nop
   10397:	c9                   	leave  
   10398:	c3                   	ret    

00010399 <hlt>:
{
   10399:	55                   	push   %ebp
   1039a:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   1039c:	f4                   	hlt    
}
   1039d:	90                   	nop
   1039e:	5d                   	pop    %ebp
   1039f:	c3                   	ret    

000103a0 <panic>:
#include "tools/klib.h"
#include "irq/irq.h"
#include "debug.h"

void panic(char *filename, int line, const char *func, const char *condition)
{
   103a0:	55                   	push   %ebp
   103a1:	89 e5                	mov    %esp,%ebp
   103a3:	83 ec 08             	sub    $0x8,%esp
    irq_disable(); /* 关中断 */
   103a6:	e8 5b 07 00 00       	call   10b06 <irq_disable>

    klog_printf("\n\n\n!!!!! error !!!!!\n");
   103ab:	83 ec 0c             	sub    $0xc,%esp
   103ae:	68 c8 32 01 00       	push   $0x132c8
   103b3:	e8 3a 20 00 00       	call   123f2 <klog_printf>
   103b8:	83 c4 10             	add    $0x10,%esp
    klog_printf("filename: %s\n", filename);
   103bb:	83 ec 08             	sub    $0x8,%esp
   103be:	ff 75 08             	pushl  0x8(%ebp)
   103c1:	68 de 32 01 00       	push   $0x132de
   103c6:	e8 27 20 00 00       	call   123f2 <klog_printf>
   103cb:	83 c4 10             	add    $0x10,%esp
    klog_printf("line: %d\n", line);
   103ce:	83 ec 08             	sub    $0x8,%esp
   103d1:	ff 75 0c             	pushl  0xc(%ebp)
   103d4:	68 ec 32 01 00       	push   $0x132ec
   103d9:	e8 14 20 00 00       	call   123f2 <klog_printf>
   103de:	83 c4 10             	add    $0x10,%esp
    klog_printf("function: %s\n", func);
   103e1:	83 ec 08             	sub    $0x8,%esp
   103e4:	ff 75 10             	pushl  0x10(%ebp)
   103e7:	68 f6 32 01 00       	push   $0x132f6
   103ec:	e8 01 20 00 00       	call   123f2 <klog_printf>
   103f1:	83 c4 10             	add    $0x10,%esp
    klog_printf("condition: %s\n", condition);
   103f4:	83 ec 08             	sub    $0x8,%esp
   103f7:	ff 75 14             	pushl  0x14(%ebp)
   103fa:	68 04 33 01 00       	push   $0x13304
   103ff:	e8 ee 1f 00 00       	call   123f2 <klog_printf>
   10404:	83 c4 10             	add    $0x10,%esp
    hlt();
   10407:	e8 8d ff ff ff       	call   10399 <hlt>
   1040c:	90                   	nop
   1040d:	c9                   	leave  
   1040e:	c3                   	ret    

0001040f <lgdt>:
 *
 * @param start
 * @param offset
 */
static inline void lgdt(uint32_t start, uint16_t offset)
{
   1040f:	55                   	push   %ebp
   10410:	89 e5                	mov    %esp,%ebp
   10412:	83 ec 14             	sub    $0x14,%esp
   10415:	8b 45 0c             	mov    0xc(%ebp),%eax
   10418:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
        uint16_t offset;
        uint16_t start15_0;
        uint16_t start32_16;
    } gdt;

    gdt.start32_16 = start >> 16;
   1041c:	8b 45 08             	mov    0x8(%ebp),%eax
   1041f:	c1 e8 10             	shr    $0x10,%eax
   10422:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    gdt.start15_0 = start & 0xFFFF;
   10426:	8b 45 08             	mov    0x8(%ebp),%eax
   10429:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    gdt.offset = offset - 1;
   1042d:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   10431:	83 e8 01             	sub    $0x1,%eax
   10434:	66 89 45 fa          	mov    %ax,-0x6(%ebp)

    __asm__ __volatile__("lgdt %[gdt]" ::[gdt] "m"(gdt));
   10438:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
}
   1043c:	90                   	nop
   1043d:	c9                   	leave  
   1043e:	c3                   	ret    

0001043f <gdt_alloc_seg>:
 * @brief 分配gdt表项
 *
 * @return int
 */
int gdt_alloc_seg()
{
   1043f:	55                   	push   %ebp
   10440:	89 e5                	mov    %esp,%ebp
   10442:	83 ec 10             	sub    $0x10,%esp
    int i = 1;
   10445:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    for (int i = 1; i < GDT_SIZE; i++)
   1044c:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
   10453:	eb 26                	jmp    1047b <gdt_alloc_seg+0x3c>
    {
        gdt_entry_t *desc = gdt_table + i;
   10455:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10458:	c1 e0 03             	shl    $0x3,%eax
   1045b:	05 a0 70 01 00       	add    $0x170a0,%eax
   10460:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (desc->attributes == 0)
   10463:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10466:	0f b7 40 05          	movzwl 0x5(%eax),%eax
   1046a:	66 85 c0             	test   %ax,%ax
   1046d:	75 08                	jne    10477 <gdt_alloc_seg+0x38>
        {
            return i * sizeof(gdt_entry_t);
   1046f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10472:	c1 e0 03             	shl    $0x3,%eax
   10475:	eb 12                	jmp    10489 <gdt_alloc_seg+0x4a>
    for (int i = 1; i < GDT_SIZE; i++)
   10477:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1047b:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
   10482:	7e d1                	jle    10455 <gdt_alloc_seg+0x16>
        }
    }
    return -1;
   10484:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   10489:	c9                   	leave  
   1048a:	c3                   	ret    

0001048b <gdt_segment_set>:
 * @param limit 段界限  20位
 * @param base 段基址  32位
 * @param attr 段属性 16位
 */
void gdt_segment_set(uint16_t selector, uint32_t limit, uint32_t base, uint16_t attr)
{
   1048b:	55                   	push   %ebp
   1048c:	89 e5                	mov    %esp,%ebp
   1048e:	83 ec 18             	sub    $0x18,%esp
   10491:	8b 55 08             	mov    0x8(%ebp),%edx
   10494:	8b 45 14             	mov    0x14(%ebp),%eax
   10497:	66 89 55 ec          	mov    %dx,-0x14(%ebp)
   1049b:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    gdt_entry_t *desc = gdt_table + (selector >> 3);
   1049f:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   104a3:	66 c1 e8 03          	shr    $0x3,%ax
   104a7:	0f b7 c0             	movzwl %ax,%eax
   104aa:	c1 e0 03             	shl    $0x3,%eax
   104ad:	05 a0 70 01 00       	add    $0x170a0,%eax
   104b2:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if (limit > 0xFFFFF)
   104b5:	81 7d 0c ff ff 0f 00 	cmpl   $0xfffff,0xc(%ebp)
   104bc:	76 0f                	jbe    104cd <gdt_segment_set+0x42>
    {
        attr |= 0x8000;
   104be:	66 81 4d e8 00 80    	orw    $0x8000,-0x18(%ebp)
        limit /= 0x1000;
   104c4:	8b 45 0c             	mov    0xc(%ebp),%eax
   104c7:	c1 e8 0c             	shr    $0xc,%eax
   104ca:	89 45 0c             	mov    %eax,0xc(%ebp)
    }

    desc->limit_low = limit & 0xFFFF;
   104cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   104d0:	89 c2                	mov    %eax,%edx
   104d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   104d5:	66 89 10             	mov    %dx,(%eax)
    desc->base_low = base & 0xFFFF;
   104d8:	8b 45 10             	mov    0x10(%ebp),%eax
   104db:	89 c2                	mov    %eax,%edx
   104dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
   104e0:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->base_middle = (base >> 16) & 0xFF;
   104e4:	8b 45 10             	mov    0x10(%ebp),%eax
   104e7:	c1 e8 10             	shr    $0x10,%eax
   104ea:	89 c2                	mov    %eax,%edx
   104ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
   104ef:	88 50 04             	mov    %dl,0x4(%eax)
    desc->attributes = attr | (((limit >> 16) & 0xF) << 8);
   104f2:	8b 45 0c             	mov    0xc(%ebp),%eax
   104f5:	c1 e8 10             	shr    $0x10,%eax
   104f8:	c1 e0 08             	shl    $0x8,%eax
   104fb:	66 25 00 0f          	and    $0xf00,%ax
   104ff:	66 0b 45 e8          	or     -0x18(%ebp),%ax
   10503:	89 c2                	mov    %eax,%edx
   10505:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10508:	66 89 50 05          	mov    %dx,0x5(%eax)
    desc->base_high = (base >> 24) & 0xFF;
   1050c:	8b 45 10             	mov    0x10(%ebp),%eax
   1050f:	c1 e8 18             	shr    $0x18,%eax
   10512:	89 c2                	mov    %eax,%edx
   10514:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10517:	88 50 07             	mov    %dl,0x7(%eax)
}
   1051a:	90                   	nop
   1051b:	c9                   	leave  
   1051c:	c3                   	ret    

0001051d <gdt_init>:
/**
 * @brief 初始化GDT
 *
 */
void gdt_init()
{
   1051d:	55                   	push   %ebp
   1051e:	89 e5                	mov    %esp,%ebp
   10520:	83 ec 10             	sub    $0x10,%esp
    for (int i = 0; i < GDT_SIZE; i++)
   10523:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1052a:	eb 1c                	jmp    10548 <gdt_init+0x2b>
    {
        gdt_segment_set(i << 3, 0, 0, 0);
   1052c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1052f:	c1 e0 03             	shl    $0x3,%eax
   10532:	0f b7 c0             	movzwl %ax,%eax
   10535:	6a 00                	push   $0x0
   10537:	6a 00                	push   $0x0
   10539:	6a 00                	push   $0x0
   1053b:	50                   	push   %eax
   1053c:	e8 4a ff ff ff       	call   1048b <gdt_segment_set>
   10541:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < GDT_SIZE; i++)
   10544:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10548:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
   1054f:	7e db                	jle    1052c <gdt_init+0xf>
    }

    gdt_segment_set(KERNEL_SELECTOR_CS, 0xFFFFFFFF, 0x00000000, SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);
   10551:	68 9a 40 00 00       	push   $0x409a
   10556:	6a 00                	push   $0x0
   10558:	6a ff                	push   $0xffffffff
   1055a:	6a 08                	push   $0x8
   1055c:	e8 2a ff ff ff       	call   1048b <gdt_segment_set>
   10561:	83 c4 10             	add    $0x10,%esp
    gdt_segment_set(KERNEL_SELECTOR_DS, 0xFFFFFFFF, 0x00000000, SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);
   10564:	68 92 40 00 00       	push   $0x4092
   10569:	6a 00                	push   $0x0
   1056b:	6a ff                	push   $0xffffffff
   1056d:	6a 10                	push   $0x10
   1056f:	e8 17 ff ff ff       	call   1048b <gdt_segment_set>
   10574:	83 c4 10             	add    $0x10,%esp
    gdt_segment_set(USER_SELECTOR_CS, 0xFFFFFFFF, 0x00000000, SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);
   10577:	68 fa 40 00 00       	push   $0x40fa
   1057c:	6a 00                	push   $0x0
   1057e:	6a ff                	push   $0xffffffff
   10580:	6a 23                	push   $0x23
   10582:	e8 04 ff ff ff       	call   1048b <gdt_segment_set>
   10587:	83 c4 10             	add    $0x10,%esp
    gdt_segment_set(USER_SELECTOR_DS, 0xFFFFFFFF, 0x00000000, SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);
   1058a:	68 f2 40 00 00       	push   $0x40f2
   1058f:	6a 00                	push   $0x0
   10591:	6a ff                	push   $0xffffffff
   10593:	6a 2b                	push   $0x2b
   10595:	e8 f1 fe ff ff       	call   1048b <gdt_segment_set>
   1059a:	83 c4 10             	add    $0x10,%esp

    lgdt((uint32_t)gdt_table, sizeof(gdt_table));
   1059d:	b8 a0 70 01 00       	mov    $0x170a0,%eax
   105a2:	68 00 08 00 00       	push   $0x800
   105a7:	50                   	push   %eax
   105a8:	e8 62 fe ff ff       	call   1040f <lgdt>
   105ad:	83 c4 08             	add    $0x8,%esp
   105b0:	90                   	nop
   105b1:	c9                   	leave  
   105b2:	c3                   	ret    

000105b3 <first_task_entry>:
    // mov %ss, %ax
    // mov %ax, %ds
    // mov %ax, %es
    // mov %ax, %fs
    // mov %ax, %gs
   105b3:	e9 00 00 00 00       	jmp    105b8 <first_proc>

000105b8 <first_proc>:
#include "debug/debug.h"
#include "sync/sync.h"
#include "syscall/syscall.h"

void first_proc()
{
   105b8:	55                   	push   %ebp
   105b9:	89 e5                	mov    %esp,%ebp
   105bb:	83 ec 18             	sub    $0x18,%esp
    int count = 3;
   105be:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
    pid_t pid = fork();
   105c5:	e8 66 1d 00 00       	call   12330 <fork>
   105ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
    {
        // klog_printf("child task id = %d\n", pid);
        // klog_printf("parent: %d\n", count);
    }

    for (;;)
   105cd:	eb fe                	jmp    105cd <first_proc+0x15>

000105cf <kernel_init>:
 *
 * @param mem
 * @param gdt_table //  gdt_entry_t *gdt_table的参数为弃案
 */
void kernel_init(mem_info_t *mem)
{
   105cf:	55                   	push   %ebp
   105d0:	89 e5                	mov    %esp,%ebp
   105d2:	83 ec 08             	sub    $0x8,%esp
    log_init();       /* 初始化日志输出 */
   105d5:	e8 16 27 00 00       	call   12cf0 <log_init>
    gdt_init();       /* 初始化gdt */
   105da:	e8 3e ff ff ff       	call   1051d <gdt_init>
    memory_init(mem); /* 初始化内存管理情况 */
   105df:	83 ec 0c             	sub    $0xc,%esp
   105e2:	ff 75 08             	pushl  0x8(%ebp)
   105e5:	e8 9f 08 00 00       	call   10e89 <memory_init>
   105ea:	83 c4 10             	add    $0x10,%esp
    irq_init();       /* 初始化中断描述符表 */
   105ed:	e8 5e 01 00 00       	call   10750 <irq_init>
    pagetable_init(); /* 初始化页表 */
   105f2:	e8 07 0e 00 00       	call   113fe <pagetable_init>
    // task_init(main);  /* 初始化进程 */
    tss_task_init();
   105f7:	e8 f9 27 00 00       	call   12df5 <tss_task_init>
    timer_init();   /* 初始化定时器 */
   105fc:	e8 ea fc ff ff       	call   102eb <timer_init>
    syscall_init(); /* 初始化系统调用 */
   10601:	e8 23 11 00 00       	call   11729 <syscall_init>
}
   10606:	90                   	nop
   10607:	c9                   	leave  
   10608:	c3                   	ret    

00010609 <main>:

void main()
{
   10609:	8d 4c 24 04          	lea    0x4(%esp),%ecx
   1060d:	83 e4 f0             	and    $0xfffffff0,%esp
   10610:	ff 71 fc             	pushl  -0x4(%ecx)
   10613:	55                   	push   %ebp
   10614:	89 e5                	mov    %esp,%ebp
   10616:	51                   	push   %ecx
   10617:	83 ec 04             	sub    $0x4,%esp
    first_proc_init();
   1061a:	e8 3b 1d 00 00       	call   1235a <first_proc_init>

    for (;;)
   1061f:	eb fe                	jmp    1061f <main+0x16>

00010621 <hlt>:
{
   10621:	55                   	push   %ebp
   10622:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   10624:	f4                   	hlt    
}
   10625:	90                   	nop
   10626:	5d                   	pop    %ebp
   10627:	c3                   	ret    

00010628 <cli>:
{
   10628:	55                   	push   %ebp
   10629:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("cli");
   1062b:	fa                   	cli    
}
   1062c:	90                   	nop
   1062d:	5d                   	pop    %ebp
   1062e:	c3                   	ret    

0001062f <sti>:
{
   1062f:	55                   	push   %ebp
   10630:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("sti");
   10632:	fb                   	sti    
}
   10633:	90                   	nop
   10634:	5d                   	pop    %ebp
   10635:	c3                   	ret    

00010636 <inb>:
{
   10636:	55                   	push   %ebp
   10637:	89 e5                	mov    %esp,%ebp
   10639:	83 ec 14             	sub    $0x14,%esp
   1063c:	8b 45 08             	mov    0x8(%ebp),%eax
   1063f:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[port], %[rv]"
   10643:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   10647:	89 c2                	mov    %eax,%edx
   10649:	ec                   	in     (%dx),%al
   1064a:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   1064d:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   10651:	c9                   	leave  
   10652:	c3                   	ret    

00010653 <outb>:
{
   10653:	55                   	push   %ebp
   10654:	89 e5                	mov    %esp,%ebp
   10656:	83 ec 08             	sub    $0x8,%esp
   10659:	8b 55 08             	mov    0x8(%ebp),%edx
   1065c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1065f:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   10663:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[data], %[port]"
   10666:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   1066a:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   1066e:	ee                   	out    %al,(%dx)
}
   1066f:	90                   	nop
   10670:	c9                   	leave  
   10671:	c3                   	ret    

00010672 <lidt>:
 *
 * @param start
 * @param size
 */
static inline void lidt(uint32_t start, uint32_t size)
{
   10672:	55                   	push   %ebp
   10673:	89 e5                	mov    %esp,%ebp
   10675:	83 ec 10             	sub    $0x10,%esp
        uint16_t limit;
        uint16_t start15_0;
        uint16_t start31_16;
    } idt;

    idt.start31_16 = start >> 16;
   10678:	8b 45 08             	mov    0x8(%ebp),%eax
   1067b:	c1 e8 10             	shr    $0x10,%eax
   1067e:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    idt.start15_0 = start & 0xFFFF;
   10682:	8b 45 08             	mov    0x8(%ebp),%eax
   10685:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    idt.limit = size - 1;
   10689:	8b 45 0c             	mov    0xc(%ebp),%eax
   1068c:	83 e8 01             	sub    $0x1,%eax
   1068f:	66 89 45 fa          	mov    %ax,-0x6(%ebp)

    __asm__ __volatile__("lidt %0" ::"m"(idt));
   10693:	0f 01 5d fa          	lidtl  -0x6(%ebp)
}
   10697:	90                   	nop
   10698:	c9                   	leave  
   10699:	c3                   	ret    

0001069a <pic_enable>:
#include "tools/klib.h"

extern irq_desc_t idt_table[IDT_SIZE];

void pic_enable(uint8_t pic_num)
{
   1069a:	55                   	push   %ebp
   1069b:	89 e5                	mov    %esp,%ebp
   1069d:	53                   	push   %ebx
   1069e:	83 ec 24             	sub    $0x24,%esp
   106a1:	8b 45 08             	mov    0x8(%ebp),%eax
   106a4:	88 45 e4             	mov    %al,-0x1c(%ebp)
    if (pic_num < PIC_START)
   106a7:	80 7d e4 1f          	cmpb   $0x1f,-0x1c(%ebp)
   106ab:	77 15                	ja     106c2 <pic_enable+0x28>
    {
        klog_printf("pic_enable erro: init failed");
   106ad:	83 ec 0c             	sub    $0xc,%esp
   106b0:	68 13 33 01 00       	push   $0x13313
   106b5:	e8 38 1d 00 00       	call   123f2 <klog_printf>
   106ba:	83 c4 10             	add    $0x10,%esp
        return;
   106bd:	e9 89 00 00 00       	jmp    1074b <pic_enable+0xb1>
    }

    pic_num -= PIC_START;
   106c2:	80 6d e4 20          	subb   $0x20,-0x1c(%ebp)

    /* irq[0 - 8] */
    if (pic_num < 8)
   106c6:	80 7d e4 07          	cmpb   $0x7,-0x1c(%ebp)
   106ca:	77 3c                	ja     10708 <pic_enable+0x6e>
    {
        int mask = inb(PIC_M_DATA) & ~(1 << pic_num);
   106cc:	83 ec 0c             	sub    $0xc,%esp
   106cf:	6a 21                	push   $0x21
   106d1:	e8 60 ff ff ff       	call   10636 <inb>
   106d6:	83 c4 10             	add    $0x10,%esp
   106d9:	0f b6 d0             	movzbl %al,%edx
   106dc:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   106e0:	bb 01 00 00 00       	mov    $0x1,%ebx
   106e5:	89 c1                	mov    %eax,%ecx
   106e7:	d3 e3                	shl    %cl,%ebx
   106e9:	89 d8                	mov    %ebx,%eax
   106eb:	f7 d0                	not    %eax
   106ed:	21 d0                	and    %edx,%eax
   106ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
        outb(PIC_M_DATA, mask);
   106f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106f5:	0f b6 c0             	movzbl %al,%eax
   106f8:	83 ec 08             	sub    $0x8,%esp
   106fb:	50                   	push   %eax
   106fc:	6a 21                	push   $0x21
   106fe:	e8 50 ff ff ff       	call   10653 <outb>
   10703:	83 c4 10             	add    $0x10,%esp
   10706:	eb 43                	jmp    1074b <pic_enable+0xb1>
    }
    /* irq[9 - 15] */
    else
    {
        int mask = inb(PIC_S_DATA) & ~(1 << (pic_num - 8));
   10708:	83 ec 0c             	sub    $0xc,%esp
   1070b:	68 a1 00 00 00       	push   $0xa1
   10710:	e8 21 ff ff ff       	call   10636 <inb>
   10715:	83 c4 10             	add    $0x10,%esp
   10718:	0f b6 c0             	movzbl %al,%eax
   1071b:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
   1071f:	83 ea 08             	sub    $0x8,%edx
   10722:	bb 01 00 00 00       	mov    $0x1,%ebx
   10727:	89 d1                	mov    %edx,%ecx
   10729:	d3 e3                	shl    %cl,%ebx
   1072b:	89 da                	mov    %ebx,%edx
   1072d:	f7 d2                	not    %edx
   1072f:	21 d0                	and    %edx,%eax
   10731:	89 45 f4             	mov    %eax,-0xc(%ebp)
        outb(PIC_S_DATA, mask);
   10734:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10737:	0f b6 c0             	movzbl %al,%eax
   1073a:	83 ec 08             	sub    $0x8,%esp
   1073d:	50                   	push   %eax
   1073e:	68 a1 00 00 00       	push   $0xa1
   10743:	e8 0b ff ff ff       	call   10653 <outb>
   10748:	83 c4 10             	add    $0x10,%esp
    }
}
   1074b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1074e:	c9                   	leave  
   1074f:	c3                   	ret    

00010750 <irq_init>:
/**
 * @brief 初始化中断向量表
 *
 */
void irq_init()
{
   10750:	55                   	push   %ebp
   10751:	89 e5                	mov    %esp,%ebp
   10753:	83 ec 18             	sub    $0x18,%esp
    /* 初始化中断代理 */
    pic_init();
   10756:	e8 5b 02 00 00       	call   109b6 <pic_init>

    for (int i = 0; i < IDT_SIZE; i++)
   1075b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10762:	eb 25                	jmp    10789 <irq_init+0x39>
    {
        irq_segment_set(idt_table + i, KERNEL_SELECTOR_CS, (uint32_t)ENTRY(unknown), GATE_TYPE_IDT | GATE_P | GATE_DPL_0);
   10764:	ba 2b 00 01 00       	mov    $0x1002b,%edx
   10769:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1076c:	c1 e0 03             	shl    $0x3,%eax
   1076f:	05 00 a0 01 00       	add    $0x1a000,%eax
   10774:	68 00 8e 00 00       	push   $0x8e00
   10779:	52                   	push   %edx
   1077a:	6a 08                	push   $0x8
   1077c:	50                   	push   %eax
   1077d:	e8 9a 01 00 00       	call   1091c <irq_segment_set>
   10782:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < IDT_SIZE; i++)
   10785:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10789:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   10790:	7e d2                	jle    10764 <irq_init+0x14>
    }

    /****************中断程序安装区域*********************/
    irq_install(IRQ0_DE, (irq_handler_t)ENTRY(divider));
   10792:	83 ec 08             	sub    $0x8,%esp
   10795:	68 48 00 01 00       	push   $0x10048
   1079a:	6a 00                	push   $0x0
   1079c:	e8 d1 01 00 00       	call   10972 <irq_install>
   107a1:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ1_DB, (irq_handler_t)ENTRY(debug));
   107a4:	83 ec 08             	sub    $0x8,%esp
   107a7:	68 65 00 01 00       	push   $0x10065
   107ac:	6a 01                	push   $0x1
   107ae:	e8 bf 01 00 00       	call   10972 <irq_install>
   107b3:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ2_NMI, (irq_handler_t)ENTRY(NMI));
   107b6:	83 ec 08             	sub    $0x8,%esp
   107b9:	68 82 00 01 00       	push   $0x10082
   107be:	6a 02                	push   $0x2
   107c0:	e8 ad 01 00 00       	call   10972 <irq_install>
   107c5:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ3_BP, (irq_handler_t)ENTRY(breakpoint));
   107c8:	83 ec 08             	sub    $0x8,%esp
   107cb:	68 9f 00 01 00       	push   $0x1009f
   107d0:	6a 03                	push   $0x3
   107d2:	e8 9b 01 00 00       	call   10972 <irq_install>
   107d7:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ4_OF, (irq_handler_t)ENTRY(overflow));
   107da:	83 ec 08             	sub    $0x8,%esp
   107dd:	68 bc 00 01 00       	push   $0x100bc
   107e2:	6a 04                	push   $0x4
   107e4:	e8 89 01 00 00       	call   10972 <irq_install>
   107e9:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ5_BR, (irq_handler_t)ENTRY(bound_range));
   107ec:	83 ec 08             	sub    $0x8,%esp
   107ef:	68 d9 00 01 00       	push   $0x100d9
   107f4:	6a 05                	push   $0x5
   107f6:	e8 77 01 00 00       	call   10972 <irq_install>
   107fb:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ6_UD, (irq_handler_t)ENTRY(invalid_opcode));
   107fe:	83 ec 08             	sub    $0x8,%esp
   10801:	68 f6 00 01 00       	push   $0x100f6
   10806:	6a 06                	push   $0x6
   10808:	e8 65 01 00 00       	call   10972 <irq_install>
   1080d:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ7_NM, (irq_handler_t)ENTRY(device_unfound));
   10810:	83 ec 08             	sub    $0x8,%esp
   10813:	68 13 01 01 00       	push   $0x10113
   10818:	6a 07                	push   $0x7
   1081a:	e8 53 01 00 00       	call   10972 <irq_install>
   1081f:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ8_DF, (irq_handler_t)ENTRY(double_fault));
   10822:	83 ec 08             	sub    $0x8,%esp
   10825:	68 30 01 01 00       	push   $0x10130
   1082a:	6a 08                	push   $0x8
   1082c:	e8 41 01 00 00       	call   10972 <irq_install>
   10831:	83 c4 10             	add    $0x10,%esp
    // irq_install(IRQ9_MF, (irq_handler_t)ENTRY(divider));
    irq_install(IRQ10_TS, (irq_handler_t)ENTRY(invalid_tss));
   10834:	83 ec 08             	sub    $0x8,%esp
   10837:	68 4b 01 01 00       	push   $0x1014b
   1083c:	6a 0a                	push   $0xa
   1083e:	e8 2f 01 00 00       	call   10972 <irq_install>
   10843:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ11_NP, (irq_handler_t)ENTRY(segment_not_present));
   10846:	83 ec 08             	sub    $0x8,%esp
   10849:	68 66 01 01 00       	push   $0x10166
   1084e:	6a 0b                	push   $0xb
   10850:	e8 1d 01 00 00       	call   10972 <irq_install>
   10855:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ12_SS, (irq_handler_t)ENTRY(stack_segment_fault));
   10858:	83 ec 08             	sub    $0x8,%esp
   1085b:	68 81 01 01 00       	push   $0x10181
   10860:	6a 0c                	push   $0xc
   10862:	e8 0b 01 00 00       	call   10972 <irq_install>
   10867:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ13_GP, (irq_handler_t)ENTRY(general_protection));
   1086a:	83 ec 08             	sub    $0x8,%esp
   1086d:	68 9c 01 01 00       	push   $0x1019c
   10872:	6a 0d                	push   $0xd
   10874:	e8 f9 00 00 00       	call   10972 <irq_install>
   10879:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ14_PF, (irq_handler_t)ENTRY(page_fault));
   1087c:	83 ec 08             	sub    $0x8,%esp
   1087f:	68 b7 01 01 00       	push   $0x101b7
   10884:	6a 0e                	push   $0xe
   10886:	e8 e7 00 00 00       	call   10972 <irq_install>
   1088b:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ16_MF, (irq_handler_t)ENTRY(float_point_error));
   1088e:	83 ec 08             	sub    $0x8,%esp
   10891:	68 d2 01 01 00       	push   $0x101d2
   10896:	6a 10                	push   $0x10
   10898:	e8 d5 00 00 00       	call   10972 <irq_install>
   1089d:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ17_AC, (irq_handler_t)ENTRY(aligment_check));
   108a0:	83 ec 08             	sub    $0x8,%esp
   108a3:	68 ef 01 01 00       	push   $0x101ef
   108a8:	6a 11                	push   $0x11
   108aa:	e8 c3 00 00 00       	call   10972 <irq_install>
   108af:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ18_MC, (irq_handler_t)ENTRY(machine_check));
   108b2:	83 ec 08             	sub    $0x8,%esp
   108b5:	68 0a 02 01 00       	push   $0x1020a
   108ba:	6a 12                	push   $0x12
   108bc:	e8 b1 00 00 00       	call   10972 <irq_install>
   108c1:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ19_XM, (irq_handler_t)ENTRY(SIMD));
   108c4:	83 ec 08             	sub    $0x8,%esp
   108c7:	68 27 02 01 00       	push   $0x10227
   108cc:	6a 13                	push   $0x13
   108ce:	e8 9f 00 00 00       	call   10972 <irq_install>
   108d3:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ20_VE, (irq_handler_t)ENTRY(virtual_exception));
   108d6:	83 ec 08             	sub    $0x8,%esp
   108d9:	68 44 02 01 00       	push   $0x10244
   108de:	6a 14                	push   $0x14
   108e0:	e8 8d 00 00 00       	call   10972 <irq_install>
   108e5:	83 c4 10             	add    $0x10,%esp
    /****************中断程序安装区域*********************/
    /****************系统调用单独给一个特权级*************/
    irq_segment_set(idt_table + IRQ128_INT, KERNEL_SELECTOR_CS, (uint32_t)syscall_handler, GATE_TYPE_IDT | GATE_P | GATE_DPL_3);
   108e8:	ba 7e 02 01 00       	mov    $0x1027e,%edx
   108ed:	b8 00 a4 01 00       	mov    $0x1a400,%eax
   108f2:	68 00 ee 00 00       	push   $0xee00
   108f7:	52                   	push   %edx
   108f8:	6a 08                	push   $0x8
   108fa:	50                   	push   %eax
   108fb:	e8 1c 00 00 00       	call   1091c <irq_segment_set>
   10900:	83 c4 10             	add    $0x10,%esp
    /****************系统调用单独给一个特权级*************/
    lidt((uint32_t)idt_table, sizeof(irq_desc_t) * IDT_SIZE);
   10903:	b8 00 a0 01 00       	mov    $0x1a000,%eax
   10908:	83 ec 08             	sub    $0x8,%esp
   1090b:	68 00 08 00 00       	push   $0x800
   10910:	50                   	push   %eax
   10911:	e8 5c fd ff ff       	call   10672 <lidt>
   10916:	83 c4 10             	add    $0x10,%esp

    return;
   10919:	90                   	nop
}
   1091a:	c9                   	leave  
   1091b:	c3                   	ret    

0001091c <irq_segment_set>:
 * @param attr 中断门的属性
 * @return true
 * @return false
 */
bool irq_segment_set(irq_desc_t *desc, uint16_t selector, uint32_t offset, uint16_t attr)
{
   1091c:	55                   	push   %ebp
   1091d:	89 e5                	mov    %esp,%ebp
   1091f:	83 ec 08             	sub    $0x8,%esp
   10922:	8b 55 0c             	mov    0xc(%ebp),%edx
   10925:	8b 45 14             	mov    0x14(%ebp),%eax
   10928:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   1092c:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    if (offset > 0xFFFFF)
   10930:	81 7d 10 ff ff 0f 00 	cmpl   $0xfffff,0x10(%ebp)
   10937:	76 07                	jbe    10940 <irq_segment_set+0x24>
    {
        return false;
   10939:	b8 00 00 00 00       	mov    $0x0,%eax
   1093e:	eb 30                	jmp    10970 <irq_segment_set+0x54>
    }

    desc->limit15_0 = offset & 0xFFFF;
   10940:	8b 45 10             	mov    0x10(%ebp),%eax
   10943:	89 c2                	mov    %eax,%edx
   10945:	8b 45 08             	mov    0x8(%ebp),%eax
   10948:	66 89 10             	mov    %dx,(%eax)
    desc->selector = selector;
   1094b:	8b 45 08             	mov    0x8(%ebp),%eax
   1094e:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   10952:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->attribute = attr;
   10956:	8b 45 08             	mov    0x8(%ebp),%eax
   10959:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
   1095d:	66 89 50 04          	mov    %dx,0x4(%eax)
    desc->limit31_16 = (offset >> 16) & 0xFFFF;
   10961:	8b 45 10             	mov    0x10(%ebp),%eax
   10964:	c1 e8 10             	shr    $0x10,%eax
   10967:	89 c2                	mov    %eax,%edx
   10969:	8b 45 08             	mov    0x8(%ebp),%eax
   1096c:	66 89 50 06          	mov    %dx,0x6(%eax)
}
   10970:	c9                   	leave  
   10971:	c3                   	ret    

00010972 <irq_install>:
 *
 * @param irq_num 中断向量号
 * @param handler 中断函数
 */
bool irq_install(uint16_t irq_num, irq_handler_t handler)
{
   10972:	55                   	push   %ebp
   10973:	89 e5                	mov    %esp,%ebp
   10975:	83 ec 04             	sub    $0x4,%esp
   10978:	8b 45 08             	mov    0x8(%ebp),%eax
   1097b:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    if (irq_num >= IDT_SIZE)
   1097f:	66 81 7d fc ff 00    	cmpw   $0xff,-0x4(%ebp)
   10985:	76 07                	jbe    1098e <irq_install+0x1c>
    {
        return false;
   10987:	b8 00 00 00 00       	mov    $0x0,%eax
   1098c:	eb 26                	jmp    109b4 <irq_install+0x42>
    }
    irq_segment_set(idt_table + irq_num, KERNEL_SELECTOR_CS, (uint32_t)handler, GATE_TYPE_IDT | GATE_P | GATE_DPL_0);
   1098e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10991:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   10995:	c1 e2 03             	shl    $0x3,%edx
   10998:	81 c2 00 a0 01 00    	add    $0x1a000,%edx
   1099e:	68 00 8e 00 00       	push   $0x8e00
   109a3:	50                   	push   %eax
   109a4:	6a 08                	push   $0x8
   109a6:	52                   	push   %edx
   109a7:	e8 70 ff ff ff       	call   1091c <irq_segment_set>
   109ac:	83 c4 10             	add    $0x10,%esp
    return true;
   109af:	b8 01 00 00 00       	mov    $0x1,%eax
}
   109b4:	c9                   	leave  
   109b5:	c3                   	ret    

000109b6 <pic_init>:

void pic_init()
{
   109b6:	55                   	push   %ebp
   109b7:	89 e5                	mov    %esp,%ebp

    /* 初始化主片 */
    outb(PIC_M_CTRL, 0x11); // ICW1：边沿触发 + 级联8259A + 需要ICW4
   109b9:	6a 11                	push   $0x11
   109bb:	6a 20                	push   $0x20
   109bd:	e8 91 fc ff ff       	call   10653 <outb>
   109c2:	83 c4 08             	add    $0x8,%esp
    outb(PIC_M_DATA, 0x20); // ICW2：起始中断向量号是0x20（32）IR[0 - 7]为0x20~0x27
   109c5:	6a 20                	push   $0x20
   109c7:	6a 21                	push   $0x21
   109c9:	e8 85 fc ff ff       	call   10653 <outb>
   109ce:	83 c4 08             	add    $0x8,%esp

    outb(PIC_M_DATA, 0x04); // ICW3：IR2接从片
   109d1:	6a 04                	push   $0x4
   109d3:	6a 21                	push   $0x21
   109d5:	e8 79 fc ff ff       	call   10653 <outb>
   109da:	83 c4 08             	add    $0x8,%esp
    outb(PIC_M_DATA, 0x01); // ICW4：8086模式，非自动EOI
   109dd:	6a 01                	push   $0x1
   109df:	6a 21                	push   $0x21
   109e1:	e8 6d fc ff ff       	call   10653 <outb>
   109e6:	83 c4 08             	add    $0x8,%esp

    /* 初始化从片 */
    outb(PIC_S_CTRL, 0x11); // ICW1：边沿触发 + 级联8259A + 需要ICW4
   109e9:	6a 11                	push   $0x11
   109eb:	68 a0 00 00 00       	push   $0xa0
   109f0:	e8 5e fc ff ff       	call   10653 <outb>
   109f5:	83 c4 08             	add    $0x8,%esp
    outb(PIC_S_DATA, 0x28); // ICW2：起始中断向量号为0x28（40）IR[8 - 15]为0x28~0x2F
   109f8:	6a 28                	push   $0x28
   109fa:	68 a1 00 00 00       	push   $0xa1
   109ff:	e8 4f fc ff ff       	call   10653 <outb>
   10a04:	83 c4 08             	add    $0x8,%esp

    outb(PIC_S_DATA, 0x02); // ICW3：设置从片到主片的IR2引脚
   10a07:	6a 02                	push   $0x2
   10a09:	68 a1 00 00 00       	push   $0xa1
   10a0e:	e8 40 fc ff ff       	call   10653 <outb>
   10a13:	83 c4 08             	add    $0x8,%esp
    outb(PIC_S_DATA, 0x01); // ICW4：8086模式，正常EOI
   10a16:	6a 01                	push   $0x1
   10a18:	68 a1 00 00 00       	push   $0xa1
   10a1d:	e8 31 fc ff ff       	call   10653 <outb>
   10a22:	83 c4 08             	add    $0x8,%esp
}
   10a25:	90                   	nop
   10a26:	c9                   	leave  
   10a27:	c3                   	ret    

00010a28 <irq_handler_unknown>:

/* 未知异常 */
void irq_handler_unknown(trap_frame_t *trapframe)
{
   10a28:	55                   	push   %ebp
   10a29:	89 e5                	mov    %esp,%ebp
    // hlt();
    // for (;;)
    //     ;
    return;
   10a2b:	90                   	nop
}
   10a2c:	5d                   	pop    %ebp
   10a2d:	c3                   	ret    

00010a2e <irq_handler_divider>:

/* 除0异常 */
void irq_handler_divider(trap_frame_t *trapframe)
{
   10a2e:	55                   	push   %ebp
   10a2f:	89 e5                	mov    %esp,%ebp
    // hlt();
    // for (;;)
    //     ;
    return;
   10a31:	90                   	nop
}
   10a32:	5d                   	pop    %ebp
   10a33:	c3                   	ret    

00010a34 <irq_handler_debug>:

void irq_handler_debug(trap_frame_t *trapframe)
{
   10a34:	55                   	push   %ebp
   10a35:	89 e5                	mov    %esp,%ebp
    hlt();
   10a37:	e8 e5 fb ff ff       	call   10621 <hlt>
    for (;;)
   10a3c:	eb fe                	jmp    10a3c <irq_handler_debug+0x8>

00010a3e <irq_handler_NMI>:
        ;
}
void irq_handler_NMI(trap_frame_t *trapframe)
{
   10a3e:	55                   	push   %ebp
   10a3f:	89 e5                	mov    %esp,%ebp
    hlt();
   10a41:	e8 db fb ff ff       	call   10621 <hlt>
    for (;;)
   10a46:	eb fe                	jmp    10a46 <irq_handler_NMI+0x8>

00010a48 <irq_handler_breakpoint>:
        ;
}
void irq_handler_breakpoint(trap_frame_t *trapframe)
{
   10a48:	55                   	push   %ebp
   10a49:	89 e5                	mov    %esp,%ebp
    hlt();
   10a4b:	e8 d1 fb ff ff       	call   10621 <hlt>
    for (;;)
   10a50:	eb fe                	jmp    10a50 <irq_handler_breakpoint+0x8>

00010a52 <irq_handler_overflow>:
        ;
}
void irq_handler_overflow(trap_frame_t *trapframe)
{
   10a52:	55                   	push   %ebp
   10a53:	89 e5                	mov    %esp,%ebp
    hlt();
   10a55:	e8 c7 fb ff ff       	call   10621 <hlt>
    for (;;)
   10a5a:	eb fe                	jmp    10a5a <irq_handler_overflow+0x8>

00010a5c <irq_handler_bound_range>:
        ;
}
void irq_handler_bound_range(trap_frame_t *trapframe)
{
   10a5c:	55                   	push   %ebp
   10a5d:	89 e5                	mov    %esp,%ebp
    hlt();
   10a5f:	e8 bd fb ff ff       	call   10621 <hlt>
    for (;;)
   10a64:	eb fe                	jmp    10a64 <irq_handler_bound_range+0x8>

00010a66 <irq_handler_invalid_opcode>:
        ;
}
void irq_handler_invalid_opcode(trap_frame_t *trapframe)
{
   10a66:	55                   	push   %ebp
   10a67:	89 e5                	mov    %esp,%ebp
    hlt();
   10a69:	e8 b3 fb ff ff       	call   10621 <hlt>
    for (;;)
   10a6e:	eb fe                	jmp    10a6e <irq_handler_invalid_opcode+0x8>

00010a70 <irq_handler_device_unfound>:
        ;
}
void irq_handler_device_unfound(trap_frame_t *trapframe)
{
   10a70:	55                   	push   %ebp
   10a71:	89 e5                	mov    %esp,%ebp
    hlt();
   10a73:	e8 a9 fb ff ff       	call   10621 <hlt>
    for (;;)
   10a78:	eb fe                	jmp    10a78 <irq_handler_device_unfound+0x8>

00010a7a <irq_handler_double_fault>:
        ;
}
void irq_handler_double_fault(trap_frame_t *trapframe)
{
   10a7a:	55                   	push   %ebp
   10a7b:	89 e5                	mov    %esp,%ebp
    hlt();
   10a7d:	e8 9f fb ff ff       	call   10621 <hlt>
    for (;;)
   10a82:	eb fe                	jmp    10a82 <irq_handler_double_fault+0x8>

00010a84 <irq_handler_invalid_tss>:
        ;
}
void irq_handler_invalid_tss(trap_frame_t *trapframe)
{
   10a84:	55                   	push   %ebp
   10a85:	89 e5                	mov    %esp,%ebp
    hlt();
   10a87:	e8 95 fb ff ff       	call   10621 <hlt>
    for (;;)
   10a8c:	eb fe                	jmp    10a8c <irq_handler_invalid_tss+0x8>

00010a8e <irq_handler_segment_not_present>:
        ;
}
void irq_handler_segment_not_present(trap_frame_t *trapframe)
{
   10a8e:	55                   	push   %ebp
   10a8f:	89 e5                	mov    %esp,%ebp
    hlt();
   10a91:	e8 8b fb ff ff       	call   10621 <hlt>
    for (;;)
   10a96:	eb fe                	jmp    10a96 <irq_handler_segment_not_present+0x8>

00010a98 <irq_handler_stack_segment_fault>:
        ;
}
void irq_handler_stack_segment_fault(trap_frame_t *trapframe)
{
   10a98:	55                   	push   %ebp
   10a99:	89 e5                	mov    %esp,%ebp
    hlt();
   10a9b:	e8 81 fb ff ff       	call   10621 <hlt>
    for (;;)
   10aa0:	eb fe                	jmp    10aa0 <irq_handler_stack_segment_fault+0x8>

00010aa2 <irq_handler_general_protection>:
        ;
}
void irq_handler_general_protection(trap_frame_t *trapframe)
{
   10aa2:	55                   	push   %ebp
   10aa3:	89 e5                	mov    %esp,%ebp
    hlt();
   10aa5:	e8 77 fb ff ff       	call   10621 <hlt>
    for (;;)
   10aaa:	eb fe                	jmp    10aaa <irq_handler_general_protection+0x8>

00010aac <irq_handler_page_fault>:
        ;
}
void irq_handler_page_fault(trap_frame_t *trapframe)
{
   10aac:	55                   	push   %ebp
   10aad:	89 e5                	mov    %esp,%ebp
    hlt();
   10aaf:	e8 6d fb ff ff       	call   10621 <hlt>
    for (;;)
   10ab4:	eb fe                	jmp    10ab4 <irq_handler_page_fault+0x8>

00010ab6 <irq_handler_float_point_error>:
        ;
}
void irq_handler_float_point_error(trap_frame_t *trapframe)
{
   10ab6:	55                   	push   %ebp
   10ab7:	89 e5                	mov    %esp,%ebp
    hlt();
   10ab9:	e8 63 fb ff ff       	call   10621 <hlt>
    for (;;)
   10abe:	eb fe                	jmp    10abe <irq_handler_float_point_error+0x8>

00010ac0 <irq_handler_aligment_check>:
        ;
}
void irq_handler_aligment_check(trap_frame_t *trapframe)
{
   10ac0:	55                   	push   %ebp
   10ac1:	89 e5                	mov    %esp,%ebp
    hlt();
   10ac3:	e8 59 fb ff ff       	call   10621 <hlt>
    for (;;)
   10ac8:	eb fe                	jmp    10ac8 <irq_handler_aligment_check+0x8>

00010aca <irq_handler_machine_check>:
        ;
}
void irq_handler_machine_check(trap_frame_t *trapframe)
{
   10aca:	55                   	push   %ebp
   10acb:	89 e5                	mov    %esp,%ebp
    hlt();
   10acd:	e8 4f fb ff ff       	call   10621 <hlt>
    for (;;)
   10ad2:	eb fe                	jmp    10ad2 <irq_handler_machine_check+0x8>

00010ad4 <irq_handler_SIMD>:
        ;
}
void irq_handler_SIMD(trap_frame_t *trapframe)
{
   10ad4:	55                   	push   %ebp
   10ad5:	89 e5                	mov    %esp,%ebp
    hlt();
   10ad7:	e8 45 fb ff ff       	call   10621 <hlt>
    for (;;)
   10adc:	eb fe                	jmp    10adc <irq_handler_SIMD+0x8>

00010ade <irq_handler_virtual_exception>:
        ;
}

void irq_handler_virtual_exception(trap_frame_t *trapframe)
{
   10ade:	55                   	push   %ebp
   10adf:	89 e5                	mov    %esp,%ebp
    hlt();
   10ae1:	e8 3b fb ff ff       	call   10621 <hlt>
    for (;;)
   10ae6:	eb fe                	jmp    10ae6 <irq_handler_virtual_exception+0x8>

00010ae8 <irq_enable>:
 * @brief 打开中断
 *
 * @return irq_status 操作之前的状态
 */
irq_status irq_enable()
{
   10ae8:	55                   	push   %ebp
   10ae9:	89 e5                	mov    %esp,%ebp
   10aeb:	83 ec 18             	sub    $0x18,%esp
    irq_status old_status = get_irq_status();
   10aee:	e8 31 00 00 00       	call   10b24 <get_irq_status>
   10af3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (old_status == INTR_OFF)
   10af6:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
   10afa:	75 05                	jne    10b01 <irq_enable+0x19>
    {
        sti();
   10afc:	e8 2e fb ff ff       	call   1062f <sti>
    }
    return old_status;
   10b01:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10b04:	c9                   	leave  
   10b05:	c3                   	ret    

00010b06 <irq_disable>:
 * @brief 关闭中断
 *
 * @return irq_status 操作之前的状态
 */
irq_status irq_disable()
{
   10b06:	55                   	push   %ebp
   10b07:	89 e5                	mov    %esp,%ebp
   10b09:	83 ec 18             	sub    $0x18,%esp
    irq_status old_status = get_irq_status();
   10b0c:	e8 13 00 00 00       	call   10b24 <get_irq_status>
   10b11:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (old_status == INTR_ON)
   10b14:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10b18:	75 05                	jne    10b1f <irq_disable+0x19>
    {
        cli();
   10b1a:	e8 09 fb ff ff       	call   10628 <cli>
    }
    return old_status;
   10b1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10b22:	c9                   	leave  
   10b23:	c3                   	ret    

00010b24 <get_irq_status>:
 * @brief 取得中断的状态
 *
 * @return irq_status
 */
irq_status get_irq_status()
{
   10b24:	55                   	push   %ebp
   10b25:	89 e5                	mov    %esp,%ebp
   10b27:	83 ec 10             	sub    $0x10,%esp
    uint32_t elfags = 0;
   10b2a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    GET_EFLAGS(elfags);
   10b31:	9c                   	pushf  
   10b32:	58                   	pop    %eax
   10b33:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (EFLAGS_IF & elfags) ? INTR_ON : INTR_OFF;
   10b36:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10b39:	25 00 02 00 00       	and    $0x200,%eax
   10b3e:	85 c0                	test   %eax,%eax
   10b40:	0f 94 c0             	sete   %al
   10b43:	0f b6 c0             	movzbl %al,%eax
}
   10b46:	c9                   	leave  
   10b47:	c3                   	ret    

00010b48 <irq_enter_protection>:
 * @brief 关中断并保留关中断前的状态
 *
 * @return irq_status
 */
irq_status irq_enter_protection()
{
   10b48:	55                   	push   %ebp
   10b49:	89 e5                	mov    %esp,%ebp
   10b4b:	83 ec 18             	sub    $0x18,%esp
    irq_status status = irq_disable();
   10b4e:	e8 b3 ff ff ff       	call   10b06 <irq_disable>
   10b53:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return status;
   10b56:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10b59:	c9                   	leave  
   10b5a:	c3                   	ret    

00010b5b <irq_leave_protection>:
 *
 * @param status
 * @return irq_status
 */
irq_status irq_leave_protection(irq_status status)
{
   10b5b:	55                   	push   %ebp
   10b5c:	89 e5                	mov    %esp,%ebp
   10b5e:	83 ec 08             	sub    $0x8,%esp
    irq_set_status(status);
   10b61:	83 ec 0c             	sub    $0xc,%esp
   10b64:	ff 75 08             	pushl  0x8(%ebp)
   10b67:	e8 06 00 00 00       	call   10b72 <irq_set_status>
   10b6c:	83 c4 10             	add    $0x10,%esp
}
   10b6f:	90                   	nop
   10b70:	c9                   	leave  
   10b71:	c3                   	ret    

00010b72 <irq_set_status>:

irq_status irq_set_status(irq_status status)
{
   10b72:	55                   	push   %ebp
   10b73:	89 e5                	mov    %esp,%ebp
   10b75:	83 ec 08             	sub    $0x8,%esp
    return (status == INTR_ON) ? irq_enable() : irq_disable();
   10b78:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10b7c:	75 07                	jne    10b85 <irq_set_status+0x13>
   10b7e:	e8 65 ff ff ff       	call   10ae8 <irq_enable>
   10b83:	eb 05                	jmp    10b8a <irq_set_status+0x18>
   10b85:	e8 7c ff ff ff       	call   10b06 <irq_disable>
   10b8a:	c9                   	leave  
   10b8b:	c3                   	ret    

00010b8c <bitmap_init>:
 * @param bitmap
 * @param count
 * @param start
 */
void bitmap_init(bitmap_t *bitmap, int count, uint8_t *bits)
{
   10b8c:	55                   	push   %ebp
   10b8d:	89 e5                	mov    %esp,%ebp
   10b8f:	83 ec 18             	sub    $0x18,%esp
    bitmap->count = count;
   10b92:	8b 45 08             	mov    0x8(%ebp),%eax
   10b95:	8b 55 0c             	mov    0xc(%ebp),%edx
   10b98:	89 10                	mov    %edx,(%eax)
    bitmap->bits = bits;
   10b9a:	8b 45 08             	mov    0x8(%ebp),%eax
   10b9d:	8b 55 10             	mov    0x10(%ebp),%edx
   10ba0:	89 50 04             	mov    %edx,0x4(%eax)
    int num = bitmap_get_bytes(bitmap->count);
   10ba3:	8b 45 08             	mov    0x8(%ebp),%eax
   10ba6:	8b 00                	mov    (%eax),%eax
   10ba8:	83 ec 0c             	sub    $0xc,%esp
   10bab:	50                   	push   %eax
   10bac:	e8 20 00 00 00       	call   10bd1 <bitmap_get_bytes>
   10bb1:	83 c4 10             	add    $0x10,%esp
   10bb4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kmemset(bitmap->bits, 0, num);
   10bb7:	8b 45 08             	mov    0x8(%ebp),%eax
   10bba:	8b 40 04             	mov    0x4(%eax),%eax
   10bbd:	83 ec 04             	sub    $0x4,%esp
   10bc0:	ff 75 f4             	pushl  -0xc(%ebp)
   10bc3:	6a 00                	push   $0x0
   10bc5:	50                   	push   %eax
   10bc6:	e8 a9 17 00 00       	call   12374 <kmemset>
   10bcb:	83 c4 10             	add    $0x10,%esp
}
   10bce:	90                   	nop
   10bcf:	c9                   	leave  
   10bd0:	c3                   	ret    

00010bd1 <bitmap_get_bytes>:
 * @brief 取得位图需要占用的字节/取得位图数组的大小
 *
 * @param count
 */
int bitmap_get_bytes(int count)
{
   10bd1:	55                   	push   %ebp
   10bd2:	89 e5                	mov    %esp,%ebp
    /*向上取整*/
    return (count + 8 - 1) / 8;
   10bd4:	8b 45 08             	mov    0x8(%ebp),%eax
   10bd7:	83 c0 07             	add    $0x7,%eax
   10bda:	8d 50 07             	lea    0x7(%eax),%edx
   10bdd:	85 c0                	test   %eax,%eax
   10bdf:	0f 48 c2             	cmovs  %edx,%eax
   10be2:	c1 f8 03             	sar    $0x3,%eax
}
   10be5:	5d                   	pop    %ebp
   10be6:	c3                   	ret    

00010be7 <bitmap_set_bit>:
 * @param index
 * @param count
 * @param bit 1/0
 */
void bitmap_set_bit(bitmap_t *bitmap, int index, int count, int bit)
{
   10be7:	55                   	push   %ebp
   10be8:	89 e5                	mov    %esp,%ebp
   10bea:	56                   	push   %esi
   10beb:	53                   	push   %ebx
   10bec:	83 ec 10             	sub    $0x10,%esp
    if (index >= bitmap->count)
   10bef:	8b 45 08             	mov    0x8(%ebp),%eax
   10bf2:	8b 00                	mov    (%eax),%eax
   10bf4:	39 45 0c             	cmp    %eax,0xc(%ebp)
   10bf7:	0f 8d c2 00 00 00    	jge    10cbf <bitmap_set_bit+0xd8>
    {
        /*超出边界*/
        return;
    }

    int cnt = index + count;
   10bfd:	8b 55 0c             	mov    0xc(%ebp),%edx
   10c00:	8b 45 10             	mov    0x10(%ebp),%eax
   10c03:	01 d0                	add    %edx,%eax
   10c05:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (int i = index; i < cnt; i++)
   10c08:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10c0e:	e9 9e 00 00 00       	jmp    10cb1 <bitmap_set_bit+0xca>
    {
        if (bit)
   10c13:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   10c17:	74 4a                	je     10c63 <bitmap_set_bit+0x7c>
        {
            /*置1*/
            bitmap->bits[i / 8] |= 0x01 << (i % 8);
   10c19:	8b 45 08             	mov    0x8(%ebp),%eax
   10c1c:	8b 50 04             	mov    0x4(%eax),%edx
   10c1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10c22:	8d 48 07             	lea    0x7(%eax),%ecx
   10c25:	85 c0                	test   %eax,%eax
   10c27:	0f 48 c1             	cmovs  %ecx,%eax
   10c2a:	c1 f8 03             	sar    $0x3,%eax
   10c2d:	89 c3                	mov    %eax,%ebx
   10c2f:	89 d8                	mov    %ebx,%eax
   10c31:	01 d0                	add    %edx,%eax
   10c33:	0f b6 00             	movzbl (%eax),%eax
   10c36:	89 c6                	mov    %eax,%esi
   10c38:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10c3b:	99                   	cltd   
   10c3c:	c1 ea 1d             	shr    $0x1d,%edx
   10c3f:	01 d0                	add    %edx,%eax
   10c41:	83 e0 07             	and    $0x7,%eax
   10c44:	29 d0                	sub    %edx,%eax
   10c46:	ba 01 00 00 00       	mov    $0x1,%edx
   10c4b:	89 c1                	mov    %eax,%ecx
   10c4d:	d3 e2                	shl    %cl,%edx
   10c4f:	89 d0                	mov    %edx,%eax
   10c51:	89 f2                	mov    %esi,%edx
   10c53:	09 c2                	or     %eax,%edx
   10c55:	8b 45 08             	mov    0x8(%ebp),%eax
   10c58:	8b 40 04             	mov    0x4(%eax),%eax
   10c5b:	89 d9                	mov    %ebx,%ecx
   10c5d:	01 c8                	add    %ecx,%eax
   10c5f:	88 10                	mov    %dl,(%eax)
   10c61:	eb 4a                	jmp    10cad <bitmap_set_bit+0xc6>
        }
        else
        {
            /*置0*/
            bitmap->bits[i / 8] &= ~(0x01 << (i % 8));
   10c63:	8b 45 08             	mov    0x8(%ebp),%eax
   10c66:	8b 50 04             	mov    0x4(%eax),%edx
   10c69:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10c6c:	8d 48 07             	lea    0x7(%eax),%ecx
   10c6f:	85 c0                	test   %eax,%eax
   10c71:	0f 48 c1             	cmovs  %ecx,%eax
   10c74:	c1 f8 03             	sar    $0x3,%eax
   10c77:	89 c3                	mov    %eax,%ebx
   10c79:	89 d8                	mov    %ebx,%eax
   10c7b:	01 d0                	add    %edx,%eax
   10c7d:	0f b6 00             	movzbl (%eax),%eax
   10c80:	89 c6                	mov    %eax,%esi
   10c82:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10c85:	99                   	cltd   
   10c86:	c1 ea 1d             	shr    $0x1d,%edx
   10c89:	01 d0                	add    %edx,%eax
   10c8b:	83 e0 07             	and    $0x7,%eax
   10c8e:	29 d0                	sub    %edx,%eax
   10c90:	ba 01 00 00 00       	mov    $0x1,%edx
   10c95:	89 c1                	mov    %eax,%ecx
   10c97:	d3 e2                	shl    %cl,%edx
   10c99:	89 d0                	mov    %edx,%eax
   10c9b:	f7 d0                	not    %eax
   10c9d:	89 f2                	mov    %esi,%edx
   10c9f:	21 c2                	and    %eax,%edx
   10ca1:	8b 45 08             	mov    0x8(%ebp),%eax
   10ca4:	8b 40 04             	mov    0x4(%eax),%eax
   10ca7:	89 d9                	mov    %ebx,%ecx
   10ca9:	01 c8                	add    %ecx,%eax
   10cab:	88 10                	mov    %dl,(%eax)
    for (int i = index; i < cnt; i++)
   10cad:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10cb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cb4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   10cb7:	0f 8c 56 ff ff ff    	jl     10c13 <bitmap_set_bit+0x2c>
   10cbd:	eb 01                	jmp    10cc0 <bitmap_set_bit+0xd9>
        return;
   10cbf:	90                   	nop
        }
    }
}
   10cc0:	83 c4 10             	add    $0x10,%esp
   10cc3:	5b                   	pop    %ebx
   10cc4:	5e                   	pop    %esi
   10cc5:	5d                   	pop    %ebp
   10cc6:	c3                   	ret    

00010cc7 <bitmap_get_bit>:
 * @param bitmap
 * @param index
 * @return int
 */
int bitmap_get_bit(bitmap_t *bitmap, int index)
{
   10cc7:	55                   	push   %ebp
   10cc8:	89 e5                	mov    %esp,%ebp
   10cca:	53                   	push   %ebx
    return (bitmap->bits[index / 8] & (0x01 << (index % 8))) ? 1 : 0;
   10ccb:	8b 45 08             	mov    0x8(%ebp),%eax
   10cce:	8b 50 04             	mov    0x4(%eax),%edx
   10cd1:	8b 45 0c             	mov    0xc(%ebp),%eax
   10cd4:	8d 48 07             	lea    0x7(%eax),%ecx
   10cd7:	85 c0                	test   %eax,%eax
   10cd9:	0f 48 c1             	cmovs  %ecx,%eax
   10cdc:	c1 f8 03             	sar    $0x3,%eax
   10cdf:	01 d0                	add    %edx,%eax
   10ce1:	0f b6 00             	movzbl (%eax),%eax
   10ce4:	0f b6 d8             	movzbl %al,%ebx
   10ce7:	8b 45 0c             	mov    0xc(%ebp),%eax
   10cea:	99                   	cltd   
   10ceb:	c1 ea 1d             	shr    $0x1d,%edx
   10cee:	01 d0                	add    %edx,%eax
   10cf0:	83 e0 07             	and    $0x7,%eax
   10cf3:	29 d0                	sub    %edx,%eax
   10cf5:	89 c1                	mov    %eax,%ecx
   10cf7:	d3 fb                	sar    %cl,%ebx
   10cf9:	89 d8                	mov    %ebx,%eax
   10cfb:	83 e0 01             	and    $0x1,%eax
}
   10cfe:	5b                   	pop    %ebx
   10cff:	5d                   	pop    %ebp
   10d00:	c3                   	ret    

00010d01 <bitmap_is_set>:
 * @param index
 * @return true
 * @return false
 */
bool bitmap_is_set(bitmap_t *bitmap, int index)
{
   10d01:	55                   	push   %ebp
   10d02:	89 e5                	mov    %esp,%ebp
    return bitmap_get_bit(bitmap, index) ? true : false;
   10d04:	ff 75 0c             	pushl  0xc(%ebp)
   10d07:	ff 75 08             	pushl  0x8(%ebp)
   10d0a:	e8 b8 ff ff ff       	call   10cc7 <bitmap_get_bit>
   10d0f:	83 c4 08             	add    $0x8,%esp
   10d12:	85 c0                	test   %eax,%eax
   10d14:	0f 95 c0             	setne  %al
   10d17:	0f b6 c0             	movzbl %al,%eax
}
   10d1a:	c9                   	leave  
   10d1b:	c3                   	ret    

00010d1c <bitmap_alloc_nbits>:
 * @param index 起始下标
 * @param count 数目
 * @return i or -1
 */
int bitmap_alloc_nbits(bitmap_t *bitmap, int index, int count)
{
   10d1c:	55                   	push   %ebp
   10d1d:	89 e5                	mov    %esp,%ebp
   10d1f:	83 ec 10             	sub    $0x10,%esp
    int i = index;
   10d22:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d25:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (i < bitmap->count)
   10d28:	e9 81 00 00 00       	jmp    10dae <bitmap_alloc_nbits+0x92>
    {
        /* 如果找到合适的位置 */
        if (bitmap_get_bit(bitmap, i) == 0)
   10d2d:	ff 75 fc             	pushl  -0x4(%ebp)
   10d30:	ff 75 08             	pushl  0x8(%ebp)
   10d33:	e8 8f ff ff ff       	call   10cc7 <bitmap_get_bit>
   10d38:	83 c4 08             	add    $0x8,%esp
   10d3b:	85 c0                	test   %eax,%eax
   10d3d:	75 6b                	jne    10daa <bitmap_alloc_nbits+0x8e>
        {
            bool flag = false;
   10d3f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
            for (int j = i; (j < bitmap->count) && (j - i + 1 <= count); j++)
   10d46:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10d49:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10d4c:	eb 26                	jmp    10d74 <bitmap_alloc_nbits+0x58>
            {
                if (bitmap_get_bit(bitmap, j) == 1)
   10d4e:	ff 75 f4             	pushl  -0xc(%ebp)
   10d51:	ff 75 08             	pushl  0x8(%ebp)
   10d54:	e8 6e ff ff ff       	call   10cc7 <bitmap_get_bit>
   10d59:	83 c4 08             	add    $0x8,%esp
   10d5c:	83 f8 01             	cmp    $0x1,%eax
   10d5f:	75 0f                	jne    10d70 <bitmap_alloc_nbits+0x54>
                {
                    flag = true;
   10d61:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
                    i = j;
   10d68:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d6b:	89 45 fc             	mov    %eax,-0x4(%ebp)
                    break;
   10d6e:	eb 1c                	jmp    10d8c <bitmap_alloc_nbits+0x70>
            for (int j = i; (j < bitmap->count) && (j - i + 1 <= count); j++)
   10d70:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10d74:	8b 45 08             	mov    0x8(%ebp),%eax
   10d77:	8b 00                	mov    (%eax),%eax
   10d79:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   10d7c:	7d 0e                	jge    10d8c <bitmap_alloc_nbits+0x70>
   10d7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d81:	2b 45 fc             	sub    -0x4(%ebp),%eax
   10d84:	83 c0 01             	add    $0x1,%eax
   10d87:	39 45 10             	cmp    %eax,0x10(%ebp)
   10d8a:	7d c2                	jge    10d4e <bitmap_alloc_nbits+0x32>
                }
            }

            /* 成功找到合适的位置 */
            if (flag == false)
   10d8c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   10d90:	75 18                	jne    10daa <bitmap_alloc_nbits+0x8e>
            {
                /* 在位图上做标记 */
                bitmap_set_bit(bitmap, i, count, 1);
   10d92:	6a 01                	push   $0x1
   10d94:	ff 75 10             	pushl  0x10(%ebp)
   10d97:	ff 75 fc             	pushl  -0x4(%ebp)
   10d9a:	ff 75 08             	pushl  0x8(%ebp)
   10d9d:	e8 45 fe ff ff       	call   10be7 <bitmap_set_bit>
   10da2:	83 c4 10             	add    $0x10,%esp
                return i;
   10da5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10da8:	eb 17                	jmp    10dc1 <bitmap_alloc_nbits+0xa5>
            }
        }
        i++;
   10daa:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while (i < bitmap->count)
   10dae:	8b 45 08             	mov    0x8(%ebp),%eax
   10db1:	8b 00                	mov    (%eax),%eax
   10db3:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   10db6:	0f 8c 71 ff ff ff    	jl     10d2d <bitmap_alloc_nbits+0x11>
    }
    return -1;
   10dbc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10dc1:	c9                   	leave  
   10dc2:	c3                   	ret    

00010dc3 <kfree_pages>:
 * @param addr
 * @param n
 * @return int
 */
int kfree_pages(uint32_t addr, int n)
{
   10dc3:	55                   	push   %ebp
   10dc4:	89 e5                	mov    %esp,%ebp
   10dc6:	83 ec 18             	sub    $0x18,%esp
    /* 此处需要上锁 */
    uint32_t pg_idx = (addr - addr_manager.kernelstart) / addr_manager.page_size;
   10dc9:	a1 0c 80 01 00       	mov    0x1800c,%eax
   10dce:	8b 55 08             	mov    0x8(%ebp),%edx
   10dd1:	29 c2                	sub    %eax,%edx
   10dd3:	89 d0                	mov    %edx,%eax
   10dd5:	8b 0d 08 80 01 00    	mov    0x18008,%ecx
   10ddb:	ba 00 00 00 00       	mov    $0x0,%edx
   10de0:	f7 f1                	div    %ecx
   10de2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bitmap_set_bit(&addr_manager.bitmap, pg_idx, n, 0);
   10de5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10de8:	6a 00                	push   $0x0
   10dea:	ff 75 0c             	pushl  0xc(%ebp)
   10ded:	50                   	push   %eax
   10dee:	68 00 80 01 00       	push   $0x18000
   10df3:	e8 ef fd ff ff       	call   10be7 <bitmap_set_bit>
   10df8:	83 c4 10             	add    $0x10,%esp
    /* 此处需要上锁 */
    return 0;
   10dfb:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10e00:	c9                   	leave  
   10e01:	c3                   	ret    

00010e02 <kalloc_pages>:
 * @brief 在内核空间分配n个页
 *
 * @return uint32_t
 */
uint32_t kalloc_pages(int n)
{
   10e02:	55                   	push   %ebp
   10e03:	89 e5                	mov    %esp,%ebp
   10e05:	83 ec 18             	sub    $0x18,%esp
    /* 此处需要加锁 */
    /* 找到待分配内存在bitmap中的下标 */
    int page_index = bitmap_alloc_nbits(&addr_manager.bitmap, 0, n);
   10e08:	83 ec 04             	sub    $0x4,%esp
   10e0b:	ff 75 08             	pushl  0x8(%ebp)
   10e0e:	6a 00                	push   $0x0
   10e10:	68 00 80 01 00       	push   $0x18000
   10e15:	e8 02 ff ff ff       	call   10d1c <bitmap_alloc_nbits>
   10e1a:	83 c4 10             	add    $0x10,%esp
   10e1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /* 超出内核区域的范围 */
    if (page_index >= 1023)
   10e20:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
   10e27:	7e 07                	jle    10e30 <kalloc_pages+0x2e>
    {
        return 0;
   10e29:	b8 00 00 00 00       	mov    $0x0,%eax
   10e2e:	eb 1a                	jmp    10e4a <kalloc_pages+0x48>
    }

    if (page_index >= 0)
   10e30:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e34:	78 0f                	js     10e45 <kalloc_pages+0x43>
    {
        /* 返回地址信息 */
        return addr_manager.kernelstart + page_index * MEM_PAGE_SIZE;
   10e36:	a1 0c 80 01 00       	mov    0x1800c,%eax
   10e3b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   10e3e:	c1 e2 0c             	shl    $0xc,%edx
   10e41:	01 d0                	add    %edx,%eax
   10e43:	eb 05                	jmp    10e4a <kalloc_pages+0x48>
    }
    return 0;
   10e45:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10e4a:	c9                   	leave  
   10e4b:	c3                   	ret    

00010e4c <ualloc_pages>:
 *
 * @param n
 * @return uint32_t
 */
uint32_t ualloc_pages(int n)
{
   10e4c:	55                   	push   %ebp
   10e4d:	89 e5                	mov    %esp,%ebp
   10e4f:	83 ec 18             	sub    $0x18,%esp
    /* 此处需要加锁 */
    /* 找到待分配内存在bitmap中的下标 */
    int page_index = bitmap_alloc_nbits(&addr_manager.bitmap,
   10e52:	83 ec 04             	sub    $0x4,%esp
   10e55:	ff 75 08             	pushl  0x8(%ebp)
   10e58:	68 00 01 00 00       	push   $0x100
   10e5d:	68 00 80 01 00       	push   $0x18000
   10e62:	e8 b5 fe ff ff       	call   10d1c <bitmap_alloc_nbits>
   10e67:	83 c4 10             	add    $0x10,%esp
   10e6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                        (MEM_USERFREE_START - MEM_KERNELFREE_START) / MEM_PAGE_SIZE,
                                        n);
    if (page_index >= 0)
   10e6d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e71:	78 0f                	js     10e82 <ualloc_pages+0x36>
    {
        /* 返回地址信息 */
        return addr_manager.kernelstart + page_index * MEM_PAGE_SIZE;
   10e73:	a1 0c 80 01 00       	mov    0x1800c,%eax
   10e78:	8b 55 f4             	mov    -0xc(%ebp),%edx
   10e7b:	c1 e2 0c             	shl    $0xc,%edx
   10e7e:	01 d0                	add    %edx,%eax
   10e80:	eb 05                	jmp    10e87 <ualloc_pages+0x3b>
    }
    return 0;
   10e82:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10e87:	c9                   	leave  
   10e88:	c3                   	ret    

00010e89 <memory_init>:

void memory_init(mem_info_t *mem_info)
{
   10e89:	55                   	push   %ebp
   10e8a:	89 e5                	mov    %esp,%ebp
   10e8c:	83 ec 18             	sub    $0x18,%esp
    /* 0x80000Byte以内的最后空间 */
    extern uint8_t *free_addr;
    uint8_t *mem_free = (uint8_t *)&free_addr;
   10e8f:	c7 45 f4 00 a8 01 00 	movl   $0x1a800,-0xc(%ebp)

    /* 获取1MB以上可用空间的大小 */
    /* 此处有些不准确 */
    uint32_t mem_free_size = total_mem_size(mem_info) - MEM_KERNELFREE_START;
   10e96:	83 ec 0c             	sub    $0xc,%esp
   10e99:	ff 75 08             	pushl  0x8(%ebp)
   10e9c:	e8 49 00 00 00       	call   10eea <total_mem_size>
   10ea1:	83 c4 10             	add    $0x10,%esp
   10ea4:	2d 00 00 10 00       	sub    $0x100000,%eax
   10ea9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    mem_free_size = DOWN2(mem_free_size, MEM_PAGE_SIZE);
   10eac:	81 65 f0 00 f0 ff ff 	andl   $0xfffff000,-0x10(%ebp)
    /* 初始化内存分配管理器 */
    /* bitmap的大小最大为4 * 1024 * 1024 * 1024 / 4096 / 8 = 128kb */
    /* 1MB~2MB可用来存放在内核相关的东西, 2MB~128MB可用来存放用户空间的东西 */
    alloc_init(mem_free, mem_free_size, MEM_KERNELFREE_START, MEM_USERFREE_START, MEM_PAGE_SIZE);
   10eb3:	83 ec 0c             	sub    $0xc,%esp
   10eb6:	68 00 10 00 00       	push   $0x1000
   10ebb:	68 00 00 20 00       	push   $0x200000
   10ec0:	68 00 00 10 00       	push   $0x100000
   10ec5:	ff 75 f0             	pushl  -0x10(%ebp)
   10ec8:	ff 75 f4             	pushl  -0xc(%ebp)
   10ecb:	e8 54 00 00 00       	call   10f24 <alloc_init>
   10ed0:	83 c4 20             	add    $0x20,%esp
    /* 存放位图过的空间不算在剩余空间里面 */
    mem_free += bitmap_get_bytes(addr_manager.bitmap.count);
   10ed3:	a1 00 80 01 00       	mov    0x18000,%eax
   10ed8:	83 ec 0c             	sub    $0xc,%esp
   10edb:	50                   	push   %eax
   10edc:	e8 f0 fc ff ff       	call   10bd1 <bitmap_get_bytes>
   10ee1:	83 c4 10             	add    $0x10,%esp
   10ee4:	01 45 f4             	add    %eax,-0xc(%ebp)
    ASSERT(mem_free < (uint8_t *)MEM_EBDA_START);
}
   10ee7:	90                   	nop
   10ee8:	c9                   	leave  
   10ee9:	c3                   	ret    

00010eea <total_mem_size>:
 *
 * @param mem_info
 * @return uint32_t
 */
uint32_t total_mem_size(mem_info_t *mem_info)
{
   10eea:	55                   	push   %ebp
   10eeb:	89 e5                	mov    %esp,%ebp
   10eed:	83 ec 10             	sub    $0x10,%esp
    /*需要上锁*/
    uint32_t mem_size = 0;
   10ef0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for (int i = 0; i < mem_info->count; i++)
   10ef7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   10efe:	eb 11                	jmp    10f11 <total_mem_size+0x27>
    {
        mem_size += mem_info->info[i].offset;
   10f00:	8b 45 08             	mov    0x8(%ebp),%eax
   10f03:	8b 55 f8             	mov    -0x8(%ebp),%edx
   10f06:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
   10f0a:	01 45 fc             	add    %eax,-0x4(%ebp)
    for (int i = 0; i < mem_info->count; i++)
   10f0d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   10f11:	8b 45 08             	mov    0x8(%ebp),%eax
   10f14:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   10f1a:	39 45 f8             	cmp    %eax,-0x8(%ebp)
   10f1d:	7c e1                	jl     10f00 <total_mem_size+0x16>
    }
    return mem_size;
   10f1f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10f22:	c9                   	leave  
   10f23:	c3                   	ret    

00010f24 <alloc_init>:

void alloc_init(uint8_t *bits, uint32_t size, uint32_t kstart, uint32_t ustart, uint32_t page_size)
{
   10f24:	55                   	push   %ebp
   10f25:	89 e5                	mov    %esp,%ebp
   10f27:	83 ec 08             	sub    $0x8,%esp
    /*需要上锁*/
    addr_manager.kernelstart = kstart;
   10f2a:	8b 45 10             	mov    0x10(%ebp),%eax
   10f2d:	a3 0c 80 01 00       	mov    %eax,0x1800c
    addr_manager.userstart = ustart;
   10f32:	8b 45 14             	mov    0x14(%ebp),%eax
   10f35:	a3 10 80 01 00       	mov    %eax,0x18010
    addr_manager.size = size;
   10f3a:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f3d:	a3 14 80 01 00       	mov    %eax,0x18014
    addr_manager.page_size = page_size;
   10f42:	8b 45 18             	mov    0x18(%ebp),%eax
   10f45:	a3 08 80 01 00       	mov    %eax,0x18008
    /*初始化位图*/
    bitmap_init(&addr_manager.bitmap, addr_manager.size / page_size, bits);
   10f4a:	a1 14 80 01 00       	mov    0x18014,%eax
   10f4f:	ba 00 00 00 00       	mov    $0x0,%edx
   10f54:	f7 75 18             	divl   0x18(%ebp)
   10f57:	83 ec 04             	sub    $0x4,%esp
   10f5a:	ff 75 08             	pushl  0x8(%ebp)
   10f5d:	50                   	push   %eax
   10f5e:	68 00 80 01 00       	push   $0x18000
   10f63:	e8 24 fc ff ff       	call   10b8c <bitmap_init>
   10f68:	83 c4 10             	add    $0x10,%esp
   10f6b:	90                   	nop
   10f6c:	c9                   	leave  
   10f6d:	c3                   	ret    

00010f6e <rcr0>:
{
   10f6e:	55                   	push   %ebp
   10f6f:	89 e5                	mov    %esp,%ebp
   10f71:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__("mov %%cr0, %[rv]"
   10f74:	0f 20 c0             	mov    %cr0,%eax
   10f77:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return rv;
   10f7a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10f7d:	c9                   	leave  
   10f7e:	c3                   	ret    

00010f7f <wcr0>:
{
   10f7f:	55                   	push   %ebp
   10f80:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("mov %[data], %%cr0" ::[data] "r"(data));
   10f82:	8b 45 08             	mov    0x8(%ebp),%eax
   10f85:	0f 22 c0             	mov    %eax,%cr0
}
   10f88:	90                   	nop
   10f89:	5d                   	pop    %ebp
   10f8a:	c3                   	ret    

00010f8b <wcr3>:
{
   10f8b:	55                   	push   %ebp
   10f8c:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("mov %[data], %%cr3" ::[data] "r"(data));
   10f8e:	8b 45 08             	mov    0x8(%ebp),%eax
   10f91:	0f 22 d8             	mov    %eax,%cr3
}
   10f94:	90                   	nop
   10f95:	5d                   	pop    %ebp
   10f96:	c3                   	ret    

00010f97 <create_kernel_table>:

extern pde_t kernel_table[NPDE];
extern addr_alloc_t addr_manager;

void create_kernel_table()
{
   10f97:	55                   	push   %ebp
   10f98:	89 e5                	mov    %esp,%ebp
   10f9a:	83 ec 28             	sub    $0x28,%esp
        {sdata, (void *)(MEM_EBDA_START - 1), sdata, PTE_W | PTE_U},                                                    // 内核数据区
        {(void *)MEM_KERNELFREE_START, (void *)(MEM_KERNELFREE_END * 10), (void *)MEM_KERNELFREE_START, PTE_W | PTE_U}, // 内核空闲区
    };

    /* 初始化页目录表 */
    kmemset(kernel_table, 0, sizeof(kernel_table));
   10f9d:	83 ec 04             	sub    $0x4,%esp
   10fa0:	68 00 10 00 00       	push   $0x1000
   10fa5:	6a 00                	push   $0x0
   10fa7:	68 00 90 01 00       	push   $0x19000
   10fac:	e8 c3 13 00 00       	call   12374 <kmemset>
   10fb1:	83 c4 10             	add    $0x10,%esp

    /*根据映射关系开始建立页表*/
    for (int i = 0; i < sizeof(kernel_map) / sizeof(mmu_manager_t); i++)
   10fb4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10fbb:	eb 70                	jmp    1102d <create_kernel_table+0x96>
    {
        mmu_manager_t *map = kernel_map + i;
   10fbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10fc0:	c1 e0 04             	shl    $0x4,%eax
   10fc3:	05 00 40 01 00       	add    $0x14000,%eax
   10fc8:	89 45 f0             	mov    %eax,-0x10(%ebp)
        int vstart = DOWN2((uint32_t)map->vstart, MEM_PAGE_SIZE);
   10fcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10fce:	8b 00                	mov    (%eax),%eax
   10fd0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
   10fd5:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int vend = UP2((uint32_t)map->vend, MEM_PAGE_SIZE);
   10fd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10fdb:	8b 40 04             	mov    0x4(%eax),%eax
   10fde:	05 ff 0f 00 00       	add    $0xfff,%eax
   10fe3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
   10fe8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int npage = (vend - vstart) / MEM_PAGE_SIZE;
   10feb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10fee:	2b 45 ec             	sub    -0x14(%ebp),%eax
   10ff1:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
   10ff7:	85 c0                	test   %eax,%eax
   10ff9:	0f 48 c2             	cmovs  %edx,%eax
   10ffc:	c1 f8 0c             	sar    $0xc,%eax
   10fff:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        // klog_printf("start to map from vaddr[%x] to vend[%x], the page's number is [%d]\n",
        //             vstart, vend, npage);

        /* 实现虚拟地址到物理地址的映射 */
        vaddr2paddr(kernel_table, vstart, (uint32_t)map->pstart, npage, map->perm);
   11002:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11005:	8b 50 0c             	mov    0xc(%eax),%edx
   11008:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1100b:	8b 40 08             	mov    0x8(%eax),%eax
   1100e:	89 c1                	mov    %eax,%ecx
   11010:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11013:	83 ec 0c             	sub    $0xc,%esp
   11016:	52                   	push   %edx
   11017:	ff 75 e4             	pushl  -0x1c(%ebp)
   1101a:	51                   	push   %ecx
   1101b:	50                   	push   %eax
   1101c:	68 00 90 01 00       	push   $0x19000
   11021:	e8 e6 00 00 00       	call   1110c <vaddr2paddr>
   11026:	83 c4 20             	add    $0x20,%esp
    for (int i = 0; i < sizeof(kernel_map) / sizeof(mmu_manager_t); i++)
   11029:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1102d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11030:	83 f8 03             	cmp    $0x3,%eax
   11033:	76 88                	jbe    10fbd <create_kernel_table+0x26>
    }

    /* 切换页表 */
    /* 此处kernel_table的地址必须保持为4KB对齐 */
    // wcr4(rcr4() | CR4_PSE);
    wcr3((uint32_t)kernel_table);
   11035:	b8 00 90 01 00       	mov    $0x19000,%eax
   1103a:	83 ec 0c             	sub    $0xc,%esp
   1103d:	50                   	push   %eax
   1103e:	e8 48 ff ff ff       	call   10f8b <wcr3>
   11043:	83 c4 10             	add    $0x10,%esp
    wcr0(rcr0() | CR0_PG);
   11046:	e8 23 ff ff ff       	call   10f6e <rcr0>
   1104b:	0d 00 00 00 80       	or     $0x80000000,%eax
   11050:	83 ec 0c             	sub    $0xc,%esp
   11053:	50                   	push   %eax
   11054:	e8 26 ff ff ff       	call   10f7f <wcr0>
   11059:	83 c4 10             	add    $0x10,%esp
}
   1105c:	90                   	nop
   1105d:	c9                   	leave  
   1105e:	c3                   	ret    

0001105f <find_pte>:
 * @param dir
 * @param vaddr
 * @return pte_t*
 */
pte_t *find_pte(pde_t *dir, uint32_t vaddr)
{
   1105f:	55                   	push   %ebp
   11060:	89 e5                	mov    %esp,%ebp
   11062:	83 ec 18             	sub    $0x18,%esp
    /* 页表 */
    pte_t *page_table;

    /* 索引到页目录项 */
    pde_t *pde = dir + VADDR_DIR(vaddr);
   11065:	8b 45 0c             	mov    0xc(%ebp),%eax
   11068:	c1 e8 16             	shr    $0x16,%eax
   1106b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11072:	8b 45 08             	mov    0x8(%ebp),%eax
   11075:	01 d0                	add    %edx,%eax
   11077:	89 45 f0             	mov    %eax,-0x10(%ebp)

    /* 如果页表存在 */
    if (pde->present)
   1107a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1107d:	0f b6 00             	movzbl (%eax),%eax
   11080:	83 e0 01             	and    $0x1,%eax
   11083:	84 c0                	test   %al,%al
   11085:	74 27                	je     110ae <find_pte+0x4f>
    {
        /* 找到页表的地址 */
        page_table = (pte_t *)PDE_ADDR(pde);
   11087:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1108a:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   1108e:	c0 ea 04             	shr    $0x4,%dl
   11091:	0f b6 d2             	movzbl %dl,%edx
   11094:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   11098:	c1 e1 04             	shl    $0x4,%ecx
   1109b:	09 ca                	or     %ecx,%edx
   1109d:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   110a1:	c1 e0 0c             	shl    $0xc,%eax
   110a4:	09 d0                	or     %edx,%eax
   110a6:	c1 e0 0c             	shl    $0xc,%eax
   110a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
   110ac:	eb 45                	jmp    110f3 <find_pte+0x94>
    }
    /* 页表不存在 */
    else
    {
        /* 分配内存空间存储页表 */
        uint32_t page_table_addr = kalloc_pages(1);
   110ae:	83 ec 0c             	sub    $0xc,%esp
   110b1:	6a 01                	push   $0x1
   110b3:	e8 4a fd ff ff       	call   10e02 <kalloc_pages>
   110b8:	83 c4 10             	add    $0x10,%esp
   110bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (page_table_addr == 0)
   110be:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   110c2:	75 07                	jne    110cb <find_pte+0x6c>
        {
            return NULL;
   110c4:	b8 00 00 00 00       	mov    $0x0,%eax
   110c9:	eb 3f                	jmp    1110a <find_pte+0xab>
        }

        pde->v = page_table_addr | PDE_P | PDE_W | PDE_U;
   110cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   110ce:	83 c8 07             	or     $0x7,%eax
   110d1:	89 c2                	mov    %eax,%edx
   110d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110d6:	89 10                	mov    %edx,(%eax)

        /* 创建一个新的页表 */
        page_table = (pte_t *)page_table_addr;
   110d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   110db:	89 45 f4             	mov    %eax,-0xc(%ebp)
        /* 初始化页表 */
        kmemset(page_table, 0, MEM_PAGE_SIZE);
   110de:	83 ec 04             	sub    $0x4,%esp
   110e1:	68 00 10 00 00       	push   $0x1000
   110e6:	6a 00                	push   $0x0
   110e8:	ff 75 f4             	pushl  -0xc(%ebp)
   110eb:	e8 84 12 00 00       	call   12374 <kmemset>
   110f0:	83 c4 10             	add    $0x10,%esp
    }

    return page_table + VADDR_TABLE(vaddr);
   110f3:	8b 45 0c             	mov    0xc(%ebp),%eax
   110f6:	c1 e8 0c             	shr    $0xc,%eax
   110f9:	25 ff 03 00 00       	and    $0x3ff,%eax
   110fe:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11105:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11108:	01 d0                	add    %edx,%eax
}
   1110a:	c9                   	leave  
   1110b:	c3                   	ret    

0001110c <vaddr2paddr>:
 * @param paddr 物理地址
 * @param count 分配的页的数目
 * @param perm 属性
 */
void vaddr2paddr(pde_t *dir, uint32_t vaddr, uint32_t paddr, int count, uint32_t perm)
{
   1110c:	55                   	push   %ebp
   1110d:	89 e5                	mov    %esp,%ebp
   1110f:	83 ec 18             	sub    $0x18,%esp
    for (int i = 0; i < count; i++)
   11112:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11119:	eb 4e                	jmp    11169 <vaddr2paddr+0x5d>
    {
        /* 找到对应页表项 */
        pte_t *pte = find_pte(dir, vaddr);
   1111b:	83 ec 08             	sub    $0x8,%esp
   1111e:	ff 75 0c             	pushl  0xc(%ebp)
   11121:	ff 75 08             	pushl  0x8(%ebp)
   11124:	e8 36 ff ff ff       	call   1105f <find_pte>
   11129:	83 c4 10             	add    $0x10,%esp
   1112c:	89 45 f0             	mov    %eax,-0x10(%ebp)

        /* 如果页表未查到 */
        if (pte == NULL)
   1112f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11133:	75 12                	jne    11147 <vaddr2paddr+0x3b>
        {
            klog_printf("vaddr2paddr erro: map failed, pte have been existed");
   11135:	83 ec 0c             	sub    $0xc,%esp
   11138:	68 30 33 01 00       	push   $0x13330
   1113d:	e8 b0 12 00 00       	call   123f2 <klog_printf>
   11142:	83 c4 10             	add    $0x10,%esp
            return;
   11145:	eb 2a                	jmp    11171 <vaddr2paddr+0x65>
        }

        ASSERT(pte->present == 0);
        /* 设置页表项的属性 */
        pte->v = paddr | perm | PTE_P;
   11147:	8b 45 10             	mov    0x10(%ebp),%eax
   1114a:	0b 45 18             	or     0x18(%ebp),%eax
   1114d:	83 c8 01             	or     $0x1,%eax
   11150:	89 c2                	mov    %eax,%edx
   11152:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11155:	89 10                	mov    %edx,(%eax)
        // klog_printf("the pte's paddr is %x, its content is %x\n", (uint32_t)pte, pte->v);

        vaddr += MEM_PAGE_SIZE;
   11157:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
        paddr += MEM_PAGE_SIZE;
   1115e:	81 45 10 00 10 00 00 	addl   $0x1000,0x10(%ebp)
    for (int i = 0; i < count; i++)
   11165:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11169:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1116c:	3b 45 14             	cmp    0x14(%ebp),%eax
   1116f:	7c aa                	jl     1111b <vaddr2paddr+0xf>
    }
}
   11171:	c9                   	leave  
   11172:	c3                   	ret    

00011173 <pagetable_destroy>:

void pagetable_destroy(pde_t *dir)
{
   11173:	55                   	push   %ebp
   11174:	89 e5                	mov    %esp,%ebp
   11176:	83 ec 28             	sub    $0x28,%esp
    uint32_t user_pde_start = VADDR_DIR(MEM_KERNELFREE_END);
   11179:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    pde_t *pde = (pde_t *)dir + user_pde_start;
   11180:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11183:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1118a:	8b 45 08             	mov    0x8(%ebp),%eax
   1118d:	01 d0                	add    %edx,%eax
   1118f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ASSERT(dir != NULL);

    for (int i = user_pde_start; i < PDE_CNT; i++, pde++)
   11192:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11195:	89 45 f0             	mov    %eax,-0x10(%ebp)
   11198:	e9 cb 00 00 00       	jmp    11268 <pagetable_destroy+0xf5>
    {
        if (!pde->present)
   1119d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   111a0:	0f b6 00             	movzbl (%eax),%eax
   111a3:	83 e0 01             	and    $0x1,%eax
   111a6:	84 c0                	test   %al,%al
   111a8:	0f 84 b1 00 00 00    	je     1125f <pagetable_destroy+0xec>
        {
            continue;
        }

        // 获取页表的地址
        pte_t *pte = (pte_t *)PDE_ADDR(pde);
   111ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
   111b1:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   111b5:	c0 ea 04             	shr    $0x4,%dl
   111b8:	0f b6 d2             	movzbl %dl,%edx
   111bb:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   111bf:	c1 e1 04             	shl    $0x4,%ecx
   111c2:	09 ca                	or     %ecx,%edx
   111c4:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   111c8:	c1 e0 0c             	shl    $0xc,%eax
   111cb:	09 d0                	or     %edx,%eax
   111cd:	c1 e0 0c             	shl    $0xc,%eax
   111d0:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for (int j = 0; j < PTE_CNT; j++, pte++)
   111d3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   111da:	eb 48                	jmp    11224 <pagetable_destroy+0xb1>
        {
            if (!pte->present)
   111dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   111df:	0f b6 00             	movzbl (%eax),%eax
   111e2:	83 e0 01             	and    $0x1,%eax
   111e5:	84 c0                	test   %al,%al
   111e7:	74 32                	je     1121b <pagetable_destroy+0xa8>
            {
                continue;
            }
            kfree_pages(PTE_ADDR(pte), 1);
   111e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   111ec:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   111f0:	c0 ea 04             	shr    $0x4,%dl
   111f3:	0f b6 d2             	movzbl %dl,%edx
   111f6:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   111fa:	c1 e1 04             	shl    $0x4,%ecx
   111fd:	09 ca                	or     %ecx,%edx
   111ff:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   11203:	c1 e0 0c             	shl    $0xc,%eax
   11206:	09 d0                	or     %edx,%eax
   11208:	c1 e0 0c             	shl    $0xc,%eax
   1120b:	83 ec 08             	sub    $0x8,%esp
   1120e:	6a 01                	push   $0x1
   11210:	50                   	push   %eax
   11211:	e8 ad fb ff ff       	call   10dc3 <kfree_pages>
   11216:	83 c4 10             	add    $0x10,%esp
   11219:	eb 01                	jmp    1121c <pagetable_destroy+0xa9>
                continue;
   1121b:	90                   	nop
        for (int j = 0; j < PTE_CNT; j++, pte++)
   1121c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   11220:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   11224:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   1122b:	7e af                	jle    111dc <pagetable_destroy+0x69>
        }
        kfree_pages(PDE_ADDR(pde), 1);
   1122d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11230:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   11234:	c0 ea 04             	shr    $0x4,%dl
   11237:	0f b6 d2             	movzbl %dl,%edx
   1123a:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   1123e:	c1 e1 04             	shl    $0x4,%ecx
   11241:	09 ca                	or     %ecx,%edx
   11243:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   11247:	c1 e0 0c             	shl    $0xc,%eax
   1124a:	09 d0                	or     %edx,%eax
   1124c:	c1 e0 0c             	shl    $0xc,%eax
   1124f:	83 ec 08             	sub    $0x8,%esp
   11252:	6a 01                	push   $0x1
   11254:	50                   	push   %eax
   11255:	e8 69 fb ff ff       	call   10dc3 <kfree_pages>
   1125a:	83 c4 10             	add    $0x10,%esp
   1125d:	eb 01                	jmp    11260 <pagetable_destroy+0xed>
            continue;
   1125f:	90                   	nop
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++)
   11260:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11264:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   11268:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   1126f:	0f 8e 28 ff ff ff    	jle    1119d <pagetable_destroy+0x2a>
    }
    kfree_pages((uint32_t)dir, 1);
   11275:	8b 45 08             	mov    0x8(%ebp),%eax
   11278:	83 ec 08             	sub    $0x8,%esp
   1127b:	6a 01                	push   $0x1
   1127d:	50                   	push   %eax
   1127e:	e8 40 fb ff ff       	call   10dc3 <kfree_pages>
   11283:	83 c4 10             	add    $0x10,%esp
}
   11286:	90                   	nop
   11287:	c9                   	leave  
   11288:	c3                   	ret    

00011289 <copy_pagetable>:

uint32_t copy_pagetable(pde_t *dir)
{
   11289:	55                   	push   %ebp
   1128a:	89 e5                	mov    %esp,%ebp
   1128c:	83 ec 28             	sub    $0x28,%esp
    uint32_t to_page_dir = (uint32_t)create_page_table();
   1128f:	e8 03 01 00 00       	call   11397 <create_page_table>
   11294:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    /* 找到待复制页表的用户空间部分 */
    uint32_t user_pde_start = VADDR_DIR(MEM_KERNELFREE_END);
   11297:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    pde_t *pde = (pde_t *)dir + user_pde_start;
   1129e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   112a1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   112a8:	8b 45 08             	mov    0x8(%ebp),%eax
   112ab:	01 d0                	add    %edx,%eax
   112ad:	89 45 f4             	mov    %eax,-0xc(%ebp)

    /* 遍历页目录表 */
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++)
   112b0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   112b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
   112b6:	e9 ca 00 00 00       	jmp    11385 <copy_pagetable+0xfc>
    {
        if (!pde->present)
   112bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   112be:	0f b6 00             	movzbl (%eax),%eax
   112c1:	83 e0 01             	and    $0x1,%eax
   112c4:	84 c0                	test   %al,%al
   112c6:	0f 84 b0 00 00 00    	je     1137c <copy_pagetable+0xf3>
        {
            continue;
        }

        /* 取出页表的地址 */
        pte_t *pte = (pte_t *)PDE_ADDR(pde);
   112cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   112cf:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   112d3:	c0 ea 04             	shr    $0x4,%dl
   112d6:	0f b6 d2             	movzbl %dl,%edx
   112d9:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   112dd:	c1 e1 04             	shl    $0x4,%ecx
   112e0:	09 ca                	or     %ecx,%edx
   112e2:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   112e6:	c1 e0 0c             	shl    $0xc,%eax
   112e9:	09 d0                	or     %edx,%eax
   112eb:	c1 e0 0c             	shl    $0xc,%eax
   112ee:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for (int j = 0; j < PTE_CNT; j++, pte++)
   112f1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   112f8:	eb 77                	jmp    11371 <copy_pagetable+0xe8>
        {
            if (!pte->present)
   112fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
   112fd:	0f b6 00             	movzbl (%eax),%eax
   11300:	83 e0 01             	and    $0x1,%eax
   11303:	84 c0                	test   %al,%al
   11305:	74 61                	je     11368 <copy_pagetable+0xdf>
            {
                continue;
            }

            /* 分配物理页 */
            uint32_t page = ualloc_pages(1);
   11307:	83 ec 0c             	sub    $0xc,%esp
   1130a:	6a 01                	push   $0x1
   1130c:	e8 3b fb ff ff       	call   10e4c <ualloc_pages>
   11311:	83 c4 10             	add    $0x10,%esp
   11314:	89 45 dc             	mov    %eax,-0x24(%ebp)

            uint32_t vaddr = (i << 22) | (j << 12);
   11317:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1131a:	c1 e0 16             	shl    $0x16,%eax
   1131d:	89 c2                	mov    %eax,%edx
   1131f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11322:	c1 e0 0c             	shl    $0xc,%eax
   11325:	09 d0                	or     %edx,%eax
   11327:	89 45 d8             	mov    %eax,-0x28(%ebp)
            vaddr2paddr((pde_t *)to_page_dir, vaddr, page, 1, (pte->v & 0x1FF));
   1132a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1132d:	8b 00                	mov    (%eax),%eax
   1132f:	25 ff 01 00 00       	and    $0x1ff,%eax
   11334:	89 c2                	mov    %eax,%edx
   11336:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11339:	83 ec 0c             	sub    $0xc,%esp
   1133c:	52                   	push   %edx
   1133d:	6a 01                	push   $0x1
   1133f:	ff 75 dc             	pushl  -0x24(%ebp)
   11342:	ff 75 d8             	pushl  -0x28(%ebp)
   11345:	50                   	push   %eax
   11346:	e8 c1 fd ff ff       	call   1110c <vaddr2paddr>
   1134b:	83 c4 20             	add    $0x20,%esp

            /* 将内容拷贝过去 */
            kmemcpy((void *)page, (void *)vaddr, MEM_PAGE_SIZE);
   1134e:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11351:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11354:	83 ec 04             	sub    $0x4,%esp
   11357:	68 00 10 00 00       	push   $0x1000
   1135c:	52                   	push   %edx
   1135d:	50                   	push   %eax
   1135e:	e8 4c 10 00 00       	call   123af <kmemcpy>
   11363:	83 c4 10             	add    $0x10,%esp
   11366:	eb 01                	jmp    11369 <copy_pagetable+0xe0>
                continue;
   11368:	90                   	nop
        for (int j = 0; j < PTE_CNT; j++, pte++)
   11369:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   1136d:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   11371:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   11378:	7e 80                	jle    112fa <copy_pagetable+0x71>
   1137a:	eb 01                	jmp    1137d <copy_pagetable+0xf4>
            continue;
   1137c:	90                   	nop
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++)
   1137d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11381:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   11385:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   1138c:	0f 8e 29 ff ff ff    	jle    112bb <copy_pagetable+0x32>
        }
    }
    return to_page_dir;
   11392:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   11395:	c9                   	leave  
   11396:	c3                   	ret    

00011397 <create_page_table>:

uint32_t *create_page_table()
{
   11397:	55                   	push   %ebp
   11398:	89 e5                	mov    %esp,%ebp
   1139a:	83 ec 18             	sub    $0x18,%esp
    pde_t *dir = (pde_t *)ualloc_pages(1); /* 获取一页的空间存储页表 */
   1139d:	83 ec 0c             	sub    $0xc,%esp
   113a0:	6a 01                	push   $0x1
   113a2:	e8 a5 fa ff ff       	call   10e4c <ualloc_pages>
   113a7:	83 c4 10             	add    $0x10,%esp
   113aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ASSERT(dir != NULL);

    kmemset(dir, 0, MEM_PAGE_SIZE);
   113ad:	83 ec 04             	sub    $0x4,%esp
   113b0:	68 00 10 00 00       	push   $0x1000
   113b5:	6a 00                	push   $0x0
   113b7:	ff 75 f0             	pushl  -0x10(%ebp)
   113ba:	e8 b5 0f 00 00       	call   12374 <kmemset>
   113bf:	83 c4 10             	add    $0x10,%esp

    /* 建立内核空间的页目录项 */
    uint32_t user_pde_start = VADDR_DIR(MEM_KERNELFREE_END);
   113c2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for (int i = 0; i <= user_pde_start; i++)
   113c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   113d0:	eb 1f                	jmp    113f1 <create_page_table+0x5a>
    {
        dir[i].v = kernel_table[i].v;
   113d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   113d5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   113dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   113df:	01 c2                	add    %eax,%edx
   113e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   113e4:	8b 04 85 00 90 01 00 	mov    0x19000(,%eax,4),%eax
   113eb:	89 02                	mov    %eax,(%edx)
    for (int i = 0; i <= user_pde_start; i++)
   113ed:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   113f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   113f4:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   113f7:	73 d9                	jae    113d2 <create_page_table+0x3b>
    }
    /* 用户空间暂不建立 */

    return (uint32_t *)dir;
   113f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   113fc:	c9                   	leave  
   113fd:	c3                   	ret    

000113fe <pagetable_init>:

void pagetable_init() /*内核页表*/
{
   113fe:	55                   	push   %ebp
   113ff:	89 e5                	mov    %esp,%ebp
   11401:	83 ec 08             	sub    $0x8,%esp
    create_kernel_table();
   11404:	e8 8e fb ff ff       	call   10f97 <create_kernel_table>
}
   11409:	90                   	nop
   1140a:	c9                   	leave  
   1140b:	c3                   	ret    

0001140c <get_v2p>:
 *
 * @param dir
 * @return uint32_t
 */
uint32_t get_v2p(pde_t *dir, uint32_t vaddr)
{
   1140c:	55                   	push   %ebp
   1140d:	89 e5                	mov    %esp,%ebp
   1140f:	83 ec 18             	sub    $0x18,%esp
    pte_t *pte = find_pte(dir, vaddr);
   11412:	83 ec 08             	sub    $0x8,%esp
   11415:	ff 75 0c             	pushl  0xc(%ebp)
   11418:	ff 75 08             	pushl  0x8(%ebp)
   1141b:	e8 3f fc ff ff       	call   1105f <find_pte>
   11420:	83 c4 10             	add    $0x10,%esp
   11423:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return PTE_ADDR(pte) + (vaddr & 0xFFF);
   11426:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11429:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   1142d:	c0 ea 04             	shr    $0x4,%dl
   11430:	0f b6 d2             	movzbl %dl,%edx
   11433:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   11437:	c1 e1 04             	shl    $0x4,%ecx
   1143a:	09 ca                	or     %ecx,%edx
   1143c:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   11440:	c1 e0 0c             	shl    $0xc,%eax
   11443:	09 d0                	or     %edx,%eax
   11445:	c1 e0 0c             	shl    $0xc,%eax
   11448:	89 c2                	mov    %eax,%edx
   1144a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1144d:	25 ff 0f 00 00       	and    $0xfff,%eax
   11452:	01 d0                	add    %edx,%eax
   11454:	c9                   	leave  
   11455:	c3                   	ret    

00011456 <sem_init>:
 * @param sem 信号量结构
 * @param shared 是否被其它进程共享 0表示不被共享，1表示被共享
 * @param value 计数值
 */
void sem_init(semaphore_t *sem, bool shared, uint8_t value)
{
   11456:	55                   	push   %ebp
   11457:	89 e5                	mov    %esp,%ebp
   11459:	83 ec 18             	sub    $0x18,%esp
   1145c:	8b 45 10             	mov    0x10(%ebp),%eax
   1145f:	88 45 f4             	mov    %al,-0xc(%ebp)
    sem->value = value;
   11462:	8b 45 08             	mov    0x8(%ebp),%eax
   11465:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
   11469:	88 10                	mov    %dl,(%eax)
    klist_init(&sem->wait_list);
   1146b:	8b 45 08             	mov    0x8(%ebp),%eax
   1146e:	83 c0 04             	add    $0x4,%eax
   11471:	83 ec 0c             	sub    $0xc,%esp
   11474:	50                   	push   %eax
   11475:	e8 de 15 00 00       	call   12a58 <klist_init>
   1147a:	83 c4 10             	add    $0x10,%esp
}
   1147d:	90                   	nop
   1147e:	c9                   	leave  
   1147f:	c3                   	ret    

00011480 <thread_sem_wait>:
 * @brief 信号量的down操作
 *
 * @param sem
 */
void thread_sem_wait(semaphore_t *sem)
{
   11480:	55                   	push   %ebp
   11481:	89 e5                	mov    %esp,%ebp
   11483:	53                   	push   %ebx
   11484:	83 ec 14             	sub    $0x14,%esp
    irq_status status = irq_enter_protection();
   11487:	e8 bc f6 ff ff       	call   10b48 <irq_enter_protection>
   1148c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    thread_pcb_t *cur = cur_thread();
   1148f:	e8 19 08 00 00       	call   11cad <cur_thread>
   11494:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while (sem->value == 0)
   11497:	eb 79                	jmp    11512 <thread_sem_wait+0x92>
    {
        klist_node_t *wait_node = klist_find(&sem->wait_list, &cur->state_node); /* 先查找在链表中是否存在该节点 */
   11499:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1149c:	8d 50 28             	lea    0x28(%eax),%edx
   1149f:	8b 45 08             	mov    0x8(%ebp),%eax
   114a2:	83 c0 04             	add    $0x4,%eax
   114a5:	83 ec 08             	sub    $0x8,%esp
   114a8:	52                   	push   %edx
   114a9:	50                   	push   %eax
   114aa:	e8 22 17 00 00       	call   12bd1 <klist_find>
   114af:	83 c4 10             	add    $0x10,%esp
   114b2:	89 45 ec             	mov    %eax,-0x14(%ebp)
        ASSERT(wait_node != NULL);                                               /* 该节点已经存在，不应该存在这种情况 */

        /* 先清扫一遍所有队列 */
        klist_remove(&thread_get_manager()->ready_list, &cur->state_node);
   114b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   114b8:	8d 58 28             	lea    0x28(%eax),%ebx
   114bb:	e8 04 0a 00 00       	call   11ec4 <thread_get_manager>
   114c0:	83 c0 18             	add    $0x18,%eax
   114c3:	83 ec 08             	sub    $0x8,%esp
   114c6:	53                   	push   %ebx
   114c7:	50                   	push   %eax
   114c8:	e8 81 16 00 00       	call   12b4e <klist_remove>
   114cd:	83 c4 10             	add    $0x10,%esp
        klist_remove(&thread_get_manager()->sleep_list, &cur->state_node);
   114d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   114d3:	8d 58 28             	lea    0x28(%eax),%ebx
   114d6:	e8 e9 09 00 00       	call   11ec4 <thread_get_manager>
   114db:	83 c0 2c             	add    $0x2c,%eax
   114de:	83 ec 08             	sub    $0x8,%esp
   114e1:	53                   	push   %ebx
   114e2:	50                   	push   %eax
   114e3:	e8 66 16 00 00       	call   12b4e <klist_remove>
   114e8:	83 c4 10             	add    $0x10,%esp
        klist_append(&sem->wait_list, &cur->state_node); /* 再加入到sem的等待队列中去，阻塞线程 */
   114eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   114ee:	8d 50 28             	lea    0x28(%eax),%edx
   114f1:	8b 45 08             	mov    0x8(%ebp),%eax
   114f4:	83 c0 04             	add    $0x4,%eax
   114f7:	83 ec 08             	sub    $0x8,%esp
   114fa:	52                   	push   %edx
   114fb:	50                   	push   %eax
   114fc:	e8 cc 15 00 00       	call   12acd <klist_append>
   11501:	83 c4 10             	add    $0x10,%esp
        thread_set_block(cur);                           /* 阻塞线程 */
   11504:	83 ec 0c             	sub    $0xc,%esp
   11507:	ff 75 f0             	pushl  -0x10(%ebp)
   1150a:	e8 a5 04 00 00       	call   119b4 <thread_set_block>
   1150f:	83 c4 10             	add    $0x10,%esp
    while (sem->value == 0)
   11512:	8b 45 08             	mov    0x8(%ebp),%eax
   11515:	0f b6 00             	movzbl (%eax),%eax
   11518:	84 c0                	test   %al,%al
   1151a:	0f 84 79 ff ff ff    	je     11499 <thread_sem_wait+0x19>
    }
    sem->value--;
   11520:	8b 45 08             	mov    0x8(%ebp),%eax
   11523:	0f b6 00             	movzbl (%eax),%eax
   11526:	8d 50 ff             	lea    -0x1(%eax),%edx
   11529:	8b 45 08             	mov    0x8(%ebp),%eax
   1152c:	88 10                	mov    %dl,(%eax)
    irq_leave_protection(status);
   1152e:	83 ec 0c             	sub    $0xc,%esp
   11531:	ff 75 f4             	pushl  -0xc(%ebp)
   11534:	e8 22 f6 ff ff       	call   10b5b <irq_leave_protection>
   11539:	83 c4 10             	add    $0x10,%esp
}
   1153c:	90                   	nop
   1153d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11540:	c9                   	leave  
   11541:	c3                   	ret    

00011542 <thread_sem_post>:
 * @brief 信号量的up操作
 *
 * @param sem
 */
void thread_sem_post(semaphore_t *sem)
{
   11542:	55                   	push   %ebp
   11543:	89 e5                	mov    %esp,%ebp
   11545:	83 ec 18             	sub    $0x18,%esp
    irq_status status = irq_enter_protection();
   11548:	e8 fb f5 ff ff       	call   10b48 <irq_enter_protection>
   1154d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!klist_empty(&sem->wait_list))
   11550:	8b 45 08             	mov    0x8(%ebp),%eax
   11553:	83 c0 04             	add    $0x4,%eax
   11556:	83 ec 0c             	sub    $0xc,%esp
   11559:	50                   	push   %eax
   1155a:	e8 a6 16 00 00       	call   12c05 <klist_empty>
   1155f:	83 c4 10             	add    $0x10,%esp
   11562:	85 c0                	test   %eax,%eax
   11564:	75 42                	jne    115a8 <thread_sem_post+0x66>
    {
        klist_node_t *node = sem->wait_list.head.next;
   11566:	8b 45 08             	mov    0x8(%ebp),%eax
   11569:	8b 40 08             	mov    0x8(%eax),%eax
   1156c:	89 45 f0             	mov    %eax,-0x10(%ebp)
        thread_pcb_t *pcb = KLIST_STRUCT_ADDR(node, thread_pcb_t, state_node);
   1156f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11573:	74 08                	je     1157d <thread_sem_post+0x3b>
   11575:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11578:	83 e8 28             	sub    $0x28,%eax
   1157b:	eb 05                	jmp    11582 <thread_sem_post+0x40>
   1157d:	b8 00 00 00 00       	mov    $0x0,%eax
   11582:	89 45 ec             	mov    %eax,-0x14(%ebp)
        klist_remove(&sem->wait_list, node); /* 从等待队列中移除 */
   11585:	8b 45 08             	mov    0x8(%ebp),%eax
   11588:	83 c0 04             	add    $0x4,%eax
   1158b:	83 ec 08             	sub    $0x8,%esp
   1158e:	ff 75 f0             	pushl  -0x10(%ebp)
   11591:	50                   	push   %eax
   11592:	e8 b7 15 00 00       	call   12b4e <klist_remove>
   11597:	83 c4 10             	add    $0x10,%esp
        thread_push_ready(pcb);              /* 加入就绪队列 */
   1159a:	83 ec 0c             	sub    $0xc,%esp
   1159d:	ff 75 ec             	pushl  -0x14(%ebp)
   115a0:	e8 4c 03 00 00       	call   118f1 <thread_push_ready>
   115a5:	83 c4 10             	add    $0x10,%esp
    }
    sem->value++;
   115a8:	8b 45 08             	mov    0x8(%ebp),%eax
   115ab:	0f b6 00             	movzbl (%eax),%eax
   115ae:	8d 50 01             	lea    0x1(%eax),%edx
   115b1:	8b 45 08             	mov    0x8(%ebp),%eax
   115b4:	88 10                	mov    %dl,(%eax)
    irq_leave_protection(status);
   115b6:	83 ec 0c             	sub    $0xc,%esp
   115b9:	ff 75 f4             	pushl  -0xc(%ebp)
   115bc:	e8 9a f5 ff ff       	call   10b5b <irq_leave_protection>
   115c1:	83 c4 10             	add    $0x10,%esp
}
   115c4:	90                   	nop
   115c5:	c9                   	leave  
   115c6:	c3                   	ret    

000115c7 <sem_destroy>:

void sem_destroy(semaphore_t *sem)
{
   115c7:	55                   	push   %ebp
   115c8:	89 e5                	mov    %esp,%ebp
    return;
   115ca:	90                   	nop
   115cb:	5d                   	pop    %ebp
   115cc:	c3                   	ret    

000115cd <hlt>:
{
   115cd:	55                   	push   %ebp
   115ce:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   115d0:	f4                   	hlt    
}
   115d1:	90                   	nop
   115d2:	5d                   	pop    %ebp
   115d3:	c3                   	ret    

000115d4 <sys_getpid>:
#include "syscall.h"
extern proc_manager_t proc_manager;
extern task_manage_t task_manager;

pid_t sys_getpid()
{
   115d4:	55                   	push   %ebp
   115d5:	89 e5                	mov    %esp,%ebp
   115d7:	83 ec 18             	sub    $0x18,%esp
    proc_pcb_t *cur = cur_proc();
   115da:	e8 34 0d 00 00       	call   12313 <cur_proc>
   115df:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return cur->pid;
   115e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115e5:	8b 00                	mov    (%eax),%eax
}
   115e7:	c9                   	leave  
   115e8:	c3                   	ret    

000115e9 <sys_write>:

void sys_write()
{
   115e9:	55                   	push   %ebp
   115ea:	89 e5                	mov    %esp,%ebp
    hlt();
   115ec:	e8 dc ff ff ff       	call   115cd <hlt>
}
   115f1:	90                   	nop
   115f2:	5d                   	pop    %ebp
   115f3:	c3                   	ret    

000115f4 <sys_read>:

void sys_read()
{
   115f4:	55                   	push   %ebp
   115f5:	89 e5                	mov    %esp,%ebp
    hlt();
   115f7:	e8 d1 ff ff ff       	call   115cd <hlt>
}
   115fc:	90                   	nop
   115fd:	5d                   	pop    %ebp
   115fe:	c3                   	ret    

000115ff <sys_fork>:

pid_t sys_fork(syscall_frame_t *sys_frame)
{
   115ff:	55                   	push   %ebp
   11600:	89 e5                	mov    %esp,%ebp
   11602:	83 ec 18             	sub    $0x18,%esp
    // new_proc->context->eflags = sys_frame->eflags;
    // irq_leave_protection(proc_manager.irq_state);
    // return new_proc->pid;

    // 思路二
    task_t *cur = cur_task();
   11605:	e8 15 1b 00 00       	call   1311f <cur_task>
   1160a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t *new_task = init_task(sys_frame->eip);
   1160d:	8b 45 08             	mov    0x8(%ebp),%eax
   11610:	8b 40 44             	mov    0x44(%eax),%eax
   11613:	83 ec 0c             	sub    $0xc,%esp
   11616:	50                   	push   %eax
   11617:	e8 2c 1a 00 00       	call   13048 <init_task>
   1161c:	83 c4 10             	add    $0x10,%esp
   1161f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    proc_manager.irq_state = irq_enter_protection();
   11622:	e8 21 f5 ff ff       	call   10b48 <irq_enter_protection>
   11627:	a3 c0 81 01 00       	mov    %eax,0x181c0

    // pagetable_destroy(new_task->tss.cr3);
    new_task->tss.gs = sys_frame->gs;
   1162c:	8b 45 08             	mov    0x8(%ebp),%eax
   1162f:	8b 50 0c             	mov    0xc(%eax),%edx
   11632:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11635:	89 50 60             	mov    %edx,0x60(%eax)
    new_task->tss.fs = sys_frame->fs;
   11638:	8b 45 08             	mov    0x8(%ebp),%eax
   1163b:	8b 50 10             	mov    0x10(%eax),%edx
   1163e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11641:	89 50 5c             	mov    %edx,0x5c(%eax)
    new_task->tss.es = sys_frame->es;
   11644:	8b 45 08             	mov    0x8(%ebp),%eax
   11647:	8b 50 14             	mov    0x14(%eax),%edx
   1164a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1164d:	89 50 4c             	mov    %edx,0x4c(%eax)
    new_task->tss.ds = sys_frame->ds;
   11650:	8b 45 08             	mov    0x8(%ebp),%eax
   11653:	8b 50 18             	mov    0x18(%eax),%edx
   11656:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11659:	89 50 58             	mov    %edx,0x58(%eax)
    new_task->tss.edi = sys_frame->edi;
   1165c:	8b 45 08             	mov    0x8(%ebp),%eax
   1165f:	8b 50 1c             	mov    0x1c(%eax),%edx
   11662:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11665:	89 50 48             	mov    %edx,0x48(%eax)
    new_task->tss.esi = sys_frame->esi;
   11668:	8b 45 08             	mov    0x8(%ebp),%eax
   1166b:	8b 50 20             	mov    0x20(%eax),%edx
   1166e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11671:	89 50 44             	mov    %edx,0x44(%eax)
    new_task->tss.ebp = sys_frame->ebp;
   11674:	8b 45 08             	mov    0x8(%ebp),%eax
   11677:	8b 50 24             	mov    0x24(%eax),%edx
   1167a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1167d:	89 50 40             	mov    %edx,0x40(%eax)
    new_task->tss.esp = (uint32_t *)sys_frame->esp;
   11680:	8b 45 08             	mov    0x8(%ebp),%eax
   11683:	8b 40 28             	mov    0x28(%eax),%eax
   11686:	89 c2                	mov    %eax,%edx
   11688:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1168b:	89 50 3c             	mov    %edx,0x3c(%eax)
    new_task->tss.ebx = sys_frame->ebx;
   1168e:	8b 45 08             	mov    0x8(%ebp),%eax
   11691:	8b 50 2c             	mov    0x2c(%eax),%edx
   11694:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11697:	89 50 38             	mov    %edx,0x38(%eax)
    new_task->tss.edx = sys_frame->edx;
   1169a:	8b 45 08             	mov    0x8(%ebp),%eax
   1169d:	8b 50 30             	mov    0x30(%eax),%edx
   116a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116a3:	89 50 34             	mov    %edx,0x34(%eax)
    new_task->tss.ecx = sys_frame->ecx;
   116a6:	8b 45 08             	mov    0x8(%ebp),%eax
   116a9:	8b 50 34             	mov    0x34(%eax),%edx
   116ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116af:	89 50 30             	mov    %edx,0x30(%eax)
    new_task->tss.eip = (void *)sys_frame->eip;
   116b2:	8b 45 08             	mov    0x8(%ebp),%eax
   116b5:	8b 40 44             	mov    0x44(%eax),%eax
   116b8:	89 c2                	mov    %eax,%edx
   116ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116bd:	89 50 24             	mov    %edx,0x24(%eax)
    new_task->tss.cs = sys_frame->cs;
   116c0:	8b 45 08             	mov    0x8(%ebp),%eax
   116c3:	8b 50 48             	mov    0x48(%eax),%edx
   116c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116c9:	89 50 50             	mov    %edx,0x50(%eax)
    new_task->tss.eflags = sys_frame->eflags;
   116cc:	8b 45 08             	mov    0x8(%ebp),%eax
   116cf:	8b 50 4c             	mov    0x4c(%eax),%edx
   116d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116d5:	89 50 28             	mov    %edx,0x28(%eax)
    // new_task->tss.cr3 = copy_pagetable(new_task->tss.cr3);

    new_task->parent = cur;
   116d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116db:	8b 55 f4             	mov    -0xc(%ebp),%edx
   116de:	89 50 74             	mov    %edx,0x74(%eax)
    new_task->ifkernel = cur->ifkernel;
   116e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116e4:	8b 50 70             	mov    0x70(%eax),%edx
   116e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116ea:	89 50 70             	mov    %edx,0x70(%eax)
    new_task->tss.eax = 0;
   116ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116f0:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)

    irq_leave_protection(proc_manager.irq_state);
   116f7:	a1 c0 81 01 00       	mov    0x181c0,%eax
   116fc:	83 ec 0c             	sub    $0xc,%esp
   116ff:	50                   	push   %eax
   11700:	e8 56 f4 ff ff       	call   10b5b <irq_leave_protection>
   11705:	83 c4 10             	add    $0x10,%esp
    return new_task->pid;
   11708:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1170b:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
}
   11711:	c9                   	leave  
   11712:	c3                   	ret    

00011713 <sys_malloc>:

void sys_malloc()
{
   11713:	55                   	push   %ebp
   11714:	89 e5                	mov    %esp,%ebp
    hlt();
   11716:	e8 b2 fe ff ff       	call   115cd <hlt>
}
   1171b:	90                   	nop
   1171c:	5d                   	pop    %ebp
   1171d:	c3                   	ret    

0001171e <sys_putchar>:

void sys_putchar()
{
   1171e:	55                   	push   %ebp
   1171f:	89 e5                	mov    %esp,%ebp
    hlt();
   11721:	e8 a7 fe ff ff       	call   115cd <hlt>
}
   11726:	90                   	nop
   11727:	5d                   	pop    %ebp
   11728:	c3                   	ret    

00011729 <syscall_init>:

void syscall_init()
{
   11729:	55                   	push   %ebp
   1172a:	89 e5                	mov    %esp,%ebp
    syscall_table[SYS_GETPID] = (syscall_t)sys_getpid;
   1172c:	c7 05 40 70 01 00 d4 	movl   $0x115d4,0x17040
   11733:	15 01 00 
    syscall_table[SYS_WRITE] = (syscall_t)sys_write;
   11736:	c7 05 44 70 01 00 e9 	movl   $0x115e9,0x17044
   1173d:	15 01 00 
    syscall_table[SYS_READ] = (syscall_t)sys_read;
   11740:	c7 05 48 70 01 00 f4 	movl   $0x115f4,0x17048
   11747:	15 01 00 
    syscall_table[SYS_FORK] = (syscall_t)sys_fork;
   1174a:	c7 05 4c 70 01 00 ff 	movl   $0x115ff,0x1704c
   11751:	15 01 00 
    syscall_table[SYS_MALLOC] = (syscall_t)sys_malloc;
   11754:	c7 05 50 70 01 00 13 	movl   $0x11713,0x17050
   1175b:	17 01 00 
    syscall_table[SYS_PUTCHAR] = (syscall_t)sys_putchar;
   1175e:	c7 05 54 70 01 00 1e 	movl   $0x1171e,0x17054
   11765:	17 01 00 
   11768:	90                   	nop
   11769:	5d                   	pop    %ebp
   1176a:	c3                   	ret    

0001176b <wcr3>:
{
   1176b:	55                   	push   %ebp
   1176c:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("mov %[data], %%cr3" ::[data] "r"(data));
   1176e:	8b 45 08             	mov    0x8(%ebp),%eax
   11771:	0f 22 d8             	mov    %eax,%cr3
}
   11774:	90                   	nop
   11775:	5d                   	pop    %ebp
   11776:	c3                   	ret    

00011777 <lgdt>:
{
   11777:	55                   	push   %ebp
   11778:	89 e5                	mov    %esp,%ebp
   1177a:	83 ec 14             	sub    $0x14,%esp
   1177d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11780:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    gdt.start32_16 = start >> 16;
   11784:	8b 45 08             	mov    0x8(%ebp),%eax
   11787:	c1 e8 10             	shr    $0x10,%eax
   1178a:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    gdt.start15_0 = start & 0xFFFF;
   1178e:	8b 45 08             	mov    0x8(%ebp),%eax
   11791:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    gdt.offset = offset - 1;
   11795:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   11799:	83 e8 01             	sub    $0x1,%eax
   1179c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__("lgdt %[gdt]" ::[gdt] "m"(gdt));
   117a0:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
}
   117a4:	90                   	nop
   117a5:	c9                   	leave  
   117a6:	c3                   	ret    

000117a7 <ltr>:

static void inline ltr(uint32_t tss_sel)
{
   117a7:	55                   	push   %ebp
   117a8:	89 e5                	mov    %esp,%ebp

    __asm__ __volatile__("ltr %%ax" ::"a"(tss_sel));
   117aa:	8b 45 08             	mov    0x8(%ebp),%eax
   117ad:	0f 00 d8             	ltr    %ax
}
   117b0:	90                   	nop
   117b1:	5d                   	pop    %ebp
   117b2:	c3                   	ret    

000117b3 <tss_init>:
/**
 * @brief 初始化tss
 *
 */
void tss_init()
{
   117b3:	55                   	push   %ebp
   117b4:	89 e5                	mov    %esp,%ebp
   117b6:	83 ec 08             	sub    $0x8,%esp
    tss_desc_set(KERNEL_SELECTOR_TSS);
   117b9:	83 ec 0c             	sub    $0xc,%esp
   117bc:	6a 18                	push   $0x18
   117be:	e8 24 00 00 00       	call   117e7 <tss_desc_set>
   117c3:	83 c4 10             	add    $0x10,%esp
}
   117c6:	90                   	nop
   117c7:	c9                   	leave  
   117c8:	c3                   	ret    

000117c9 <switch_thread_from_to>:
 *
 * @param from
 * @param to
 */
void switch_thread_from_to(thread_pcb_t *from, thread_pcb_t *to)
{
   117c9:	55                   	push   %ebp
   117ca:	89 e5                	mov    %esp,%ebp
   117cc:	83 ec 08             	sub    $0x8,%esp
    simple_switch(&from->kstack, to->kstack);
   117cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   117d2:	8b 10                	mov    (%eax),%edx
   117d4:	8b 45 08             	mov    0x8(%ebp),%eax
   117d7:	83 ec 08             	sub    $0x8,%esp
   117da:	52                   	push   %edx
   117db:	50                   	push   %eax
   117dc:	e8 cc ea ff ff       	call   102ad <simple_switch>
   117e1:	83 c4 10             	add    $0x10,%esp
}
   117e4:	90                   	nop
   117e5:	c9                   	leave  
   117e6:	c3                   	ret    

000117e7 <tss_desc_set>:
 * @param ifkernel 判断是否属于内核
 * @param entry 入口
 * @param stack 栈
 */
void tss_desc_set(int tss_sel)
{
   117e7:	55                   	push   %ebp
   117e8:	89 e5                	mov    %esp,%ebp
   117ea:	83 ec 18             	sub    $0x18,%esp
    kmemset(&tss, 0, sizeof(tss_t));
   117ed:	83 ec 04             	sub    $0x4,%esp
   117f0:	6a 68                	push   $0x68
   117f2:	6a 00                	push   $0x0
   117f4:	68 80 80 01 00       	push   $0x18080
   117f9:	e8 76 0b 00 00       	call   12374 <kmemset>
   117fe:	83 c4 10             	add    $0x10,%esp
    /* 在GDT表中设置TSS描述符 */
    gdt_segment_set(tss_sel, sizeof(tss_t), (uint32_t)&tss, SEG_S_SYSTEM | SEG_TYPE_TSS | SEG_DPL0 | SEG_P_PRESENT);
   11801:	ba 80 80 01 00       	mov    $0x18080,%edx
   11806:	8b 45 08             	mov    0x8(%ebp),%eax
   11809:	0f b7 c0             	movzwl %ax,%eax
   1180c:	68 89 00 00 00       	push   $0x89
   11811:	52                   	push   %edx
   11812:	6a 68                	push   $0x68
   11814:	50                   	push   %eax
   11815:	e8 71 ec ff ff       	call   1048b <gdt_segment_set>
   1181a:	83 c4 10             	add    $0x10,%esp

    /* 设置tss的结构 */
    int data_sel, code_sel;

    data_sel = KERNEL_SELECTOR_DS;
   1181d:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    code_sel = KERNEL_SELECTOR_CS;
   11824:	c7 45 f0 08 00 00 00 	movl   $0x8,-0x10(%ebp)

    // tss.eip = (uint32_t(*)(void))entry;
    tss.esp = tss.esp0 = (uint32_t *)KERNEL_STACK_SIZE;
   1182b:	c7 05 84 80 01 00 00 	movl   $0x2000,0x18084
   11832:	20 00 00 
   11835:	a1 84 80 01 00       	mov    0x18084,%eax
   1183a:	a3 b8 80 01 00       	mov    %eax,0x180b8
    tss.es = tss.ds = tss.fs = tss.gs = data_sel;
   1183f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11842:	a3 dc 80 01 00       	mov    %eax,0x180dc
   11847:	a1 dc 80 01 00       	mov    0x180dc,%eax
   1184c:	a3 d8 80 01 00       	mov    %eax,0x180d8
   11851:	a1 d8 80 01 00       	mov    0x180d8,%eax
   11856:	a3 d4 80 01 00       	mov    %eax,0x180d4
   1185b:	a1 d4 80 01 00       	mov    0x180d4,%eax
   11860:	a3 c8 80 01 00       	mov    %eax,0x180c8
    tss.ss0 = tss.ss = data_sel;
   11865:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11868:	a3 d0 80 01 00       	mov    %eax,0x180d0
   1186d:	a1 d0 80 01 00       	mov    0x180d0,%eax
   11872:	a3 88 80 01 00       	mov    %eax,0x18088
    tss.cs = code_sel;
   11877:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1187a:	a3 cc 80 01 00       	mov    %eax,0x180cc
    tss.eflags = ELFAGS_MBS | EFLAGS_IF;
   1187f:	c7 05 a4 80 01 00 02 	movl   $0x202,0x180a4
   11886:	02 00 00 

    /* 加载选择子到tr寄存器 */
    lgdt((uint32_t)gdt_table, sizeof(gdt_table));
   11889:	b8 a0 70 01 00       	mov    $0x170a0,%eax
   1188e:	83 ec 08             	sub    $0x8,%esp
   11891:	68 00 08 00 00       	push   $0x800
   11896:	50                   	push   %eax
   11897:	e8 db fe ff ff       	call   11777 <lgdt>
   1189c:	83 c4 10             	add    $0x10,%esp
    ltr(tss_sel);
   1189f:	8b 45 08             	mov    0x8(%ebp),%eax
   118a2:	83 ec 0c             	sub    $0xc,%esp
   118a5:	50                   	push   %eax
   118a6:	e8 fc fe ff ff       	call   117a7 <ltr>
   118ab:	83 c4 10             	add    $0x10,%esp
}
   118ae:	90                   	nop
   118af:	c9                   	leave  
   118b0:	c3                   	ret    

000118b1 <thread_set_general>:
 * @brief 将线程加入到普通队列
 *
 * @param pcb
 */
void thread_set_general(thread_pcb_t *pcb)
{
   118b1:	55                   	push   %ebp
   118b2:	89 e5                	mov    %esp,%ebp
   118b4:	83 ec 08             	sub    $0x8,%esp
    klist_append(&thread_manager.general_list, &pcb->general_node);
   118b7:	8b 45 08             	mov    0x8(%ebp),%eax
   118ba:	83 c0 30             	add    $0x30,%eax
   118bd:	83 ec 08             	sub    $0x8,%esp
   118c0:	50                   	push   %eax
   118c1:	68 04 81 01 00       	push   $0x18104
   118c6:	e8 02 12 00 00       	call   12acd <klist_append>
   118cb:	83 c4 10             	add    $0x10,%esp
}
   118ce:	90                   	nop
   118cf:	c9                   	leave  
   118d0:	c3                   	ret    

000118d1 <proc_set_general>:

void proc_set_general(proc_pcb_t *pcb)
{
   118d1:	55                   	push   %ebp
   118d2:	89 e5                	mov    %esp,%ebp
   118d4:	83 ec 08             	sub    $0x8,%esp
    klist_append(&proc_manager.general_list, &pcb->general_node);
   118d7:	8b 45 08             	mov    0x8(%ebp),%eax
   118da:	83 c0 44             	add    $0x44,%eax
   118dd:	83 ec 08             	sub    $0x8,%esp
   118e0:	50                   	push   %eax
   118e1:	68 84 81 01 00       	push   $0x18184
   118e6:	e8 e2 11 00 00       	call   12acd <klist_append>
   118eb:	83 c4 10             	add    $0x10,%esp
}
   118ee:	90                   	nop
   118ef:	c9                   	leave  
   118f0:	c3                   	ret    

000118f1 <thread_push_ready>:
 * @brief 将任务加入就绪队列的队头
 *
 * @param pcb
 */
void thread_push_ready(thread_pcb_t *pcb)
{
   118f1:	55                   	push   %ebp
   118f2:	89 e5                	mov    %esp,%ebp
   118f4:	83 ec 08             	sub    $0x8,%esp
    klist_remove(&thread_manager.ready_list, &pcb->state_node); /* 如果存在于就绪队列中就重新把其加入队尾 */
   118f7:	8b 45 08             	mov    0x8(%ebp),%eax
   118fa:	83 c0 28             	add    $0x28,%eax
   118fd:	83 ec 08             	sub    $0x8,%esp
   11900:	50                   	push   %eax
   11901:	68 18 81 01 00       	push   $0x18118
   11906:	e8 43 12 00 00       	call   12b4e <klist_remove>
   1190b:	83 c4 10             	add    $0x10,%esp
    pcb->status = TASK_READY;
   1190e:	8b 45 08             	mov    0x8(%ebp),%eax
   11911:	c7 40 1c 02 00 00 00 	movl   $0x2,0x1c(%eax)
    klist_push(&thread_manager.ready_list, &pcb->state_node);
   11918:	8b 45 08             	mov    0x8(%ebp),%eax
   1191b:	83 c0 28             	add    $0x28,%eax
   1191e:	83 ec 08             	sub    $0x8,%esp
   11921:	50                   	push   %eax
   11922:	68 18 81 01 00       	push   $0x18118
   11927:	e8 64 11 00 00       	call   12a90 <klist_push>
   1192c:	83 c4 10             	add    $0x10,%esp
}
   1192f:	90                   	nop
   11930:	c9                   	leave  
   11931:	c3                   	ret    

00011932 <thread_set_ready>:
 * @brief 将线程加入到就绪队列的队尾
 *
 * @param pcb
 */
void thread_set_ready(thread_pcb_t *pcb)
{
   11932:	55                   	push   %ebp
   11933:	89 e5                	mov    %esp,%ebp
   11935:	83 ec 08             	sub    $0x8,%esp
    klist_remove(&thread_manager.ready_list, &pcb->state_node); /* 如果存在于就绪队列中就重新把其加入队尾 */
   11938:	8b 45 08             	mov    0x8(%ebp),%eax
   1193b:	83 c0 28             	add    $0x28,%eax
   1193e:	83 ec 08             	sub    $0x8,%esp
   11941:	50                   	push   %eax
   11942:	68 18 81 01 00       	push   $0x18118
   11947:	e8 02 12 00 00       	call   12b4e <klist_remove>
   1194c:	83 c4 10             	add    $0x10,%esp
    pcb->status = TASK_READY;
   1194f:	8b 45 08             	mov    0x8(%ebp),%eax
   11952:	c7 40 1c 02 00 00 00 	movl   $0x2,0x1c(%eax)
    klist_append(&thread_manager.ready_list, &pcb->state_node);
   11959:	8b 45 08             	mov    0x8(%ebp),%eax
   1195c:	83 c0 28             	add    $0x28,%eax
   1195f:	83 ec 08             	sub    $0x8,%esp
   11962:	50                   	push   %eax
   11963:	68 18 81 01 00       	push   $0x18118
   11968:	e8 60 11 00 00       	call   12acd <klist_append>
   1196d:	83 c4 10             	add    $0x10,%esp
}
   11970:	90                   	nop
   11971:	c9                   	leave  
   11972:	c3                   	ret    

00011973 <proc_set_ready>:

void proc_set_ready(proc_pcb_t *pcb)
{
   11973:	55                   	push   %ebp
   11974:	89 e5                	mov    %esp,%ebp
   11976:	83 ec 08             	sub    $0x8,%esp
    klist_remove(&proc_manager.ready_list, &pcb->state_node); /* 如果存在于就绪队列中就重新把其加入队尾 */
   11979:	8b 45 08             	mov    0x8(%ebp),%eax
   1197c:	83 c0 3c             	add    $0x3c,%eax
   1197f:	83 ec 08             	sub    $0x8,%esp
   11982:	50                   	push   %eax
   11983:	68 98 81 01 00       	push   $0x18198
   11988:	e8 c1 11 00 00       	call   12b4e <klist_remove>
   1198d:	83 c4 10             	add    $0x10,%esp
    pcb->status = TASK_READY;
   11990:	8b 45 08             	mov    0x8(%ebp),%eax
   11993:	c7 40 24 02 00 00 00 	movl   $0x2,0x24(%eax)
    klist_append(&proc_manager.ready_list, &pcb->state_node);
   1199a:	8b 45 08             	mov    0x8(%ebp),%eax
   1199d:	83 c0 3c             	add    $0x3c,%eax
   119a0:	83 ec 08             	sub    $0x8,%esp
   119a3:	50                   	push   %eax
   119a4:	68 98 81 01 00       	push   $0x18198
   119a9:	e8 1f 11 00 00       	call   12acd <klist_append>
   119ae:	83 c4 10             	add    $0x10,%esp
}
   119b1:	90                   	nop
   119b2:	c9                   	leave  
   119b3:	c3                   	ret    

000119b4 <thread_set_block>:

void thread_set_block(thread_pcb_t *pcb)
{
   119b4:	55                   	push   %ebp
   119b5:	89 e5                	mov    %esp,%ebp
   119b7:	83 ec 08             	sub    $0x8,%esp
    pcb->status = TASK_BLOCKED;
   119ba:	8b 45 08             	mov    0x8(%ebp),%eax
   119bd:	c7 40 1c 03 00 00 00 	movl   $0x3,0x1c(%eax)
    thread_dispatch();
   119c4:	e8 34 03 00 00       	call   11cfd <thread_dispatch>
}
   119c9:	90                   	nop
   119ca:	c9                   	leave  
   119cb:	c3                   	ret    

000119cc <thread_set_sleep>:
 * @brief 将线程加入到睡眠队列
 *
 * @param pcb
 */
void thread_set_sleep(thread_pcb_t *pcb)
{
   119cc:	55                   	push   %ebp
   119cd:	89 e5                	mov    %esp,%ebp
   119cf:	83 ec 08             	sub    $0x8,%esp
    pcb->status = TASK_SLEEP;
   119d2:	8b 45 08             	mov    0x8(%ebp),%eax
   119d5:	c7 40 1c 06 00 00 00 	movl   $0x6,0x1c(%eax)
    klist_append(&thread_manager.sleep_list, &pcb->state_node);
   119dc:	8b 45 08             	mov    0x8(%ebp),%eax
   119df:	83 c0 28             	add    $0x28,%eax
   119e2:	83 ec 08             	sub    $0x8,%esp
   119e5:	50                   	push   %eax
   119e6:	68 2c 81 01 00       	push   $0x1812c
   119eb:	e8 dd 10 00 00       	call   12acd <klist_append>
   119f0:	83 c4 10             	add    $0x10,%esp
}
   119f3:	90                   	nop
   119f4:	c9                   	leave  
   119f5:	c3                   	ret    

000119f6 <main_thread_init>:
 * @param prio
 * @param func
 * @param args
 */
void main_thread_init(char *name, int prio, thread_func func, void *args)
{
   119f6:	55                   	push   %ebp
   119f7:	89 e5                	mov    %esp,%ebp
   119f9:	83 ec 08             	sub    $0x8,%esp
    thread_manager.cur_thread = &thread_manager.main_thread;
   119fc:	c7 05 00 81 01 00 40 	movl   $0x18140,0x18100
   11a03:	81 01 00 
    /* 初始化线程 */
    kthread_init(&thread_manager.main_thread, name, prio);
   11a06:	83 ec 04             	sub    $0x4,%esp
   11a09:	ff 75 0c             	pushl  0xc(%ebp)
   11a0c:	ff 75 08             	pushl  0x8(%ebp)
   11a0f:	68 40 81 01 00       	push   $0x18140
   11a14:	e8 66 00 00 00       	call   11a7f <kthread_init>
   11a19:	83 c4 10             	add    $0x10,%esp
    kthread_create(&thread_manager.main_thread, func, NULL);
   11a1c:	83 ec 04             	sub    $0x4,%esp
   11a1f:	6a 00                	push   $0x0
   11a21:	ff 75 10             	pushl  0x10(%ebp)
   11a24:	68 40 81 01 00       	push   $0x18140
   11a29:	e8 ad 00 00 00       	call   11adb <kthread_create>
   11a2e:	83 c4 10             	add    $0x10,%esp
    /* 设置线程的运行状态 */
    thread_set_general(&thread_manager.main_thread);
   11a31:	83 ec 0c             	sub    $0xc,%esp
   11a34:	68 40 81 01 00       	push   $0x18140
   11a39:	e8 73 fe ff ff       	call   118b1 <thread_set_general>
   11a3e:	83 c4 10             	add    $0x10,%esp
    thread_set_ready(&thread_manager.main_thread);
   11a41:	83 ec 0c             	sub    $0xc,%esp
   11a44:	68 40 81 01 00       	push   $0x18140
   11a49:	e8 e4 fe ff ff       	call   11932 <thread_set_ready>
   11a4e:	83 c4 10             	add    $0x10,%esp
    thread_manager.main_thread.ticks = TASK_TICKS_DEFAULT;
   11a51:	c7 05 64 81 01 00 05 	movl   $0x5,0x18164
   11a58:	00 00 00 
    thread_manager.main_thread.status = TASK_RUNNING;
   11a5b:	c7 05 5c 81 01 00 00 	movl   $0x0,0x1815c
   11a62:	00 00 00 
}
   11a65:	90                   	nop
   11a66:	c9                   	leave  
   11a67:	c3                   	ret    

00011a68 <kthread>:
 *
 * @param function
 * @param args
 */
void kthread(thread_func *function, void *args)
{
   11a68:	55                   	push   %ebp
   11a69:	89 e5                	mov    %esp,%ebp
   11a6b:	83 ec 08             	sub    $0x8,%esp
    function(args);
   11a6e:	83 ec 0c             	sub    $0xc,%esp
   11a71:	ff 75 0c             	pushl  0xc(%ebp)
   11a74:	8b 45 08             	mov    0x8(%ebp),%eax
   11a77:	ff d0                	call   *%eax
   11a79:	83 c4 10             	add    $0x10,%esp
}
   11a7c:	90                   	nop
   11a7d:	c9                   	leave  
   11a7e:	c3                   	ret    

00011a7f <kthread_init>:
 * @param pthread
 * @param name
 * @param prio
 */
void kthread_init(thread_pcb_t *pthread, char *name, int prio)
{
   11a7f:	55                   	push   %ebp
   11a80:	89 e5                	mov    %esp,%ebp
   11a82:	83 ec 08             	sub    $0x8,%esp
    kmemset(pthread, 0, sizeof(pthread));
   11a85:	83 ec 04             	sub    $0x4,%esp
   11a88:	6a 04                	push   $0x4
   11a8a:	6a 00                	push   $0x0
   11a8c:	ff 75 08             	pushl  0x8(%ebp)
   11a8f:	e8 e0 08 00 00       	call   12374 <kmemset>
   11a94:	83 c4 10             	add    $0x10,%esp
    kstrcpy(pthread->name, name);
   11a97:	8b 45 08             	mov    0x8(%ebp),%eax
   11a9a:	83 c0 04             	add    $0x4,%eax
   11a9d:	83 ec 08             	sub    $0x8,%esp
   11aa0:	ff 75 0c             	pushl  0xc(%ebp)
   11aa3:	50                   	push   %eax
   11aa4:	e8 6e 0f 00 00       	call   12a17 <kstrcpy>
   11aa9:	83 c4 10             	add    $0x10,%esp
    pthread->status = TASK_CREATED;
   11aac:	8b 45 08             	mov    0x8(%ebp),%eax
   11aaf:	c7 40 1c 01 00 00 00 	movl   $0x1,0x1c(%eax)
    pthread->priority = prio;
   11ab6:	8b 45 08             	mov    0x8(%ebp),%eax
   11ab9:	8b 55 10             	mov    0x10(%ebp),%edx
   11abc:	89 50 18             	mov    %edx,0x18(%eax)
    pthread->kstack = (uint32_t *)((uint32_t)pthread + MEM_PAGE_SIZE);
   11abf:	8b 45 08             	mov    0x8(%ebp),%eax
   11ac2:	05 00 10 00 00       	add    $0x1000,%eax
   11ac7:	89 c2                	mov    %eax,%edx
   11ac9:	8b 45 08             	mov    0x8(%ebp),%eax
   11acc:	89 10                	mov    %edx,(%eax)
    pthread->stack_magic = TASK_STACK_MAGIC; // 魔数
   11ace:	8b 45 08             	mov    0x8(%ebp),%eax
   11ad1:	c7 40 20 16 09 87 19 	movl   $0x19870916,0x20(%eax)
}
   11ad8:	90                   	nop
   11ad9:	c9                   	leave  
   11ada:	c3                   	ret    

00011adb <kthread_create>:
 * @param pthread 线程pcb
 * @param func 线程的函数名
 * @param args 线程的参数
 */
void kthread_create(thread_pcb_t *pthread, thread_func func, void *args)
{
   11adb:	55                   	push   %ebp
   11adc:	89 e5                	mov    %esp,%ebp
   11ade:	83 ec 10             	sub    $0x10,%esp
    pthread->kstack -= sizeof(intr_stack);
   11ae1:	8b 45 08             	mov    0x8(%ebp),%eax
   11ae4:	8b 00                	mov    (%eax),%eax
   11ae6:	8d 90 e0 fe ff ff    	lea    -0x120(%eax),%edx
   11aec:	8b 45 08             	mov    0x8(%ebp),%eax
   11aef:	89 10                	mov    %edx,(%eax)
    pthread->kstack -= sizeof(thread_stack);
   11af1:	8b 45 08             	mov    0x8(%ebp),%eax
   11af4:	8b 00                	mov    (%eax),%eax
   11af6:	8d 50 80             	lea    -0x80(%eax),%edx
   11af9:	8b 45 08             	mov    0x8(%ebp),%eax
   11afc:	89 10                	mov    %edx,(%eax)

    thread_stack *kthread_stack = (thread_stack *)pthread->kstack;
   11afe:	8b 45 08             	mov    0x8(%ebp),%eax
   11b01:	8b 00                	mov    (%eax),%eax
   11b03:	89 45 fc             	mov    %eax,-0x4(%ebp)
    kthread_stack->eip = kthread;
   11b06:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b09:	c7 40 10 68 1a 01 00 	movl   $0x11a68,0x10(%eax)
    kthread_stack->function = func;
   11b10:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b13:	8b 55 0c             	mov    0xc(%ebp),%edx
   11b16:	89 50 18             	mov    %edx,0x18(%eax)
    kthread_stack->args = args;
   11b19:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b1c:	8b 55 10             	mov    0x10(%ebp),%edx
   11b1f:	89 50 1c             	mov    %edx,0x1c(%eax)
    kthread_stack->ebp = kthread_stack->ebx = kthread_stack->esi = kthread_stack->edi = 0;
   11b22:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b25:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   11b2c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b2f:	8b 50 08             	mov    0x8(%eax),%edx
   11b32:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b35:	89 50 0c             	mov    %edx,0xc(%eax)
   11b38:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b3b:	8b 50 0c             	mov    0xc(%eax),%edx
   11b3e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b41:	89 50 04             	mov    %edx,0x4(%eax)
   11b44:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b47:	8b 50 04             	mov    0x4(%eax),%edx
   11b4a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b4d:	89 10                	mov    %edx,(%eax)
}
   11b4f:	90                   	nop
   11b50:	c9                   	leave  
   11b51:	c3                   	ret    

00011b52 <thread_start>:

thread_pcb_t *thread_start(char *name, int prio, thread_func func, void *args)
{
   11b52:	55                   	push   %ebp
   11b53:	89 e5                	mov    %esp,%ebp
   11b55:	83 ec 18             	sub    $0x18,%esp
    irq_status status = irq_enter_protection();
   11b58:	e8 eb ef ff ff       	call   10b48 <irq_enter_protection>
   11b5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    thread_pcb_t *thread = (thread_pcb_t *)kalloc_pages(1);
   11b60:	83 ec 0c             	sub    $0xc,%esp
   11b63:	6a 01                	push   $0x1
   11b65:	e8 98 f2 ff ff       	call   10e02 <kalloc_pages>
   11b6a:	83 c4 10             	add    $0x10,%esp
   11b6d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    kthread_init(thread, name, prio);
   11b70:	83 ec 04             	sub    $0x4,%esp
   11b73:	ff 75 0c             	pushl  0xc(%ebp)
   11b76:	ff 75 08             	pushl  0x8(%ebp)
   11b79:	ff 75 f0             	pushl  -0x10(%ebp)
   11b7c:	e8 fe fe ff ff       	call   11a7f <kthread_init>
   11b81:	83 c4 10             	add    $0x10,%esp
    kthread_create(thread, func, NULL);
   11b84:	83 ec 04             	sub    $0x4,%esp
   11b87:	6a 00                	push   $0x0
   11b89:	ff 75 10             	pushl  0x10(%ebp)
   11b8c:	ff 75 f0             	pushl  -0x10(%ebp)
   11b8f:	e8 47 ff ff ff       	call   11adb <kthread_create>
   11b94:	83 c4 10             	add    $0x10,%esp

    thread->ticks = TASK_TICKS_DEFAULT;
   11b97:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b9a:	c7 40 24 05 00 00 00 	movl   $0x5,0x24(%eax)
    thread_set_general(thread);
   11ba1:	83 ec 0c             	sub    $0xc,%esp
   11ba4:	ff 75 f0             	pushl  -0x10(%ebp)
   11ba7:	e8 05 fd ff ff       	call   118b1 <thread_set_general>
   11bac:	83 c4 10             	add    $0x10,%esp
    thread_set_ready(thread);
   11baf:	83 ec 0c             	sub    $0xc,%esp
   11bb2:	ff 75 f0             	pushl  -0x10(%ebp)
   11bb5:	e8 78 fd ff ff       	call   11932 <thread_set_ready>
   11bba:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(status);
   11bbd:	83 ec 0c             	sub    $0xc,%esp
   11bc0:	ff 75 f4             	pushl  -0xc(%ebp)
   11bc3:	e8 93 ef ff ff       	call   10b5b <irq_leave_protection>
   11bc8:	83 c4 10             	add    $0x10,%esp
    return thread;
   11bcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   11bce:	c9                   	leave  
   11bcf:	c3                   	ret    

00011bd0 <task_init>:
/**
 * @brief 初始化进程和线程
 *
 */
thread_pcb_t *task_init(thread_func *main)
{
   11bd0:	55                   	push   %ebp
   11bd1:	89 e5                	mov    %esp,%ebp
   11bd3:	83 ec 18             	sub    $0x18,%esp
    // klist_init(&thread_manager.sleep_list);
    // klist_init(&thread_manager.general_list);

    // main_thread_init("main", 0, main, NULL); /* 创建主线程 */

    klist_init(&proc_manager.ready_list);
   11bd6:	83 ec 0c             	sub    $0xc,%esp
   11bd9:	68 98 81 01 00       	push   $0x18198
   11bde:	e8 75 0e 00 00       	call   12a58 <klist_init>
   11be3:	83 c4 10             	add    $0x10,%esp
    klist_init(&proc_manager.sleep_list);
   11be6:	83 ec 0c             	sub    $0xc,%esp
   11be9:	68 ac 81 01 00       	push   $0x181ac
   11bee:	e8 65 0e 00 00       	call   12a58 <klist_init>
   11bf3:	83 c4 10             	add    $0x10,%esp
    klist_init(&proc_manager.general_list);
   11bf6:	83 ec 0c             	sub    $0xc,%esp
   11bf9:	68 84 81 01 00       	push   $0x18184
   11bfe:	e8 55 0e 00 00       	call   12a58 <klist_init>
   11c03:	83 c4 10             	add    $0x10,%esp

    proc_pcb_t *pcb = (proc_pcb_t *)kalloc_pages(1); /* 给PCB分配一页内存 */
   11c06:	83 ec 0c             	sub    $0xc,%esp
   11c09:	6a 01                	push   $0x1
   11c0b:	e8 f2 f1 ff ff       	call   10e02 <kalloc_pages>
   11c10:	83 c4 10             	add    $0x10,%esp
   11c13:	89 45 f4             	mov    %eax,-0xc(%ebp)
    proc_manager.cur_proc = pcb;                     /* 将PCB设置为当前正在运行的进程 */
   11c16:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c19:	a3 80 81 01 00       	mov    %eax,0x18180
    pcb->_filename = main;
   11c1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c21:	8b 55 08             	mov    0x8(%ebp),%edx
   11c24:	89 50 1c             	mov    %edx,0x1c(%eax)
    kstrcpy(pcb->name, "main_proc");
   11c27:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c2a:	83 c0 08             	add    $0x8,%eax
   11c2d:	83 ec 08             	sub    $0x8,%esp
   11c30:	68 64 33 01 00       	push   $0x13364
   11c35:	50                   	push   %eax
   11c36:	e8 dc 0d 00 00       	call   12a17 <kstrcpy>
   11c3b:	83 c4 10             	add    $0x10,%esp
    pcb->pgdir = (uint32_t *)kernel_table; /* 创建页表相关 */
   11c3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c41:	c7 40 54 00 90 01 00 	movl   $0x19000,0x54(%eax)
    pcb->ticks = TASK_TICKS_DEFAULT;
   11c48:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c4b:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
    pcb->pid = alloc_pid(); /* 给进程分配PID */
   11c52:	e8 a5 06 00 00       	call   122fc <alloc_pid>
   11c57:	89 c2                	mov    %eax,%edx
   11c59:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c5c:	89 10                	mov    %edx,(%eax)
    pcb->parent = NULL;
   11c5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c61:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
    pcb->ifkernel = KERNEL_PROC;
   11c68:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c6b:	c6 40 34 00          	movb   $0x0,0x34(%eax)
    pcb->ifsaved_context = UNSAVED_CONTEXT;
   11c6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c72:	c7 40 38 01 00 00 00 	movl   $0x1,0x38(%eax)
    proc_set_general(pcb);
   11c79:	83 ec 0c             	sub    $0xc,%esp
   11c7c:	ff 75 f4             	pushl  -0xc(%ebp)
   11c7f:	e8 4d fc ff ff       	call   118d1 <proc_set_general>
   11c84:	83 c4 10             	add    $0x10,%esp
    proc_set_ready(pcb);
   11c87:	83 ec 0c             	sub    $0xc,%esp
   11c8a:	ff 75 f4             	pushl  -0xc(%ebp)
   11c8d:	e8 e1 fc ff ff       	call   11973 <proc_set_ready>
   11c92:	83 c4 10             	add    $0x10,%esp
    proc_start(pcb, KERNEL_PROC);
   11c95:	83 ec 08             	sub    $0x8,%esp
   11c98:	6a 00                	push   $0x0
   11c9a:	ff 75 f4             	pushl  -0xc(%ebp)
   11c9d:	e8 cf 02 00 00       	call   11f71 <proc_start>
   11ca2:	83 c4 10             	add    $0x10,%esp
    tss_init(); /* 初始化tss */
   11ca5:	e8 09 fb ff ff       	call   117b3 <tss_init>
}
   11caa:	90                   	nop
   11cab:	c9                   	leave  
   11cac:	c3                   	ret    

00011cad <cur_thread>:

thread_pcb_t *cur_thread()
{
   11cad:	55                   	push   %ebp
   11cae:	89 e5                	mov    %esp,%ebp
    return thread_manager.cur_thread;
   11cb0:	a1 00 81 01 00       	mov    0x18100,%eax
}
   11cb5:	5d                   	pop    %ebp
   11cb6:	c3                   	ret    

00011cb7 <thread_schedule>:
 * @brief 此处负责线程调度的算法选择
 *
 * @return thread_pcb_t*
 */
thread_pcb_t *thread_schedule()
{
   11cb7:	55                   	push   %ebp
   11cb8:	89 e5                	mov    %esp,%ebp
   11cba:	83 ec 18             	sub    $0x18,%esp
    int sections = SCHEDULE_SECTIONS;
   11cbd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    switch (sections)
   11cc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11cc7:	85 c0                	test   %eax,%eax
   11cc9:	74 08                	je     11cd3 <thread_schedule+0x1c>
    {
    case THREAD_FIFO:
        return thread_FIFO();
        break;
    default:
        break;
   11ccb:	90                   	nop
    }
    return NULL;
   11ccc:	b8 00 00 00 00       	mov    $0x0,%eax
   11cd1:	eb 05                	jmp    11cd8 <thread_schedule+0x21>
        return thread_FIFO();
   11cd3:	e8 3d 01 00 00       	call   11e15 <thread_FIFO>
}
   11cd8:	c9                   	leave  
   11cd9:	c3                   	ret    

00011cda <proc_schedule>:

proc_pcb_t *proc_schedule()
{
   11cda:	55                   	push   %ebp
   11cdb:	89 e5                	mov    %esp,%ebp
   11cdd:	83 ec 18             	sub    $0x18,%esp
    int sections = SCHEDULE_SECTIONS;
   11ce0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    switch (sections)
   11ce7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11cea:	85 c0                	test   %eax,%eax
   11cec:	74 08                	je     11cf6 <proc_schedule+0x1c>
    {
    case THREAD_FIFO:
        return proc_FIFO();
        break;
    default:
        break;
   11cee:	90                   	nop
    }
    return NULL;
   11cef:	b8 00 00 00 00       	mov    $0x0,%eax
   11cf4:	eb 05                	jmp    11cfb <proc_schedule+0x21>
        return proc_FIFO();
   11cf6:	e8 4e 01 00 00       	call   11e49 <proc_FIFO>
}
   11cfb:	c9                   	leave  
   11cfc:	c3                   	ret    

00011cfd <thread_dispatch>:
/**
 * @brief 线程调度，切换线程
 *
 */
void thread_dispatch()
{
   11cfd:	55                   	push   %ebp
   11cfe:	89 e5                	mov    %esp,%ebp
   11d00:	83 ec 18             	sub    $0x18,%esp
    thread_pcb_t *cur = cur_thread();
   11d03:	e8 a5 ff ff ff       	call   11cad <cur_thread>
   11d08:	89 45 f4             	mov    %eax,-0xc(%ebp)
    thread_pcb_t *next = thread_schedule();
   11d0b:	e8 a7 ff ff ff       	call   11cb7 <thread_schedule>
   11d10:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (next != cur && next->status == TASK_READY)
   11d13:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d16:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   11d19:	74 31                	je     11d4c <thread_dispatch+0x4f>
   11d1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d1e:	8b 40 1c             	mov    0x1c(%eax),%eax
   11d21:	83 f8 02             	cmp    $0x2,%eax
   11d24:	75 26                	jne    11d4c <thread_dispatch+0x4f>
    {
        thread_manager.cur_thread = next;
   11d26:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d29:	a3 00 81 01 00       	mov    %eax,0x18100
        next->status = TASK_RUNNING;
   11d2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d31:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
        switch_thread_from_to(cur, next);
   11d38:	83 ec 08             	sub    $0x8,%esp
   11d3b:	ff 75 f0             	pushl  -0x10(%ebp)
   11d3e:	ff 75 f4             	pushl  -0xc(%ebp)
   11d41:	e8 83 fa ff ff       	call   117c9 <switch_thread_from_to>
   11d46:	83 c4 10             	add    $0x10,%esp
    else if (klist_len(&thread_manager.ready_list) == 1)
    {
        /* 只有一个线程则无法切换 */
        return;
    }
    return;
   11d49:	90                   	nop
   11d4a:	eb 13                	jmp    11d5f <thread_dispatch+0x62>
    else if (klist_len(&thread_manager.ready_list) == 1)
   11d4c:	83 ec 0c             	sub    $0xc,%esp
   11d4f:	68 18 81 01 00       	push   $0x18118
   11d54:	e8 57 0e 00 00       	call   12bb0 <klist_len>
   11d59:	83 c4 10             	add    $0x10,%esp
   11d5c:	83 f8 01             	cmp    $0x1,%eax
    return;
   11d5f:	90                   	nop
}
   11d60:	c9                   	leave  
   11d61:	c3                   	ret    

00011d62 <proc_dispatch>:

void proc_dispatch()
{
   11d62:	55                   	push   %ebp
   11d63:	89 e5                	mov    %esp,%ebp
   11d65:	83 ec 18             	sub    $0x18,%esp
    proc_pcb_t *cur = cur_proc();
   11d68:	e8 a6 05 00 00       	call   12313 <cur_proc>
   11d6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /* 找到进程 */
    proc_pcb_t *next = proc_schedule();
   11d70:	e8 65 ff ff ff       	call   11cda <proc_schedule>
   11d75:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (next != cur && next->status == TASK_READY)
   11d78:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d7b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   11d7e:	74 6a                	je     11dea <proc_dispatch+0x88>
   11d80:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d83:	8b 40 24             	mov    0x24(%eax),%eax
   11d86:	83 f8 02             	cmp    $0x2,%eax
   11d89:	75 5f                	jne    11dea <proc_dispatch+0x88>
    {
        irq_status status;
        proc_manager.cur_proc = next;
   11d8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d8e:	a3 80 81 01 00       	mov    %eax,0x18180
        next->status = TASK_RUNNING;
   11d93:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d96:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)

        /* 切换进程 */
        cur->ifsaved_context = UNSAVED_CONTEXT;
   11d9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11da0:	c7 40 38 01 00 00 00 	movl   $0x1,0x38(%eax)
        switch_pgdir(next->pgdir); /* 切换页表 */
   11da7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11daa:	8b 40 54             	mov    0x54(%eax),%eax
   11dad:	83 ec 0c             	sub    $0xc,%esp
   11db0:	50                   	push   %eax
   11db1:	e8 ed 04 00 00       	call   122a3 <switch_pgdir>
   11db6:	83 c4 10             	add    $0x10,%esp
        update_tss_esp0(next);     /* 切换内核栈 */
   11db9:	83 ec 0c             	sub    $0xc,%esp
   11dbc:	ff 75 f0             	pushl  -0x10(%ebp)
   11dbf:	e8 ce 04 00 00       	call   12292 <update_tss_esp0>
   11dc4:	83 c4 10             	add    $0x10,%esp
        irq_leave_protection(proc_manager.irq_state);
   11dc7:	a1 c0 81 01 00       	mov    0x181c0,%eax
   11dcc:	83 ec 0c             	sub    $0xc,%esp
   11dcf:	50                   	push   %eax
   11dd0:	e8 86 ed ff ff       	call   10b5b <irq_leave_protection>
   11dd5:	83 c4 10             	add    $0x10,%esp
        /* 此处可能还需要修改 */
        proc_switch(next); /* 切换进程 */
   11dd8:	83 ec 0c             	sub    $0xc,%esp
   11ddb:	ff 75 f0             	pushl  -0x10(%ebp)
   11dde:	e8 c3 03 00 00       	call   121a6 <proc_switch>
   11de3:	83 c4 10             	add    $0x10,%esp
    {
   11de6:	90                   	nop
    {
        /* 只有一个进程则无法切换 */
        irq_leave_protection(proc_manager.irq_state);
        return;
    }
    return;
   11de7:	90                   	nop
   11de8:	eb 28                	jmp    11e12 <proc_dispatch+0xb0>
    else if (klist_len(&proc_manager.ready_list) == 1)
   11dea:	83 ec 0c             	sub    $0xc,%esp
   11ded:	68 98 81 01 00       	push   $0x18198
   11df2:	e8 b9 0d 00 00       	call   12bb0 <klist_len>
   11df7:	83 c4 10             	add    $0x10,%esp
   11dfa:	83 f8 01             	cmp    $0x1,%eax
   11dfd:	75 13                	jne    11e12 <proc_dispatch+0xb0>
        irq_leave_protection(proc_manager.irq_state);
   11dff:	a1 c0 81 01 00       	mov    0x181c0,%eax
   11e04:	83 ec 0c             	sub    $0xc,%esp
   11e07:	50                   	push   %eax
   11e08:	e8 4e ed ff ff       	call   10b5b <irq_leave_protection>
   11e0d:	83 c4 10             	add    $0x10,%esp
        return;
   11e10:	eb 01                	jmp    11e13 <proc_dispatch+0xb1>
    return;
   11e12:	90                   	nop
}
   11e13:	c9                   	leave  
   11e14:	c3                   	ret    

00011e15 <thread_FIFO>:
 * @brief 先进先出算法
 *
 * @return thread_pcb_t*
 */
thread_pcb_t *thread_FIFO()
{
   11e15:	55                   	push   %ebp
   11e16:	89 e5                	mov    %esp,%ebp
   11e18:	83 ec 18             	sub    $0x18,%esp
    klist_node_t *next_node = klist_get_first_node(&thread_manager.ready_list);
   11e1b:	83 ec 0c             	sub    $0xc,%esp
   11e1e:	68 18 81 01 00       	push   $0x18118
   11e23:	e8 93 0d 00 00       	call   12bbb <klist_get_first_node>
   11e28:	83 c4 10             	add    $0x10,%esp
   11e2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    thread_pcb_t *next = KLIST_STRUCT_ADDR(next_node, thread_pcb_t, state_node);
   11e2e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11e32:	74 08                	je     11e3c <thread_FIFO+0x27>
   11e34:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e37:	83 e8 28             	sub    $0x28,%eax
   11e3a:	eb 05                	jmp    11e41 <thread_FIFO+0x2c>
   11e3c:	b8 00 00 00 00       	mov    $0x0,%eax
   11e41:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return next;
   11e44:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   11e47:	c9                   	leave  
   11e48:	c3                   	ret    

00011e49 <proc_FIFO>:

proc_pcb_t *proc_FIFO()
{
   11e49:	55                   	push   %ebp
   11e4a:	89 e5                	mov    %esp,%ebp
   11e4c:	83 ec 18             	sub    $0x18,%esp
    klist_node_t *next_node = klist_get_first_node(&proc_manager.ready_list);
   11e4f:	83 ec 0c             	sub    $0xc,%esp
   11e52:	68 98 81 01 00       	push   $0x18198
   11e57:	e8 5f 0d 00 00       	call   12bbb <klist_get_first_node>
   11e5c:	83 c4 10             	add    $0x10,%esp
   11e5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    proc_pcb_t *next = KLIST_STRUCT_ADDR(next_node, proc_pcb_t, state_node);
   11e62:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11e66:	74 08                	je     11e70 <proc_FIFO+0x27>
   11e68:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e6b:	83 e8 3c             	sub    $0x3c,%eax
   11e6e:	eb 05                	jmp    11e75 <proc_FIFO+0x2c>
   11e70:	b8 00 00 00 00       	mov    $0x0,%eax
   11e75:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return next;
   11e78:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   11e7b:	c9                   	leave  
   11e7c:	c3                   	ret    

00011e7d <thread_time_ticks>:

void thread_time_ticks()
{
   11e7d:	55                   	push   %ebp
   11e7e:	89 e5                	mov    %esp,%ebp
   11e80:	83 ec 18             	sub    $0x18,%esp
    // irq_status status = irq_enter_protection();
    thread_pcb_t *cur = cur_thread();
   11e83:	e8 25 fe ff ff       	call   11cad <cur_thread>
   11e88:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (--cur->ticks <= 0)
   11e8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e8e:	8b 40 24             	mov    0x24(%eax),%eax
   11e91:	8d 50 ff             	lea    -0x1(%eax),%edx
   11e94:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e97:	89 50 24             	mov    %edx,0x24(%eax)
   11e9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e9d:	8b 40 24             	mov    0x24(%eax),%eax
   11ea0:	85 c0                	test   %eax,%eax
   11ea2:	7f 1d                	jg     11ec1 <thread_time_ticks+0x44>
    {
        /* 重新插入就绪队列的尾部 */
        thread_set_ready(cur);
   11ea4:	83 ec 0c             	sub    $0xc,%esp
   11ea7:	ff 75 f4             	pushl  -0xc(%ebp)
   11eaa:	e8 83 fa ff ff       	call   11932 <thread_set_ready>
   11eaf:	83 c4 10             	add    $0x10,%esp

        cur->ticks = TASK_TICKS_DEFAULT;
   11eb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11eb5:	c7 40 24 05 00 00 00 	movl   $0x5,0x24(%eax)
        thread_dispatch();
   11ebc:	e8 3c fe ff ff       	call   11cfd <thread_dispatch>
    }
    // status = irq_enter_protection();
}
   11ec1:	90                   	nop
   11ec2:	c9                   	leave  
   11ec3:	c3                   	ret    

00011ec4 <thread_get_manager>:

thread_manager_t *thread_get_manager()
{
   11ec4:	55                   	push   %ebp
   11ec5:	89 e5                	mov    %esp,%ebp
    return &thread_manager;
   11ec7:	b8 00 81 01 00       	mov    $0x18100,%eax
}
   11ecc:	5d                   	pop    %ebp
   11ecd:	c3                   	ret    

00011ece <proc_init>:
 * @brief 创建进程
 *
 * @param _filename
 */
proc_pcb_t *proc_init(void *_filename, char const *proc_name)
{
   11ece:	55                   	push   %ebp
   11ecf:	89 e5                	mov    %esp,%ebp
   11ed1:	83 ec 18             	sub    $0x18,%esp
    proc_pcb_t *pcb = (proc_pcb_t *)kalloc_pages(1); /* 给PCB分配一页内存 */
   11ed4:	83 ec 0c             	sub    $0xc,%esp
   11ed7:	6a 01                	push   $0x1
   11ed9:	e8 24 ef ff ff       	call   10e02 <kalloc_pages>
   11ede:	83 c4 10             	add    $0x10,%esp
   11ee1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    pcb->_filename = _filename;
   11ee4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ee7:	8b 55 08             	mov    0x8(%ebp),%edx
   11eea:	89 50 1c             	mov    %edx,0x1c(%eax)
    kstrcpy(pcb->name, proc_name);
   11eed:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ef0:	83 c0 08             	add    $0x8,%eax
   11ef3:	83 ec 08             	sub    $0x8,%esp
   11ef6:	ff 75 0c             	pushl  0xc(%ebp)
   11ef9:	50                   	push   %eax
   11efa:	e8 18 0b 00 00       	call   12a17 <kstrcpy>
   11eff:	83 c4 10             	add    $0x10,%esp
    pcb->pgdir = create_page_table(); /* 创建页表相关 */
   11f02:	e8 90 f4 ff ff       	call   11397 <create_page_table>
   11f07:	89 c2                	mov    %eax,%edx
   11f09:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f0c:	89 50 54             	mov    %edx,0x54(%eax)
    pcb->ticks = TASK_TICKS_DEFAULT;
   11f0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f12:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
    pcb->pid = alloc_pid();    /* 给进程分配PID */
   11f19:	e8 de 03 00 00       	call   122fc <alloc_pid>
   11f1e:	89 c2                	mov    %eax,%edx
   11f20:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f23:	89 10                	mov    %edx,(%eax)
    pcb->parent = NULL;        /* 初始化父pcb */
   11f25:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f28:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
    pcb->ifkernel = USER_PROC; /* 确定为用户进程 */
   11f2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f32:	c6 40 34 01          	movb   $0x1,0x34(%eax)
    pcb->ifsaved_context = UNSAVED_CONTEXT;
   11f36:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f39:	c7 40 38 01 00 00 00 	movl   $0x1,0x38(%eax)
    proc_set_general(pcb);
   11f40:	83 ec 0c             	sub    $0xc,%esp
   11f43:	ff 75 f4             	pushl  -0xc(%ebp)
   11f46:	e8 86 f9 ff ff       	call   118d1 <proc_set_general>
   11f4b:	83 c4 10             	add    $0x10,%esp
    proc_set_ready(pcb);
   11f4e:	83 ec 0c             	sub    $0xc,%esp
   11f51:	ff 75 f4             	pushl  -0xc(%ebp)
   11f54:	e8 1a fa ff ff       	call   11973 <proc_set_ready>
   11f59:	83 c4 10             	add    $0x10,%esp
    proc_start(pcb, USER_PROC);
   11f5c:	83 ec 08             	sub    $0x8,%esp
   11f5f:	6a 01                	push   $0x1
   11f61:	ff 75 f4             	pushl  -0xc(%ebp)
   11f64:	e8 08 00 00 00       	call   11f71 <proc_start>
   11f69:	83 c4 10             	add    $0x10,%esp
    // 初始化进程的线程表

    // kthread_init(pcb->main_thread, proc_name, TASK_DEFAULF_PRIO);
    // kthread_create(pcb->main_thread, (void *)proc_start, pcb);
    return pcb;
   11f6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11f6f:	c9                   	leave  
   11f70:	c3                   	ret    

00011f71 <proc_start>:
 * @brief 初始化进程的相关上下文信息
 *
 * @param pcb
 */
void proc_start(proc_pcb_t *pcb, uint8_t ifkernel)
{
   11f71:	55                   	push   %ebp
   11f72:	89 e5                	mov    %esp,%ebp
   11f74:	83 ec 28             	sub    $0x28,%esp
   11f77:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f7a:	88 45 e4             	mov    %al,-0x1c(%ebp)
    void *function = pcb->_filename;
   11f7d:	8b 45 08             	mov    0x8(%ebp),%eax
   11f80:	8b 40 1c             	mov    0x1c(%eax),%eax
   11f83:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /* 存储上下文的内容 */
    if (ifkernel == KERNEL_PROC)
   11f86:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
   11f8a:	75 0c                	jne    11f98 <proc_start+0x27>
    {
        pcb->kstack = (uint32_t *)KERNEL_STACK_SIZE;
   11f8c:	8b 45 08             	mov    0x8(%ebp),%eax
   11f8f:	c7 40 04 00 20 00 00 	movl   $0x2000,0x4(%eax)
   11f96:	eb 10                	jmp    11fa8 <proc_start+0x37>
    }
    else
    {
        pcb->kstack = (uint32_t *)((uint32_t)pcb + MEM_PAGE_SIZE - 1); /* 维护proc栈底的位置 */
   11f98:	8b 45 08             	mov    0x8(%ebp),%eax
   11f9b:	05 ff 0f 00 00       	add    $0xfff,%eax
   11fa0:	89 c2                	mov    %eax,%edx
   11fa2:	8b 45 08             	mov    0x8(%ebp),%eax
   11fa5:	89 50 04             	mov    %edx,0x4(%eax)
    }
    pcb->context = (context_t *)((uint32_t)pcb + sizeof(proc_pcb_t)); /* 将上下文放在靠近pcb的位置 */
   11fa8:	8b 45 08             	mov    0x8(%ebp),%eax
   11fab:	83 c0 5c             	add    $0x5c,%eax
   11fae:	89 c2                	mov    %eax,%edx
   11fb0:	8b 45 08             	mov    0x8(%ebp),%eax
   11fb3:	89 50 50             	mov    %edx,0x50(%eax)

    pcb->priority = TASK_DEFAULF_PRIO;
   11fb6:	8b 45 08             	mov    0x8(%ebp),%eax
   11fb9:	c7 40 20 1f 00 00 00 	movl   $0x1f,0x20(%eax)
    pcb->stack_magic = TASK_STACK_MAGIC;
   11fc0:	8b 45 08             	mov    0x8(%ebp),%eax
   11fc3:	c7 40 28 16 09 87 19 	movl   $0x19870916,0x28(%eax)
    pcb->status = TASK_READY;
   11fca:	8b 45 08             	mov    0x8(%ebp),%eax
   11fcd:	c7 40 24 02 00 00 00 	movl   $0x2,0x24(%eax)
    pcb->thread_table = NULL;
   11fd4:	8b 45 08             	mov    0x8(%ebp),%eax
   11fd7:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
    pcb->ticks = TASK_TICKS_DEFAULT;
   11fde:	8b 45 08             	mov    0x8(%ebp),%eax
   11fe1:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
    pcb->context->eip = function;
   11fe8:	8b 45 08             	mov    0x8(%ebp),%eax
   11feb:	8b 40 50             	mov    0x50(%eax),%eax
   11fee:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11ff1:	89 50 34             	mov    %edx,0x34(%eax)
    pcb->context->eflags = (EFLAGS_IF | ELFAGS_MBS);
   11ff4:	8b 45 08             	mov    0x8(%ebp),%eax
   11ff7:	8b 40 50             	mov    0x50(%eax),%eax
   11ffa:	c7 40 3c 02 02 00 00 	movl   $0x202,0x3c(%eax)

    if (ifkernel == KERNEL_PROC)
   12001:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
   12005:	0f 85 ce 00 00 00    	jne    120d9 <proc_start+0x168>
    {
        pcb->context->esp = (void *)(kalloc_pages(1) + MEM_PAGE_SIZE);
   1200b:	83 ec 0c             	sub    $0xc,%esp
   1200e:	6a 01                	push   $0x1
   12010:	e8 ed ed ff ff       	call   10e02 <kalloc_pages>
   12015:	83 c4 10             	add    $0x10,%esp
   12018:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
   1201e:	8b 45 08             	mov    0x8(%ebp),%eax
   12021:	8b 40 50             	mov    0x50(%eax),%eax
   12024:	89 50 40             	mov    %edx,0x40(%eax)
        /* 上下文初始化 */
        pcb->context->eax = pcb->context->ebx = pcb->context->edx = pcb->context->ecx = 0;
   12027:	8b 45 08             	mov    0x8(%ebp),%eax
   1202a:	8b 40 50             	mov    0x50(%eax),%eax
   1202d:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
   12034:	8b 55 08             	mov    0x8(%ebp),%edx
   12037:	8b 52 50             	mov    0x50(%edx),%edx
   1203a:	8b 40 1c             	mov    0x1c(%eax),%eax
   1203d:	89 42 18             	mov    %eax,0x18(%edx)
   12040:	8b 45 08             	mov    0x8(%ebp),%eax
   12043:	8b 40 50             	mov    0x50(%eax),%eax
   12046:	8b 52 18             	mov    0x18(%edx),%edx
   12049:	89 50 14             	mov    %edx,0x14(%eax)
   1204c:	8b 55 08             	mov    0x8(%ebp),%edx
   1204f:	8b 52 50             	mov    0x50(%edx),%edx
   12052:	8b 40 14             	mov    0x14(%eax),%eax
   12055:	89 42 20             	mov    %eax,0x20(%edx)
        pcb->context->edi = pcb->context->esi = pcb->context->ebp = pcb->context->esp_dummy = 0;
   12058:	8b 45 08             	mov    0x8(%ebp),%eax
   1205b:	8b 40 50             	mov    0x50(%eax),%eax
   1205e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
   12065:	8b 55 08             	mov    0x8(%ebp),%edx
   12068:	8b 52 50             	mov    0x50(%edx),%edx
   1206b:	8b 40 10             	mov    0x10(%eax),%eax
   1206e:	89 42 0c             	mov    %eax,0xc(%edx)
   12071:	8b 45 08             	mov    0x8(%ebp),%eax
   12074:	8b 40 50             	mov    0x50(%eax),%eax
   12077:	8b 52 0c             	mov    0xc(%edx),%edx
   1207a:	89 50 08             	mov    %edx,0x8(%eax)
   1207d:	8b 55 08             	mov    0x8(%ebp),%edx
   12080:	8b 52 50             	mov    0x50(%edx),%edx
   12083:	8b 40 08             	mov    0x8(%eax),%eax
   12086:	89 42 04             	mov    %eax,0x4(%edx)
        pcb->context->gs = pcb->context->fs = pcb->context->es = pcb->context->ds = KERNEL_SELECTOR_DS;
   12089:	8b 45 08             	mov    0x8(%ebp),%eax
   1208c:	8b 40 50             	mov    0x50(%eax),%eax
   1208f:	c7 40 30 10 00 00 00 	movl   $0x10,0x30(%eax)
   12096:	8b 55 08             	mov    0x8(%ebp),%edx
   12099:	8b 52 50             	mov    0x50(%edx),%edx
   1209c:	8b 40 30             	mov    0x30(%eax),%eax
   1209f:	89 42 2c             	mov    %eax,0x2c(%edx)
   120a2:	8b 45 08             	mov    0x8(%ebp),%eax
   120a5:	8b 40 50             	mov    0x50(%eax),%eax
   120a8:	8b 52 2c             	mov    0x2c(%edx),%edx
   120ab:	89 50 28             	mov    %edx,0x28(%eax)
   120ae:	8b 55 08             	mov    0x8(%ebp),%edx
   120b1:	8b 52 50             	mov    0x50(%edx),%edx
   120b4:	8b 40 28             	mov    0x28(%eax),%eax
   120b7:	89 42 24             	mov    %eax,0x24(%edx)
        pcb->context->ss = KERNEL_SELECTOR_DS;
   120ba:	8b 45 08             	mov    0x8(%ebp),%eax
   120bd:	8b 40 50             	mov    0x50(%eax),%eax
   120c0:	c7 40 44 10 00 00 00 	movl   $0x10,0x44(%eax)
        pcb->context->cs = KERNEL_SELECTOR_CS;
   120c7:	8b 45 08             	mov    0x8(%ebp),%eax
   120ca:	8b 40 50             	mov    0x50(%eax),%eax
   120cd:	c7 40 38 08 00 00 00 	movl   $0x8,0x38(%eax)
        pcb->context->cs = USER_SELECTOR_CS;
    }

    /* 进入新的进程 */
    // proc_switch(pcb);
}
   120d4:	e9 ca 00 00 00       	jmp    121a3 <proc_start+0x232>
        pcb->context->esp = (void *)(ualloc_pages(1) + MEM_PAGE_SIZE);
   120d9:	83 ec 0c             	sub    $0xc,%esp
   120dc:	6a 01                	push   $0x1
   120de:	e8 69 ed ff ff       	call   10e4c <ualloc_pages>
   120e3:	83 c4 10             	add    $0x10,%esp
   120e6:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
   120ec:	8b 45 08             	mov    0x8(%ebp),%eax
   120ef:	8b 40 50             	mov    0x50(%eax),%eax
   120f2:	89 50 40             	mov    %edx,0x40(%eax)
        pcb->context->eax = pcb->context->ebx = pcb->context->edx = pcb->context->ecx = 0;
   120f5:	8b 45 08             	mov    0x8(%ebp),%eax
   120f8:	8b 40 50             	mov    0x50(%eax),%eax
   120fb:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
   12102:	8b 55 08             	mov    0x8(%ebp),%edx
   12105:	8b 52 50             	mov    0x50(%edx),%edx
   12108:	8b 40 1c             	mov    0x1c(%eax),%eax
   1210b:	89 42 18             	mov    %eax,0x18(%edx)
   1210e:	8b 45 08             	mov    0x8(%ebp),%eax
   12111:	8b 40 50             	mov    0x50(%eax),%eax
   12114:	8b 52 18             	mov    0x18(%edx),%edx
   12117:	89 50 14             	mov    %edx,0x14(%eax)
   1211a:	8b 55 08             	mov    0x8(%ebp),%edx
   1211d:	8b 52 50             	mov    0x50(%edx),%edx
   12120:	8b 40 14             	mov    0x14(%eax),%eax
   12123:	89 42 20             	mov    %eax,0x20(%edx)
        pcb->context->edi = pcb->context->esi = pcb->context->ebp = pcb->context->esp_dummy = 0;
   12126:	8b 45 08             	mov    0x8(%ebp),%eax
   12129:	8b 40 50             	mov    0x50(%eax),%eax
   1212c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
   12133:	8b 55 08             	mov    0x8(%ebp),%edx
   12136:	8b 52 50             	mov    0x50(%edx),%edx
   12139:	8b 40 10             	mov    0x10(%eax),%eax
   1213c:	89 42 0c             	mov    %eax,0xc(%edx)
   1213f:	8b 45 08             	mov    0x8(%ebp),%eax
   12142:	8b 40 50             	mov    0x50(%eax),%eax
   12145:	8b 52 0c             	mov    0xc(%edx),%edx
   12148:	89 50 08             	mov    %edx,0x8(%eax)
   1214b:	8b 55 08             	mov    0x8(%ebp),%edx
   1214e:	8b 52 50             	mov    0x50(%edx),%edx
   12151:	8b 40 08             	mov    0x8(%eax),%eax
   12154:	89 42 04             	mov    %eax,0x4(%edx)
        pcb->context->gs = 0; /* 显存用不到 */
   12157:	8b 45 08             	mov    0x8(%ebp),%eax
   1215a:	8b 40 50             	mov    0x50(%eax),%eax
   1215d:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
        pcb->context->fs = pcb->context->es = pcb->context->ds = USER_SELECTOR_DS;
   12164:	8b 45 08             	mov    0x8(%ebp),%eax
   12167:	8b 50 50             	mov    0x50(%eax),%edx
   1216a:	c7 42 30 2b 00 00 00 	movl   $0x2b,0x30(%edx)
   12171:	8b 45 08             	mov    0x8(%ebp),%eax
   12174:	8b 40 50             	mov    0x50(%eax),%eax
   12177:	8b 52 30             	mov    0x30(%edx),%edx
   1217a:	89 50 2c             	mov    %edx,0x2c(%eax)
   1217d:	8b 55 08             	mov    0x8(%ebp),%edx
   12180:	8b 52 50             	mov    0x50(%edx),%edx
   12183:	8b 40 2c             	mov    0x2c(%eax),%eax
   12186:	89 42 28             	mov    %eax,0x28(%edx)
        pcb->context->ss = USER_SELECTOR_DS;
   12189:	8b 45 08             	mov    0x8(%ebp),%eax
   1218c:	8b 40 50             	mov    0x50(%eax),%eax
   1218f:	c7 40 44 2b 00 00 00 	movl   $0x2b,0x44(%eax)
        pcb->context->cs = USER_SELECTOR_CS;
   12196:	8b 45 08             	mov    0x8(%ebp),%eax
   12199:	8b 40 50             	mov    0x50(%eax),%eax
   1219c:	c7 40 38 23 00 00 00 	movl   $0x23,0x38(%eax)
}
   121a3:	90                   	nop
   121a4:	c9                   	leave  
   121a5:	c3                   	ret    

000121a6 <proc_switch>:

void proc_switch(proc_pcb_t *pcb)
{
   121a6:	55                   	push   %ebp
   121a7:	89 e5                	mov    %esp,%ebp
   121a9:	57                   	push   %edi
   121aa:	56                   	push   %esi
   121ab:	53                   	push   %ebx
   121ac:	83 ec 2c             	sub    $0x2c,%esp
        "pop %%fs\n\t"
        "pop %%gs\n\t"
        "pop %%ebp\n\t"
        "iret"
        :
        : "a"(pcb->context->eax), "b"(pcb->context->ebx), "d"(pcb->context->edx), "c"(pcb->context->ecx),
   121af:	8b 45 08             	mov    0x8(%ebp),%eax
   121b2:	8b 40 50             	mov    0x50(%eax),%eax
   121b5:	8b 40 20             	mov    0x20(%eax),%eax
   121b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
   121bb:	8b 45 08             	mov    0x8(%ebp),%eax
   121be:	8b 40 50             	mov    0x50(%eax),%eax
   121c1:	8b 58 14             	mov    0x14(%eax),%ebx
   121c4:	8b 45 08             	mov    0x8(%ebp),%eax
   121c7:	8b 40 50             	mov    0x50(%eax),%eax
   121ca:	8b 50 18             	mov    0x18(%eax),%edx
   121cd:	8b 45 08             	mov    0x8(%ebp),%eax
   121d0:	8b 40 50             	mov    0x50(%eax),%eax
   121d3:	8b 48 1c             	mov    0x1c(%eax),%ecx
          "D"(pcb->context->edi), "S"(pcb->context->esi), [ebp] "g"(pcb->context->ebp),
   121d6:	8b 45 08             	mov    0x8(%ebp),%eax
   121d9:	8b 40 50             	mov    0x50(%eax),%eax
   121dc:	8b 78 04             	mov    0x4(%eax),%edi
   121df:	8b 45 08             	mov    0x8(%ebp),%eax
   121e2:	8b 40 50             	mov    0x50(%eax),%eax
   121e5:	8b 70 08             	mov    0x8(%eax),%esi
   121e8:	8b 45 08             	mov    0x8(%ebp),%eax
   121eb:	8b 40 50             	mov    0x50(%eax),%eax
   121ee:	8b 40 0c             	mov    0xc(%eax),%eax
   121f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
          [gs] "g"(pcb->context->gs), [fs] "g"(pcb->context->fs), [es] "g"(pcb->context->es), [ds] "g"(pcb->context->ds),
   121f4:	8b 45 08             	mov    0x8(%ebp),%eax
   121f7:	8b 40 50             	mov    0x50(%eax),%eax
   121fa:	8b 40 24             	mov    0x24(%eax),%eax
   121fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
   12200:	8b 45 08             	mov    0x8(%ebp),%eax
   12203:	8b 40 50             	mov    0x50(%eax),%eax
   12206:	8b 40 28             	mov    0x28(%eax),%eax
   12209:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   1220c:	8b 45 08             	mov    0x8(%ebp),%eax
   1220f:	8b 40 50             	mov    0x50(%eax),%eax
   12212:	8b 40 2c             	mov    0x2c(%eax),%eax
   12215:	89 45 e0             	mov    %eax,-0x20(%ebp)
   12218:	8b 45 08             	mov    0x8(%ebp),%eax
   1221b:	8b 40 50             	mov    0x50(%eax),%eax
   1221e:	8b 40 30             	mov    0x30(%eax),%eax
   12221:	89 45 dc             	mov    %eax,-0x24(%ebp)
          [ss] "g"(pcb->context->ss), [esp] "g"(pcb->context->esp), [eflags] "g"(pcb->context->eflags), [cs] "g"(pcb->context->cs), [eip] "g"(pcb->context->eip)
   12224:	8b 45 08             	mov    0x8(%ebp),%eax
   12227:	8b 40 50             	mov    0x50(%eax),%eax
   1222a:	8b 40 44             	mov    0x44(%eax),%eax
   1222d:	89 45 d8             	mov    %eax,-0x28(%ebp)
   12230:	8b 45 08             	mov    0x8(%ebp),%eax
   12233:	8b 40 50             	mov    0x50(%eax),%eax
   12236:	8b 40 40             	mov    0x40(%eax),%eax
   12239:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1223c:	8b 45 08             	mov    0x8(%ebp),%eax
   1223f:	8b 40 50             	mov    0x50(%eax),%eax
   12242:	8b 40 3c             	mov    0x3c(%eax),%eax
   12245:	89 45 d0             	mov    %eax,-0x30(%ebp)
   12248:	8b 45 08             	mov    0x8(%ebp),%eax
   1224b:	8b 40 50             	mov    0x50(%eax),%eax
   1224e:	8b 40 38             	mov    0x38(%eax),%eax
   12251:	89 45 cc             	mov    %eax,-0x34(%ebp)
   12254:	8b 45 08             	mov    0x8(%ebp),%eax
   12257:	8b 40 50             	mov    0x50(%eax),%eax
   1225a:	8b 40 34             	mov    0x34(%eax),%eax
   1225d:	89 45 c8             	mov    %eax,-0x38(%ebp)
    __asm__ __volatile__(
   12260:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12263:	ff 75 d8             	pushl  -0x28(%ebp)
   12266:	ff 75 d4             	pushl  -0x2c(%ebp)
   12269:	ff 75 d0             	pushl  -0x30(%ebp)
   1226c:	ff 75 cc             	pushl  -0x34(%ebp)
   1226f:	ff 75 c8             	pushl  -0x38(%ebp)
   12272:	ff 75 ec             	pushl  -0x14(%ebp)
   12275:	ff 75 e8             	pushl  -0x18(%ebp)
   12278:	ff 75 e4             	pushl  -0x1c(%ebp)
   1227b:	ff 75 e0             	pushl  -0x20(%ebp)
   1227e:	ff 75 dc             	pushl  -0x24(%ebp)
   12281:	1f                   	pop    %ds
   12282:	07                   	pop    %es
   12283:	0f a1                	pop    %fs
   12285:	0f a9                	pop    %gs
   12287:	5d                   	pop    %ebp
   12288:	cf                   	iret   
        : "memory");
}
   12289:	90                   	nop
   1228a:	83 c4 2c             	add    $0x2c,%esp
   1228d:	5b                   	pop    %ebx
   1228e:	5e                   	pop    %esi
   1228f:	5f                   	pop    %edi
   12290:	5d                   	pop    %ebp
   12291:	c3                   	ret    

00012292 <update_tss_esp0>:

void update_tss_esp0(proc_pcb_t *proc)
{
   12292:	55                   	push   %ebp
   12293:	89 e5                	mov    %esp,%ebp
    /* 切换内核栈 */
    tss.esp0 = (uint32_t *)(proc->kstack);
   12295:	8b 45 08             	mov    0x8(%ebp),%eax
   12298:	8b 40 04             	mov    0x4(%eax),%eax
   1229b:	a3 84 80 01 00       	mov    %eax,0x18084
}
   122a0:	90                   	nop
   122a1:	5d                   	pop    %ebp
   122a2:	c3                   	ret    

000122a3 <switch_pgdir>:

void switch_pgdir(uint32_t *dir)
{
   122a3:	55                   	push   %ebp
   122a4:	89 e5                	mov    %esp,%ebp
    wcr3((uint32_t)dir);
   122a6:	8b 45 08             	mov    0x8(%ebp),%eax
   122a9:	50                   	push   %eax
   122aa:	e8 bc f4 ff ff       	call   1176b <wcr3>
   122af:	83 c4 04             	add    $0x4,%esp
}
   122b2:	90                   	nop
   122b3:	c9                   	leave  
   122b4:	c3                   	ret    

000122b5 <proc_time_ticks>:
/**
 * @brief 实践轮片进程调度
 *
 */
void proc_time_ticks()
{
   122b5:	55                   	push   %ebp
   122b6:	89 e5                	mov    %esp,%ebp
   122b8:	83 ec 18             	sub    $0x18,%esp
    /* 获取进程的信息 */
    proc_pcb_t *cur = cur_proc();
   122bb:	e8 53 00 00 00       	call   12313 <cur_proc>
   122c0:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (--cur->ticks <= 0)
   122c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   122c6:	8b 40 2c             	mov    0x2c(%eax),%eax
   122c9:	8d 50 ff             	lea    -0x1(%eax),%edx
   122cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   122cf:	89 50 2c             	mov    %edx,0x2c(%eax)
   122d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   122d5:	8b 40 2c             	mov    0x2c(%eax),%eax
   122d8:	85 c0                	test   %eax,%eax
   122da:	7f 1d                	jg     122f9 <proc_time_ticks+0x44>
    {
        /* 重新插入就绪队列的尾部 */
        proc_set_ready(cur);
   122dc:	83 ec 0c             	sub    $0xc,%esp
   122df:	ff 75 f4             	pushl  -0xc(%ebp)
   122e2:	e8 8c f6 ff ff       	call   11973 <proc_set_ready>
   122e7:	83 c4 10             	add    $0x10,%esp

        cur->ticks = TASK_TICKS_DEFAULT;
   122ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
   122ed:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)

        proc_dispatch();
   122f4:	e8 69 fa ff ff       	call   11d62 <proc_dispatch>
    }
}
   122f9:	90                   	nop
   122fa:	c9                   	leave  
   122fb:	c3                   	ret    

000122fc <alloc_pid>:
 * @brief 获取进程的PID
 *
 * @return int
 */
int alloc_pid()
{
   122fc:	55                   	push   %ebp
   122fd:	89 e5                	mov    %esp,%ebp
    static int global_pid = 0;
    /* 此处需要上锁 */
    ++global_pid;
   122ff:	a1 00 50 01 00       	mov    0x15000,%eax
   12304:	83 c0 01             	add    $0x1,%eax
   12307:	a3 00 50 01 00       	mov    %eax,0x15000
    return global_pid;
   1230c:	a1 00 50 01 00       	mov    0x15000,%eax
}
   12311:	5d                   	pop    %ebp
   12312:	c3                   	ret    

00012313 <cur_proc>:
 * @brief 获取现在的进程
 *
 * @return proc_pcb_t*
 */
proc_pcb_t *cur_proc()
{
   12313:	55                   	push   %ebp
   12314:	89 e5                	mov    %esp,%ebp
    return proc_manager.cur_proc;
   12316:	a1 80 81 01 00       	mov    0x18180,%eax
}
   1231b:	5d                   	pop    %ebp
   1231c:	c3                   	ret    

0001231d <proc_ifkernel>:
 * @brief 判断当前运行的进程是否属于内核进程
 *
 * @return uint8_t
 */
uint8_t proc_ifkernel()
{
   1231d:	55                   	push   %ebp
   1231e:	89 e5                	mov    %esp,%ebp
    return proc_manager.cur_proc->ifkernel == KERNEL_PROC;
   12320:	a1 80 81 01 00       	mov    0x18180,%eax
   12325:	0f b6 40 34          	movzbl 0x34(%eax),%eax
   12329:	84 c0                	test   %al,%al
   1232b:	0f 94 c0             	sete   %al
}
   1232e:	5d                   	pop    %ebp
   1232f:	c3                   	ret    

00012330 <fork>:
 * @brief fork函数
 *
 * @return int 目标进程的pid
 */
pid_t fork()
{
   12330:	55                   	push   %ebp
   12331:	89 e5                	mov    %esp,%ebp
   12333:	83 ec 10             	sub    $0x10,%esp
    return _syscall0(SYS_FORK);
   12336:	b8 03 00 00 00       	mov    $0x3,%eax
   1233b:	cd 80                	int    $0x80
   1233d:	89 45 fc             	mov    %eax,-0x4(%ebp)
   12340:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12343:	c9                   	leave  
   12344:	c3                   	ret    

00012345 <get_pid>:
/**
 * @brief 取得当前进程的PID
 *
 */
pid_t get_pid()
{
   12345:	55                   	push   %ebp
   12346:	89 e5                	mov    %esp,%ebp
   12348:	83 ec 10             	sub    $0x10,%esp
    return _syscall0(SYS_GETPID);
   1234b:	b8 00 00 00 00       	mov    $0x0,%eax
   12350:	cd 80                	int    $0x80
   12352:	89 45 fc             	mov    %eax,-0x4(%ebp)
   12355:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12358:	c9                   	leave  
   12359:	c3                   	ret    

0001235a <first_proc_init>:
/**
 * @brief 第一个用户进程的切换和初始化
 *
 */
void first_proc_init()
{
   1235a:	55                   	push   %ebp
   1235b:	89 e5                	mov    %esp,%ebp
   1235d:	83 ec 08             	sub    $0x8,%esp
    /* 声明函数入口 */
    void first_task_entry();

    // proc_init(first_task_entry, "first_task_entry");
    init_task((uint32_t)first_task_entry);
   12360:	b8 b3 05 01 00       	mov    $0x105b3,%eax
   12365:	83 ec 0c             	sub    $0xc,%esp
   12368:	50                   	push   %eax
   12369:	e8 da 0c 00 00       	call   13048 <init_task>
   1236e:	83 c4 10             	add    $0x10,%esp
   12371:	90                   	nop
   12372:	c9                   	leave  
   12373:	c3                   	ret    

00012374 <kmemset>:
 * @param dest
 * @param data
 * @param size
 */
void kmemset(void *dest, uint8_t data, int size)
{
   12374:	55                   	push   %ebp
   12375:	89 e5                	mov    %esp,%ebp
   12377:	83 ec 14             	sub    $0x14,%esp
   1237a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1237d:	88 45 ec             	mov    %al,-0x14(%ebp)
    if (size < 0)
   12380:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   12384:	78 26                	js     123ac <kmemset+0x38>
    {
        /*此处可以打印错误信息*/
        return;
    }

    uint8_t *d = (uint8_t *)dest;
   12386:	8b 45 08             	mov    0x8(%ebp),%eax
   12389:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (size--)
   1238c:	eb 0f                	jmp    1239d <kmemset+0x29>
    {
        *d++ = data;
   1238e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12391:	8d 50 01             	lea    0x1(%eax),%edx
   12394:	89 55 fc             	mov    %edx,-0x4(%ebp)
   12397:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
   1239b:	88 10                	mov    %dl,(%eax)
    while (size--)
   1239d:	8b 45 10             	mov    0x10(%ebp),%eax
   123a0:	8d 50 ff             	lea    -0x1(%eax),%edx
   123a3:	89 55 10             	mov    %edx,0x10(%ebp)
   123a6:	85 c0                	test   %eax,%eax
   123a8:	75 e4                	jne    1238e <kmemset+0x1a>
   123aa:	eb 01                	jmp    123ad <kmemset+0x39>
        return;
   123ac:	90                   	nop
    }
}
   123ad:	c9                   	leave  
   123ae:	c3                   	ret    

000123af <kmemcpy>:
 * @param dest
 * @param src
 * @param size
 */
void kmemcpy(void *dest, void *src, int size)
{
   123af:	55                   	push   %ebp
   123b0:	89 e5                	mov    %esp,%ebp
   123b2:	83 ec 10             	sub    $0x10,%esp
    if (size < 0)
   123b5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   123b9:	78 34                	js     123ef <kmemcpy+0x40>
    {
        /*此处可以打印错误信息*/
        return;
    }

    uint8_t *d = (uint8_t *)dest;
   123bb:	8b 45 08             	mov    0x8(%ebp),%eax
   123be:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t *s = (uint8_t *)src;
   123c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   123c4:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while (size--)
   123c7:	eb 17                	jmp    123e0 <kmemcpy+0x31>
    {
        *d++ = *s++;
   123c9:	8b 55 f8             	mov    -0x8(%ebp),%edx
   123cc:	8d 42 01             	lea    0x1(%edx),%eax
   123cf:	89 45 f8             	mov    %eax,-0x8(%ebp)
   123d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123d5:	8d 48 01             	lea    0x1(%eax),%ecx
   123d8:	89 4d fc             	mov    %ecx,-0x4(%ebp)
   123db:	0f b6 12             	movzbl (%edx),%edx
   123de:	88 10                	mov    %dl,(%eax)
    while (size--)
   123e0:	8b 45 10             	mov    0x10(%ebp),%eax
   123e3:	8d 50 ff             	lea    -0x1(%eax),%edx
   123e6:	89 55 10             	mov    %edx,0x10(%ebp)
   123e9:	85 c0                	test   %eax,%eax
   123eb:	75 dc                	jne    123c9 <kmemcpy+0x1a>
   123ed:	eb 01                	jmp    123f0 <kmemcpy+0x41>
        return;
   123ef:	90                   	nop
    }
}
   123f0:	c9                   	leave  
   123f1:	c3                   	ret    

000123f2 <klog_printf>:
 *
 * @param fmt
 * @param ...
 */
void klog_printf(const char *fmt, ...)
{
   123f2:	55                   	push   %ebp
   123f3:	89 e5                	mov    %esp,%ebp
   123f5:	81 ec 18 01 00 00    	sub    $0x118,%esp
    char buf[256];
    va_list args_list;

    kmemset(buf, 0, sizeof(buf));
   123fb:	68 00 01 00 00       	push   $0x100
   12400:	6a 00                	push   $0x0
   12402:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
   12408:	50                   	push   %eax
   12409:	e8 66 ff ff ff       	call   12374 <kmemset>
   1240e:	83 c4 0c             	add    $0xc,%esp

    va_start(args_list, fmt);
   12411:	8d 45 0c             	lea    0xc(%ebp),%eax
   12414:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
    klog_vsprintf(buf, fmt, args_list);
   1241a:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
   12420:	83 ec 04             	sub    $0x4,%esp
   12423:	50                   	push   %eax
   12424:	ff 75 08             	pushl  0x8(%ebp)
   12427:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
   1242d:	50                   	push   %eax
   1242e:	e8 36 00 00 00       	call   12469 <klog_vsprintf>
   12433:	83 c4 10             	add    $0x10,%esp
    va_end(args_list);

    char *p = buf;
   12436:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
   1243c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (*p != 0)
   1243f:	eb 1b                	jmp    1245c <klog_printf+0x6a>
    {
        write_serial(*p++);
   12441:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12444:	8d 50 01             	lea    0x1(%eax),%edx
   12447:	89 55 f4             	mov    %edx,-0xc(%ebp)
   1244a:	0f b6 00             	movzbl (%eax),%eax
   1244d:	0f be c0             	movsbl %al,%eax
   12450:	83 ec 0c             	sub    $0xc,%esp
   12453:	50                   	push   %eax
   12454:	e8 24 09 00 00       	call   12d7d <write_serial>
   12459:	83 c4 10             	add    $0x10,%esp
    while (*p != 0)
   1245c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1245f:	0f b6 00             	movzbl (%eax),%eax
   12462:	84 c0                	test   %al,%al
   12464:	75 db                	jne    12441 <klog_printf+0x4f>
    }
    /* 打印回车和换行 */
    // write_serial_end();
}
   12466:	90                   	nop
   12467:	c9                   	leave  
   12468:	c3                   	ret    

00012469 <klog_vsprintf>:
 * @param buf
 * @param fmt
 * @param args
 */
void klog_vsprintf(char *buf, const char *fmt, va_list args)
{
   12469:	55                   	push   %ebp
   1246a:	89 e5                	mov    %esp,%ebp
   1246c:	53                   	push   %ebx
   1246d:	83 ec 64             	sub    $0x64,%esp
    /* 状态机的状态 */
    enum
    {
        NORMAL,
        FORMAT
    } state = NORMAL;
   12470:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    char *ch = buf;
   12477:	8b 45 08             	mov    0x8(%ebp),%eax
   1247a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (*fmt != 0)
   1247d:	e9 22 02 00 00       	jmp    126a4 <klog_vsprintf+0x23b>
    {
        switch (state)
   12482:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12485:	85 c0                	test   %eax,%eax
   12487:	74 0a                	je     12493 <klog_vsprintf+0x2a>
   12489:	83 f8 01             	cmp    $0x1,%eax
   1248c:	74 66                	je     124f4 <klog_vsprintf+0x8b>
   1248e:	e9 11 02 00 00       	jmp    126a4 <klog_vsprintf+0x23b>
        {
        case NORMAL:
            if (*fmt == '%')
   12493:	8b 45 0c             	mov    0xc(%ebp),%eax
   12496:	0f b6 00             	movzbl (%eax),%eax
   12499:	3c 25                	cmp    $0x25,%al
   1249b:	75 10                	jne    124ad <klog_vsprintf+0x44>
            {
                state = FORMAT;
   1249d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
                fmt++;
   124a4:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
                break;
   124a8:	e9 f7 01 00 00       	jmp    126a4 <klog_vsprintf+0x23b>
            }

            if (*fmt == '\n')
   124ad:	8b 45 0c             	mov    0xc(%ebp),%eax
   124b0:	0f b6 00             	movzbl (%eax),%eax
   124b3:	3c 0a                	cmp    $0xa,%al
   124b5:	75 21                	jne    124d8 <klog_vsprintf+0x6f>
            {
                *ch++ = '\n';
   124b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   124ba:	8d 50 01             	lea    0x1(%eax),%edx
   124bd:	89 55 f4             	mov    %edx,-0xc(%ebp)
   124c0:	c6 00 0a             	movb   $0xa,(%eax)
                *ch++ = '\r';
   124c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   124c6:	8d 50 01             	lea    0x1(%eax),%edx
   124c9:	89 55 f4             	mov    %edx,-0xc(%ebp)
   124cc:	c6 00 0d             	movb   $0xd,(%eax)
                fmt++;
   124cf:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
   124d3:	e9 cc 01 00 00       	jmp    126a4 <klog_vsprintf+0x23b>
            }
            else
            {
                *ch++ = *fmt++;
   124d8:	8b 55 0c             	mov    0xc(%ebp),%edx
   124db:	8d 42 01             	lea    0x1(%edx),%eax
   124de:	89 45 0c             	mov    %eax,0xc(%ebp)
   124e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   124e4:	8d 48 01             	lea    0x1(%eax),%ecx
   124e7:	89 4d f4             	mov    %ecx,-0xc(%ebp)
   124ea:	0f b6 12             	movzbl (%edx),%edx
   124ed:	88 10                	mov    %dl,(%eax)
            }
            break;
   124ef:	e9 b0 01 00 00       	jmp    126a4 <klog_vsprintf+0x23b>
        case FORMAT:
            /* 错误类型 */
            if (*fmt == '%')
   124f4:	8b 45 0c             	mov    0xc(%ebp),%eax
   124f7:	0f b6 00             	movzbl (%eax),%eax
   124fa:	3c 25                	cmp    $0x25,%al
   124fc:	75 11                	jne    1250f <klog_vsprintf+0xa6>
            {
                *ch++ = '%';
   124fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12501:	8d 50 01             	lea    0x1(%eax),%edx
   12504:	89 55 f4             	mov    %edx,-0xc(%ebp)
   12507:	c6 00 25             	movb   $0x25,(%eax)
   1250a:	e9 89 01 00 00       	jmp    12698 <klog_vsprintf+0x22f>
            }
            /* int类型 */
            else if (*fmt == 'd')
   1250f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12512:	0f b6 00             	movzbl (%eax),%eax
   12515:	3c 64                	cmp    $0x64,%al
   12517:	0f 85 99 00 00 00    	jne    125b6 <klog_vsprintf+0x14d>
            {
   1251d:	89 e0                	mov    %esp,%eax
   1251f:	89 c3                	mov    %eax,%ebx
                int num = va_arg(args, int);
   12521:	8b 45 10             	mov    0x10(%ebp),%eax
   12524:	8d 50 04             	lea    0x4(%eax),%edx
   12527:	89 55 10             	mov    %edx,0x10(%ebp)
   1252a:	8b 00                	mov    (%eax),%eax
   1252c:	89 45 dc             	mov    %eax,-0x24(%ebp)
                int len = kintlen(num);
   1252f:	83 ec 0c             	sub    $0xc,%esp
   12532:	ff 75 dc             	pushl  -0x24(%ebp)
   12535:	e8 2a 03 00 00       	call   12864 <kintlen>
   1253a:	83 c4 10             	add    $0x10,%esp
   1253d:	89 45 d8             	mov    %eax,-0x28(%ebp)
                char p[len + 1];
   12540:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12543:	83 c0 01             	add    $0x1,%eax
   12546:	8d 50 ff             	lea    -0x1(%eax),%edx
   12549:	89 55 d4             	mov    %edx,-0x2c(%ebp)
   1254c:	89 c2                	mov    %eax,%edx
   1254e:	b8 10 00 00 00       	mov    $0x10,%eax
   12553:	83 e8 01             	sub    $0x1,%eax
   12556:	01 d0                	add    %edx,%eax
   12558:	b9 10 00 00 00       	mov    $0x10,%ecx
   1255d:	ba 00 00 00 00       	mov    $0x0,%edx
   12562:	f7 f1                	div    %ecx
   12564:	6b c0 10             	imul   $0x10,%eax,%eax
   12567:	29 c4                	sub    %eax,%esp
   12569:	89 e0                	mov    %esp,%eax
   1256b:	83 c0 00             	add    $0x0,%eax
   1256e:	89 45 d0             	mov    %eax,-0x30(%ebp)
                char *ptr = p;
   12571:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12574:	89 45 ec             	mov    %eax,-0x14(%ebp)
                kitoa_s(p, num, len);
   12577:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1257a:	83 ec 04             	sub    $0x4,%esp
   1257d:	ff 75 d8             	pushl  -0x28(%ebp)
   12580:	ff 75 dc             	pushl  -0x24(%ebp)
   12583:	50                   	push   %eax
   12584:	e8 2f 01 00 00       	call   126b8 <kitoa_s>
   12589:	83 c4 10             	add    $0x10,%esp
                while (*ptr != 0)
   1258c:	eb 17                	jmp    125a5 <klog_vsprintf+0x13c>
                {
                    *ch++ = *ptr++;
   1258e:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12591:	8d 42 01             	lea    0x1(%edx),%eax
   12594:	89 45 ec             	mov    %eax,-0x14(%ebp)
   12597:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1259a:	8d 48 01             	lea    0x1(%eax),%ecx
   1259d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
   125a0:	0f b6 12             	movzbl (%edx),%edx
   125a3:	88 10                	mov    %dl,(%eax)
                while (*ptr != 0)
   125a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   125a8:	0f b6 00             	movzbl (%eax),%eax
   125ab:	84 c0                	test   %al,%al
   125ad:	75 df                	jne    1258e <klog_vsprintf+0x125>
   125af:	89 dc                	mov    %ebx,%esp
   125b1:	e9 e2 00 00 00       	jmp    12698 <klog_vsprintf+0x22f>
                }
            }
            /* char类型 */
            else if (*fmt == 'c')
   125b6:	8b 45 0c             	mov    0xc(%ebp),%eax
   125b9:	0f b6 00             	movzbl (%eax),%eax
   125bc:	3c 63                	cmp    $0x63,%al
   125be:	75 1d                	jne    125dd <klog_vsprintf+0x174>
            {
                *ch++ = va_arg(args, int);
   125c0:	8b 45 10             	mov    0x10(%ebp),%eax
   125c3:	8d 50 04             	lea    0x4(%eax),%edx
   125c6:	89 55 10             	mov    %edx,0x10(%ebp)
   125c9:	8b 08                	mov    (%eax),%ecx
   125cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   125ce:	8d 50 01             	lea    0x1(%eax),%edx
   125d1:	89 55 f4             	mov    %edx,-0xc(%ebp)
   125d4:	89 ca                	mov    %ecx,%edx
   125d6:	88 10                	mov    %dl,(%eax)
   125d8:	e9 bb 00 00 00       	jmp    12698 <klog_vsprintf+0x22f>
            }
            /* str类型 */
            else if (*fmt == 's')
   125dd:	8b 45 0c             	mov    0xc(%ebp),%eax
   125e0:	0f b6 00             	movzbl (%eax),%eax
   125e3:	3c 73                	cmp    $0x73,%al
   125e5:	75 33                	jne    1261a <klog_vsprintf+0x1b1>
            {
                char *cbuf = va_arg(args, char *);
   125e7:	8b 45 10             	mov    0x10(%ebp),%eax
   125ea:	8d 50 04             	lea    0x4(%eax),%edx
   125ed:	89 55 10             	mov    %edx,0x10(%ebp)
   125f0:	8b 00                	mov    (%eax),%eax
   125f2:	89 45 e8             	mov    %eax,-0x18(%ebp)
                while (*cbuf != 0)
   125f5:	eb 17                	jmp    1260e <klog_vsprintf+0x1a5>
                {
                    *ch++ = *cbuf++;
   125f7:	8b 55 e8             	mov    -0x18(%ebp),%edx
   125fa:	8d 42 01             	lea    0x1(%edx),%eax
   125fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
   12600:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12603:	8d 48 01             	lea    0x1(%eax),%ecx
   12606:	89 4d f4             	mov    %ecx,-0xc(%ebp)
   12609:	0f b6 12             	movzbl (%edx),%edx
   1260c:	88 10                	mov    %dl,(%eax)
                while (*cbuf != 0)
   1260e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12611:	0f b6 00             	movzbl (%eax),%eax
   12614:	84 c0                	test   %al,%al
   12616:	75 df                	jne    125f7 <klog_vsprintf+0x18e>
   12618:	eb 7e                	jmp    12698 <klog_vsprintf+0x22f>
                }
            }
            else if (*fmt == 'x')
   1261a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1261d:	0f b6 00             	movzbl (%eax),%eax
   12620:	3c 78                	cmp    $0x78,%al
   12622:	75 74                	jne    12698 <klog_vsprintf+0x22f>
            {
                int num = va_arg(args, int);
   12624:	8b 45 10             	mov    0x10(%ebp),%eax
   12627:	8d 50 04             	lea    0x4(%eax),%edx
   1262a:	89 55 10             	mov    %edx,0x10(%ebp)
   1262d:	8b 00                	mov    (%eax),%eax
   1262f:	89 45 e0             	mov    %eax,-0x20(%ebp)
                char cbuf[50];
                char *ptr = cbuf;
   12632:	8d 45 9e             	lea    -0x62(%ebp),%eax
   12635:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                kmemset(cbuf, 0, sizeof(char) * 50);
   12638:	83 ec 04             	sub    $0x4,%esp
   1263b:	6a 32                	push   $0x32
   1263d:	6a 00                	push   $0x0
   1263f:	8d 45 9e             	lea    -0x62(%ebp),%eax
   12642:	50                   	push   %eax
   12643:	e8 2c fd ff ff       	call   12374 <kmemset>
   12648:	83 c4 10             	add    $0x10,%esp
                kdecimalToHexadecimal(cbuf, num);
   1264b:	83 ec 08             	sub    $0x8,%esp
   1264e:	ff 75 e0             	pushl  -0x20(%ebp)
   12651:	8d 45 9e             	lea    -0x62(%ebp),%eax
   12654:	50                   	push   %eax
   12655:	e8 c3 05 00 00       	call   12c1d <kdecimalToHexadecimal>
   1265a:	83 c4 10             	add    $0x10,%esp

                *ch++ = '0';
   1265d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12660:	8d 50 01             	lea    0x1(%eax),%edx
   12663:	89 55 f4             	mov    %edx,-0xc(%ebp)
   12666:	c6 00 30             	movb   $0x30,(%eax)
                *ch++ = 'x';
   12669:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1266c:	8d 50 01             	lea    0x1(%eax),%edx
   1266f:	89 55 f4             	mov    %edx,-0xc(%ebp)
   12672:	c6 00 78             	movb   $0x78,(%eax)

                while (*ptr != 0)
   12675:	eb 17                	jmp    1268e <klog_vsprintf+0x225>
                {
                    *ch++ = *ptr++;
   12677:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1267a:	8d 42 01             	lea    0x1(%edx),%eax
   1267d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   12680:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12683:	8d 48 01             	lea    0x1(%eax),%ecx
   12686:	89 4d f4             	mov    %ecx,-0xc(%ebp)
   12689:	0f b6 12             	movzbl (%edx),%edx
   1268c:	88 10                	mov    %dl,(%eax)
                while (*ptr != 0)
   1268e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12691:	0f b6 00             	movzbl (%eax),%eax
   12694:	84 c0                	test   %al,%al
   12696:	75 df                	jne    12677 <klog_vsprintf+0x20e>
                }
            }
            fmt++;
   12698:	83 45 0c 01          	addl   $0x1,0xc(%ebp)

            state = NORMAL;
   1269c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            break;
   126a3:	90                   	nop
    while (*fmt != 0)
   126a4:	8b 45 0c             	mov    0xc(%ebp),%eax
   126a7:	0f b6 00             	movzbl (%eax),%eax
   126aa:	84 c0                	test   %al,%al
   126ac:	0f 85 d0 fd ff ff    	jne    12482 <klog_vsprintf+0x19>
        }
    }
}
   126b2:	90                   	nop
   126b3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   126b6:	c9                   	leave  
   126b7:	c3                   	ret    

000126b8 <kitoa_s>:
 * @brief 将整数转换为字符串
 *
 * @param value
 */
char *kitoa_s(char *buf, int value, int size)
{
   126b8:	55                   	push   %ebp
   126b9:	89 e5                	mov    %esp,%ebp
   126bb:	83 ec 18             	sub    $0x18,%esp
    int i = 0;
   126be:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    char *p = buf;
   126c5:	8b 45 08             	mov    0x8(%ebp),%eax
   126c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    kmemset(buf, 0, sizeof(buf));
   126cb:	6a 04                	push   $0x4
   126cd:	6a 00                	push   $0x0
   126cf:	ff 75 08             	pushl  0x8(%ebp)
   126d2:	e8 9d fc ff ff       	call   12374 <kmemset>
   126d7:	83 c4 0c             	add    $0xc,%esp
    int num = value;
   126da:	8b 45 0c             	mov    0xc(%ebp),%eax
   126dd:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while (num)
   126e0:	eb 54                	jmp    12736 <kitoa_s+0x7e>
    {
        *p++ = '0' + (num % 10);
   126e2:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   126e5:	ba 67 66 66 66       	mov    $0x66666667,%edx
   126ea:	89 c8                	mov    %ecx,%eax
   126ec:	f7 ea                	imul   %edx
   126ee:	c1 fa 02             	sar    $0x2,%edx
   126f1:	89 c8                	mov    %ecx,%eax
   126f3:	c1 f8 1f             	sar    $0x1f,%eax
   126f6:	29 c2                	sub    %eax,%edx
   126f8:	89 d0                	mov    %edx,%eax
   126fa:	c1 e0 02             	shl    $0x2,%eax
   126fd:	01 d0                	add    %edx,%eax
   126ff:	01 c0                	add    %eax,%eax
   12701:	29 c1                	sub    %eax,%ecx
   12703:	89 ca                	mov    %ecx,%edx
   12705:	89 d0                	mov    %edx,%eax
   12707:	8d 48 30             	lea    0x30(%eax),%ecx
   1270a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1270d:	8d 50 01             	lea    0x1(%eax),%edx
   12710:	89 55 f0             	mov    %edx,-0x10(%ebp)
   12713:	89 ca                	mov    %ecx,%edx
   12715:	88 10                	mov    %dl,(%eax)
        num /= 10;
   12717:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   1271a:	ba 67 66 66 66       	mov    $0x66666667,%edx
   1271f:	89 c8                	mov    %ecx,%eax
   12721:	f7 ea                	imul   %edx
   12723:	c1 fa 02             	sar    $0x2,%edx
   12726:	89 c8                	mov    %ecx,%eax
   12728:	c1 f8 1f             	sar    $0x1f,%eax
   1272b:	29 c2                	sub    %eax,%edx
   1272d:	89 d0                	mov    %edx,%eax
   1272f:	89 45 ec             	mov    %eax,-0x14(%ebp)
        i++;
   12732:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    while (num)
   12736:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1273a:	75 a6                	jne    126e2 <kitoa_s+0x2a>
    }
    buf[i] = 0;
   1273c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1273f:	8b 45 08             	mov    0x8(%ebp),%eax
   12742:	01 d0                	add    %edx,%eax
   12744:	c6 00 00             	movb   $0x0,(%eax)
    kreverse_charstr(buf);
   12747:	83 ec 0c             	sub    $0xc,%esp
   1274a:	ff 75 08             	pushl  0x8(%ebp)
   1274d:	e8 69 00 00 00       	call   127bb <kreverse_charstr>
   12752:	83 c4 10             	add    $0x10,%esp
}
   12755:	90                   	nop
   12756:	c9                   	leave  
   12757:	c3                   	ret    

00012758 <kreverse_intstr>:
 *
 * @param buf
 * @return char*
 */
void kreverse_intstr(int *buf)
{
   12758:	55                   	push   %ebp
   12759:	89 e5                	mov    %esp,%ebp
   1275b:	83 ec 18             	sub    $0x18,%esp
    int l = 0, r = karr_strlen(buf) - 1;
   1275e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12765:	83 ec 0c             	sub    $0xc,%esp
   12768:	ff 75 08             	pushl  0x8(%ebp)
   1276b:	e8 c7 00 00 00       	call   12837 <karr_strlen>
   12770:	83 c4 10             	add    $0x10,%esp
   12773:	83 e8 01             	sub    $0x1,%eax
   12776:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while (l < r)
   12779:	eb 35                	jmp    127b0 <kreverse_intstr+0x58>
    {
        kswap(&buf[l], &buf[r], __INT_TYPE);
   1277b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1277e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12785:	8b 45 08             	mov    0x8(%ebp),%eax
   12788:	01 c2                	add    %eax,%edx
   1278a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1278d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   12794:	8b 45 08             	mov    0x8(%ebp),%eax
   12797:	01 c8                	add    %ecx,%eax
   12799:	83 ec 04             	sub    $0x4,%esp
   1279c:	6a 00                	push   $0x0
   1279e:	52                   	push   %edx
   1279f:	50                   	push   %eax
   127a0:	e8 03 01 00 00       	call   128a8 <kswap>
   127a5:	83 c4 10             	add    $0x10,%esp
        l++;
   127a8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        r--;
   127ac:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    while (l < r)
   127b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   127b3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   127b6:	7c c3                	jl     1277b <kreverse_intstr+0x23>
    }
}
   127b8:	90                   	nop
   127b9:	c9                   	leave  
   127ba:	c3                   	ret    

000127bb <kreverse_charstr>:
 *
 * @param buf
 * @return char*
 */
void kreverse_charstr(char *buf)
{
   127bb:	55                   	push   %ebp
   127bc:	89 e5                	mov    %esp,%ebp
   127be:	83 ec 18             	sub    $0x18,%esp
    int l = 0, r = kstrlen(buf) - 1;
   127c1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   127c8:	83 ec 0c             	sub    $0xc,%esp
   127cb:	ff 75 08             	pushl  0x8(%ebp)
   127ce:	e8 3d 00 00 00       	call   12810 <kstrlen>
   127d3:	83 c4 10             	add    $0x10,%esp
   127d6:	83 e8 01             	sub    $0x1,%eax
   127d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while (l < r)
   127dc:	eb 27                	jmp    12805 <kreverse_charstr+0x4a>
    {
        kswap(&buf[l], &buf[r], __CHAR_TYPE);
   127de:	8b 55 f0             	mov    -0x10(%ebp),%edx
   127e1:	8b 45 08             	mov    0x8(%ebp),%eax
   127e4:	01 c2                	add    %eax,%edx
   127e6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   127e9:	8b 45 08             	mov    0x8(%ebp),%eax
   127ec:	01 c8                	add    %ecx,%eax
   127ee:	83 ec 04             	sub    $0x4,%esp
   127f1:	6a 06                	push   $0x6
   127f3:	52                   	push   %edx
   127f4:	50                   	push   %eax
   127f5:	e8 ae 00 00 00       	call   128a8 <kswap>
   127fa:	83 c4 10             	add    $0x10,%esp
        l++;
   127fd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        r--;
   12801:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    while (l < r)
   12805:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12808:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1280b:	7c d1                	jl     127de <kreverse_charstr+0x23>
    }
}
   1280d:	90                   	nop
   1280e:	c9                   	leave  
   1280f:	c3                   	ret    

00012810 <kstrlen>:
 *
 * @param buf
 * @return int
 */
int kstrlen(char const *buf)
{
   12810:	55                   	push   %ebp
   12811:	89 e5                	mov    %esp,%ebp
   12813:	83 ec 10             	sub    $0x10,%esp
    int cnt = 0;
   12816:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    while (buf[cnt] != '\0')
   1281d:	eb 04                	jmp    12823 <kstrlen+0x13>
    {
        cnt++;
   1281f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while (buf[cnt] != '\0')
   12823:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12826:	8b 45 08             	mov    0x8(%ebp),%eax
   12829:	01 d0                	add    %edx,%eax
   1282b:	0f b6 00             	movzbl (%eax),%eax
   1282e:	84 c0                	test   %al,%al
   12830:	75 ed                	jne    1281f <kstrlen+0xf>
    }
    return cnt;
   12832:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12835:	c9                   	leave  
   12836:	c3                   	ret    

00012837 <karr_strlen>:
 *
 * @param buf
 * @return int
 */
int karr_strlen(int *buf)
{
   12837:	55                   	push   %ebp
   12838:	89 e5                	mov    %esp,%ebp
   1283a:	83 ec 10             	sub    $0x10,%esp
    int cnt = 0;
   1283d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    while (buf[cnt] != '\0')
   12844:	eb 04                	jmp    1284a <karr_strlen+0x13>
    {
        cnt++;
   12846:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while (buf[cnt] != '\0')
   1284a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1284d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12854:	8b 45 08             	mov    0x8(%ebp),%eax
   12857:	01 d0                	add    %edx,%eax
   12859:	8b 00                	mov    (%eax),%eax
   1285b:	85 c0                	test   %eax,%eax
   1285d:	75 e7                	jne    12846 <karr_strlen+0xf>
    }
    return cnt;
   1285f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12862:	c9                   	leave  
   12863:	c3                   	ret    

00012864 <kintlen>:
 * @brief 计算int类型的长度
 *
 * @return int
 */
int kintlen(int n)
{
   12864:	55                   	push   %ebp
   12865:	89 e5                	mov    %esp,%ebp
   12867:	83 ec 10             	sub    $0x10,%esp
    int i = 0;
   1286a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    if (n == 0)
   12871:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   12875:	75 26                	jne    1289d <kintlen+0x39>
    {
        return 1;
   12877:	b8 01 00 00 00       	mov    $0x1,%eax
   1287c:	eb 28                	jmp    128a6 <kintlen+0x42>
    }

    while (n)
    {
        n /= 10;
   1287e:	8b 4d 08             	mov    0x8(%ebp),%ecx
   12881:	ba 67 66 66 66       	mov    $0x66666667,%edx
   12886:	89 c8                	mov    %ecx,%eax
   12888:	f7 ea                	imul   %edx
   1288a:	c1 fa 02             	sar    $0x2,%edx
   1288d:	89 c8                	mov    %ecx,%eax
   1288f:	c1 f8 1f             	sar    $0x1f,%eax
   12892:	29 c2                	sub    %eax,%edx
   12894:	89 d0                	mov    %edx,%eax
   12896:	89 45 08             	mov    %eax,0x8(%ebp)
        i++;
   12899:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while (n)
   1289d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   128a1:	75 db                	jne    1287e <kintlen+0x1a>
    }
    return i;
   128a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   128a6:	c9                   	leave  
   128a7:	c3                   	ret    

000128a8 <kswap>:
 * @param a
 * @param b
 * @param type
 */
void kswap(void *a, void *b, DateType type)
{
   128a8:	55                   	push   %ebp
   128a9:	89 e5                	mov    %esp,%ebp
   128ab:	83 ec 68             	sub    $0x68,%esp
    switch (type)
   128ae:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
   128b2:	0f 87 4b 01 00 00    	ja     12a03 <kswap+0x15b>
   128b8:	8b 45 10             	mov    0x10(%ebp),%eax
   128bb:	c1 e0 02             	shl    $0x2,%eax
   128be:	05 90 33 01 00       	add    $0x13390,%eax
   128c3:	8b 00                	mov    (%eax),%eax
   128c5:	ff e0                	jmp    *%eax
    {
    case __INT_TYPE:
    {
        int *p = (int *)a;
   128c7:	8b 45 08             	mov    0x8(%ebp),%eax
   128ca:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        int *s = (int *)b;
   128cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   128d0:	89 45 a0             	mov    %eax,-0x60(%ebp)

        int temp = *p;
   128d3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
   128d6:	8b 00                	mov    (%eax),%eax
   128d8:	89 45 9c             	mov    %eax,-0x64(%ebp)
        *p = *s;
   128db:	8b 45 a0             	mov    -0x60(%ebp),%eax
   128de:	8b 10                	mov    (%eax),%edx
   128e0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
   128e3:	89 10                	mov    %edx,(%eax)
        *s = *p;
   128e5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
   128e8:	8b 10                	mov    (%eax),%edx
   128ea:	8b 45 a0             	mov    -0x60(%ebp),%eax
   128ed:	89 10                	mov    %edx,(%eax)
    }
    break;
   128ef:	e9 20 01 00 00       	jmp    12a14 <kswap+0x16c>
    case __UINT8_TYPE:
    {
        uint8_t *p = (uint8_t *)a;
   128f4:	8b 45 08             	mov    0x8(%ebp),%eax
   128f7:	89 45 b0             	mov    %eax,-0x50(%ebp)
        uint8_t *s = (uint8_t *)b;
   128fa:	8b 45 0c             	mov    0xc(%ebp),%eax
   128fd:	89 45 ac             	mov    %eax,-0x54(%ebp)

        uint8_t temp = *p;
   12900:	8b 45 b0             	mov    -0x50(%ebp),%eax
   12903:	0f b6 00             	movzbl (%eax),%eax
   12906:	88 45 ab             	mov    %al,-0x55(%ebp)
        *p = *s;
   12909:	8b 45 ac             	mov    -0x54(%ebp),%eax
   1290c:	0f b6 10             	movzbl (%eax),%edx
   1290f:	8b 45 b0             	mov    -0x50(%ebp),%eax
   12912:	88 10                	mov    %dl,(%eax)
        *s = *p;
   12914:	8b 45 b0             	mov    -0x50(%ebp),%eax
   12917:	0f b6 10             	movzbl (%eax),%edx
   1291a:	8b 45 ac             	mov    -0x54(%ebp),%eax
   1291d:	88 10                	mov    %dl,(%eax)
    }
    break;
   1291f:	e9 f0 00 00 00       	jmp    12a14 <kswap+0x16c>
    case __UINT16_TYPE:
    {
        uint16_t *p = (uint16_t *)a;
   12924:	8b 45 08             	mov    0x8(%ebp),%eax
   12927:	89 45 bc             	mov    %eax,-0x44(%ebp)
        uint16_t *s = (uint16_t *)b;
   1292a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1292d:	89 45 b8             	mov    %eax,-0x48(%ebp)

        uint16_t temp = *p;
   12930:	8b 45 bc             	mov    -0x44(%ebp),%eax
   12933:	0f b7 00             	movzwl (%eax),%eax
   12936:	66 89 45 b6          	mov    %ax,-0x4a(%ebp)
        *p = *s;
   1293a:	8b 45 b8             	mov    -0x48(%ebp),%eax
   1293d:	0f b7 10             	movzwl (%eax),%edx
   12940:	8b 45 bc             	mov    -0x44(%ebp),%eax
   12943:	66 89 10             	mov    %dx,(%eax)
        *s = *p;
   12946:	8b 45 bc             	mov    -0x44(%ebp),%eax
   12949:	0f b7 10             	movzwl (%eax),%edx
   1294c:	8b 45 b8             	mov    -0x48(%ebp),%eax
   1294f:	66 89 10             	mov    %dx,(%eax)
    }
    break;
   12952:	e9 bd 00 00 00       	jmp    12a14 <kswap+0x16c>
    case __UINT32_TYPE:
    {
        uint32_t *p = (uint32_t *)a;
   12957:	8b 45 08             	mov    0x8(%ebp),%eax
   1295a:	89 45 c8             	mov    %eax,-0x38(%ebp)
        uint32_t *s = (uint32_t *)b;
   1295d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12960:	89 45 c4             	mov    %eax,-0x3c(%ebp)

        uint32_t temp = *p;
   12963:	8b 45 c8             	mov    -0x38(%ebp),%eax
   12966:	8b 00                	mov    (%eax),%eax
   12968:	89 45 c0             	mov    %eax,-0x40(%ebp)
        *p = *s;
   1296b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1296e:	8b 10                	mov    (%eax),%edx
   12970:	8b 45 c8             	mov    -0x38(%ebp),%eax
   12973:	89 10                	mov    %edx,(%eax)
        *s = *p;
   12975:	8b 45 c8             	mov    -0x38(%ebp),%eax
   12978:	8b 10                	mov    (%eax),%edx
   1297a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1297d:	89 10                	mov    %edx,(%eax)
    }
    break;
   1297f:	e9 90 00 00 00       	jmp    12a14 <kswap+0x16c>
    case __FLOAT_TYPE:
    {
        float *p = (float *)a;
   12984:	8b 45 08             	mov    0x8(%ebp),%eax
   12987:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        float *s = (float *)b;
   1298a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1298d:	89 45 d0             	mov    %eax,-0x30(%ebp)

        float temp = *p;
   12990:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   12993:	d9 00                	flds   (%eax)
   12995:	d9 5d cc             	fstps  -0x34(%ebp)
        *p = *s;
   12998:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1299b:	d9 00                	flds   (%eax)
   1299d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   129a0:	d9 18                	fstps  (%eax)
        *s = *p;
   129a2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   129a5:	d9 00                	flds   (%eax)
   129a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
   129aa:	d9 18                	fstps  (%eax)
    }
    break;
   129ac:	eb 66                	jmp    12a14 <kswap+0x16c>
    case __DOUBLE_TYPE:
    {
        double *p = (double *)a;
   129ae:	8b 45 08             	mov    0x8(%ebp),%eax
   129b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
        double *s = (double *)b;
   129b4:	8b 45 0c             	mov    0xc(%ebp),%eax
   129b7:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        double temp = *p;
   129ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
   129bd:	dd 00                	fldl   (%eax)
   129bf:	dd 5d d8             	fstpl  -0x28(%ebp)
        *p = *s;
   129c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   129c5:	dd 00                	fldl   (%eax)
   129c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   129ca:	dd 18                	fstpl  (%eax)
        *s = *p;
   129cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   129cf:	dd 00                	fldl   (%eax)
   129d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   129d4:	dd 18                	fstpl  (%eax)
    }
    break;
   129d6:	eb 3c                	jmp    12a14 <kswap+0x16c>
    case __CHAR_TYPE:
    {
        char *p = (char *)a;
   129d8:	8b 45 08             	mov    0x8(%ebp),%eax
   129db:	89 45 f4             	mov    %eax,-0xc(%ebp)
        char *s = (char *)b;
   129de:	8b 45 0c             	mov    0xc(%ebp),%eax
   129e1:	89 45 f0             	mov    %eax,-0x10(%ebp)

        char temp = *p;
   129e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   129e7:	0f b6 00             	movzbl (%eax),%eax
   129ea:	88 45 ef             	mov    %al,-0x11(%ebp)
        *p = *s;
   129ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
   129f0:	0f b6 10             	movzbl (%eax),%edx
   129f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   129f6:	88 10                	mov    %dl,(%eax)
        *s = temp;
   129f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   129fb:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
   129ff:	88 10                	mov    %dl,(%eax)
    }
    break;
   12a01:	eb 11                	jmp    12a14 <kswap+0x16c>
    default:
        klog_printf("kswap erro: TYPE cannot found\n");
   12a03:	83 ec 0c             	sub    $0xc,%esp
   12a06:	68 70 33 01 00       	push   $0x13370
   12a0b:	e8 e2 f9 ff ff       	call   123f2 <klog_printf>
   12a10:	83 c4 10             	add    $0x10,%esp
        break;
   12a13:	90                   	nop
    }
}
   12a14:	90                   	nop
   12a15:	c9                   	leave  
   12a16:	c3                   	ret    

00012a17 <kstrcpy>:
 *
 * @param dest
 * @param src
 */
void kstrcpy(char *dest, char const *src)
{
   12a17:	55                   	push   %ebp
   12a18:	89 e5                	mov    %esp,%ebp
   12a1a:	83 ec 10             	sub    $0x10,%esp
    int len = kstrlen(src);
   12a1d:	ff 75 0c             	pushl  0xc(%ebp)
   12a20:	e8 eb fd ff ff       	call   12810 <kstrlen>
   12a25:	83 c4 04             	add    $0x4,%esp
   12a28:	89 45 f8             	mov    %eax,-0x8(%ebp)

    for (int i = 0; i < len; i++)
   12a2b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12a32:	eb 19                	jmp    12a4d <kstrcpy+0x36>
    {
        dest[i] = src[i];
   12a34:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12a37:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a3a:	01 d0                	add    %edx,%eax
   12a3c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   12a3f:	8b 55 08             	mov    0x8(%ebp),%edx
   12a42:	01 ca                	add    %ecx,%edx
   12a44:	0f b6 00             	movzbl (%eax),%eax
   12a47:	88 02                	mov    %al,(%edx)
    for (int i = 0; i < len; i++)
   12a49:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12a4d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12a50:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   12a53:	7c df                	jl     12a34 <kstrcpy+0x1d>
    }
   12a55:	90                   	nop
   12a56:	c9                   	leave  
   12a57:	c3                   	ret    

00012a58 <klist_init>:
 * @brief 初始化链表
 *
 * @param list
 */
void klist_init(kdouble_list_t *list)
{
   12a58:	55                   	push   %ebp
   12a59:	89 e5                	mov    %esp,%ebp
    list->head.prev = NULL;
   12a5b:	8b 45 08             	mov    0x8(%ebp),%eax
   12a5e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    list->head.next = &list->tail;
   12a64:	8b 45 08             	mov    0x8(%ebp),%eax
   12a67:	8d 50 08             	lea    0x8(%eax),%edx
   12a6a:	8b 45 08             	mov    0x8(%ebp),%eax
   12a6d:	89 50 04             	mov    %edx,0x4(%eax)
    list->tail.prev = &list->head;
   12a70:	8b 55 08             	mov    0x8(%ebp),%edx
   12a73:	8b 45 08             	mov    0x8(%ebp),%eax
   12a76:	89 50 08             	mov    %edx,0x8(%eax)
    list->tail.next = NULL;
   12a79:	8b 45 08             	mov    0x8(%ebp),%eax
   12a7c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    list->len = 0;
   12a83:	8b 45 08             	mov    0x8(%ebp),%eax
   12a86:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
}
   12a8d:	90                   	nop
   12a8e:	5d                   	pop    %ebp
   12a8f:	c3                   	ret    

00012a90 <klist_push>:
 *
 * @param list
 * @param node
 */
void klist_push(kdouble_list_t *list, klist_node_t *node)
{
   12a90:	55                   	push   %ebp
   12a91:	89 e5                	mov    %esp,%ebp
    node->prev = &list->head;
   12a93:	8b 55 08             	mov    0x8(%ebp),%edx
   12a96:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a99:	89 10                	mov    %edx,(%eax)
    node->next = list->head.next;
   12a9b:	8b 45 08             	mov    0x8(%ebp),%eax
   12a9e:	8b 50 04             	mov    0x4(%eax),%edx
   12aa1:	8b 45 0c             	mov    0xc(%ebp),%eax
   12aa4:	89 50 04             	mov    %edx,0x4(%eax)

    list->head.next->prev = node;
   12aa7:	8b 45 08             	mov    0x8(%ebp),%eax
   12aaa:	8b 40 04             	mov    0x4(%eax),%eax
   12aad:	8b 55 0c             	mov    0xc(%ebp),%edx
   12ab0:	89 10                	mov    %edx,(%eax)
    list->head.next = node;
   12ab2:	8b 45 08             	mov    0x8(%ebp),%eax
   12ab5:	8b 55 0c             	mov    0xc(%ebp),%edx
   12ab8:	89 50 04             	mov    %edx,0x4(%eax)

    list->len++;
   12abb:	8b 45 08             	mov    0x8(%ebp),%eax
   12abe:	8b 40 10             	mov    0x10(%eax),%eax
   12ac1:	8d 50 01             	lea    0x1(%eax),%edx
   12ac4:	8b 45 08             	mov    0x8(%ebp),%eax
   12ac7:	89 50 10             	mov    %edx,0x10(%eax)
}
   12aca:	90                   	nop
   12acb:	5d                   	pop    %ebp
   12acc:	c3                   	ret    

00012acd <klist_append>:
 *
 * @param list
 * @param node
 */
void klist_append(kdouble_list_t *list, klist_node_t *node)
{
   12acd:	55                   	push   %ebp
   12ace:	89 e5                	mov    %esp,%ebp
    node->next = &list->tail;
   12ad0:	8b 45 08             	mov    0x8(%ebp),%eax
   12ad3:	8d 50 08             	lea    0x8(%eax),%edx
   12ad6:	8b 45 0c             	mov    0xc(%ebp),%eax
   12ad9:	89 50 04             	mov    %edx,0x4(%eax)
    node->prev = list->tail.prev;
   12adc:	8b 45 08             	mov    0x8(%ebp),%eax
   12adf:	8b 50 08             	mov    0x8(%eax),%edx
   12ae2:	8b 45 0c             	mov    0xc(%ebp),%eax
   12ae5:	89 10                	mov    %edx,(%eax)

    list->tail.prev->next = node;
   12ae7:	8b 45 08             	mov    0x8(%ebp),%eax
   12aea:	8b 40 08             	mov    0x8(%eax),%eax
   12aed:	8b 55 0c             	mov    0xc(%ebp),%edx
   12af0:	89 50 04             	mov    %edx,0x4(%eax)
    list->tail.prev = node;
   12af3:	8b 45 08             	mov    0x8(%ebp),%eax
   12af6:	8b 55 0c             	mov    0xc(%ebp),%edx
   12af9:	89 50 08             	mov    %edx,0x8(%eax)

    list->len++;
   12afc:	8b 45 08             	mov    0x8(%ebp),%eax
   12aff:	8b 40 10             	mov    0x10(%eax),%eax
   12b02:	8d 50 01             	lea    0x1(%eax),%edx
   12b05:	8b 45 08             	mov    0x8(%ebp),%eax
   12b08:	89 50 10             	mov    %edx,0x10(%eax)
}
   12b0b:	90                   	nop
   12b0c:	5d                   	pop    %ebp
   12b0d:	c3                   	ret    

00012b0e <klist_pop>:
 * @brief 将链表的head后的第一个元素pop出去
 *
 * @param list
 */
klist_node_t *klist_pop(kdouble_list_t *list)
{
   12b0e:	55                   	push   %ebp
   12b0f:	89 e5                	mov    %esp,%ebp
   12b11:	83 ec 10             	sub    $0x10,%esp
    klist_node_t *node = list->head.next;
   12b14:	8b 45 08             	mov    0x8(%ebp),%eax
   12b17:	8b 40 04             	mov    0x4(%eax),%eax
   12b1a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    list->head.next->next->prev = &list->head;
   12b1d:	8b 45 08             	mov    0x8(%ebp),%eax
   12b20:	8b 40 04             	mov    0x4(%eax),%eax
   12b23:	8b 40 04             	mov    0x4(%eax),%eax
   12b26:	8b 55 08             	mov    0x8(%ebp),%edx
   12b29:	89 10                	mov    %edx,(%eax)
    list->head.next = list->head.next->next;
   12b2b:	8b 45 08             	mov    0x8(%ebp),%eax
   12b2e:	8b 40 04             	mov    0x4(%eax),%eax
   12b31:	8b 50 04             	mov    0x4(%eax),%edx
   12b34:	8b 45 08             	mov    0x8(%ebp),%eax
   12b37:	89 50 04             	mov    %edx,0x4(%eax)

    list->len--;
   12b3a:	8b 45 08             	mov    0x8(%ebp),%eax
   12b3d:	8b 40 10             	mov    0x10(%eax),%eax
   12b40:	8d 50 ff             	lea    -0x1(%eax),%edx
   12b43:	8b 45 08             	mov    0x8(%ebp),%eax
   12b46:	89 50 10             	mov    %edx,0x10(%eax)

    return node;
   12b49:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12b4c:	c9                   	leave  
   12b4d:	c3                   	ret    

00012b4e <klist_remove>:
 * @param list
 * @param remove_node
 * @return klist_node_t*
 */
klist_node_t *klist_remove(kdouble_list_t *list, klist_node_t *remove_node)
{
   12b4e:	55                   	push   %ebp
   12b4f:	89 e5                	mov    %esp,%ebp
   12b51:	83 ec 10             	sub    $0x10,%esp
    klist_node_t *temp = list->head.next;
   12b54:	8b 45 08             	mov    0x8(%ebp),%eax
   12b57:	8b 40 04             	mov    0x4(%eax),%eax
   12b5a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (temp)
   12b5d:	eb 44                	jmp    12ba3 <klist_remove+0x55>
    {
        /* 找到了 */
        if (temp == remove_node)
   12b5f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12b62:	3b 45 0c             	cmp    0xc(%ebp),%eax
   12b65:	75 33                	jne    12b9a <klist_remove+0x4c>
        {
            klist_node_t *pre = temp->prev;
   12b67:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12b6a:	8b 00                	mov    (%eax),%eax
   12b6c:	89 45 f8             	mov    %eax,-0x8(%ebp)
            pre->next = temp->next;
   12b6f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12b72:	8b 50 04             	mov    0x4(%eax),%edx
   12b75:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12b78:	89 50 04             	mov    %edx,0x4(%eax)
            temp->next->prev = pre;
   12b7b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12b7e:	8b 40 04             	mov    0x4(%eax),%eax
   12b81:	8b 55 f8             	mov    -0x8(%ebp),%edx
   12b84:	89 10                	mov    %edx,(%eax)
            list->len--;
   12b86:	8b 45 08             	mov    0x8(%ebp),%eax
   12b89:	8b 40 10             	mov    0x10(%eax),%eax
   12b8c:	8d 50 ff             	lea    -0x1(%eax),%edx
   12b8f:	8b 45 08             	mov    0x8(%ebp),%eax
   12b92:	89 50 10             	mov    %edx,0x10(%eax)
            return remove_node;
   12b95:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b98:	eb 14                	jmp    12bae <klist_remove+0x60>
        }
        temp = temp->next;
   12b9a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12b9d:	8b 40 04             	mov    0x4(%eax),%eax
   12ba0:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (temp)
   12ba3:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   12ba7:	75 b6                	jne    12b5f <klist_remove+0x11>
    }
    return NULL;
   12ba9:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12bae:	c9                   	leave  
   12baf:	c3                   	ret    

00012bb0 <klist_len>:
 *
 * @param list
 * @return int
 */
int klist_len(kdouble_list_t *list)
{
   12bb0:	55                   	push   %ebp
   12bb1:	89 e5                	mov    %esp,%ebp
    return list->len;
   12bb3:	8b 45 08             	mov    0x8(%ebp),%eax
   12bb6:	8b 40 10             	mov    0x10(%eax),%eax
}
   12bb9:	5d                   	pop    %ebp
   12bba:	c3                   	ret    

00012bbb <klist_get_first_node>:
 *
 * @param list
 * @return klist_node_t*
 */
klist_node_t *klist_get_first_node(kdouble_list_t *list)
{
   12bbb:	55                   	push   %ebp
   12bbc:	89 e5                	mov    %esp,%ebp
    return list->head.next;
   12bbe:	8b 45 08             	mov    0x8(%ebp),%eax
   12bc1:	8b 40 04             	mov    0x4(%eax),%eax
}
   12bc4:	5d                   	pop    %ebp
   12bc5:	c3                   	ret    

00012bc6 <klist_get_last_node>:
 *
 * @param list
 * @return klist_node_t*
 */
klist_node_t *klist_get_last_node(kdouble_list_t *list)
{
   12bc6:	55                   	push   %ebp
   12bc7:	89 e5                	mov    %esp,%ebp
    return list->tail.prev;
   12bc9:	8b 45 08             	mov    0x8(%ebp),%eax
   12bcc:	8b 40 08             	mov    0x8(%eax),%eax
}
   12bcf:	5d                   	pop    %ebp
   12bd0:	c3                   	ret    

00012bd1 <klist_find>:
 * @param list
 * @param remove_node
 * @return klist_node_t*
 */
klist_node_t *klist_find(kdouble_list_t *list, klist_node_t *target_node)
{
   12bd1:	55                   	push   %ebp
   12bd2:	89 e5                	mov    %esp,%ebp
   12bd4:	83 ec 10             	sub    $0x10,%esp
    klist_node_t *temp = list->head.next;
   12bd7:	8b 45 08             	mov    0x8(%ebp),%eax
   12bda:	8b 40 04             	mov    0x4(%eax),%eax
   12bdd:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (temp)
   12be0:	eb 16                	jmp    12bf8 <klist_find+0x27>
    {
        if (temp == target_node)
   12be2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12be5:	3b 45 0c             	cmp    0xc(%ebp),%eax
   12be8:	75 05                	jne    12bef <klist_find+0x1e>
        {
            return temp;
   12bea:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12bed:	eb 14                	jmp    12c03 <klist_find+0x32>
        }
        temp = temp->next;
   12bef:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12bf2:	8b 40 04             	mov    0x4(%eax),%eax
   12bf5:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (temp)
   12bf8:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   12bfc:	75 e4                	jne    12be2 <klist_find+0x11>
    }
    return NULL;
   12bfe:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12c03:	c9                   	leave  
   12c04:	c3                   	ret    

00012c05 <klist_empty>:
 * @param list
 * @return true
 * @return false
 */
bool klist_empty(kdouble_list_t *list)
{
   12c05:	55                   	push   %ebp
   12c06:	89 e5                	mov    %esp,%ebp
    return klist_len(list) == 0;
   12c08:	ff 75 08             	pushl  0x8(%ebp)
   12c0b:	e8 a0 ff ff ff       	call   12bb0 <klist_len>
   12c10:	83 c4 04             	add    $0x4,%esp
   12c13:	85 c0                	test   %eax,%eax
   12c15:	0f 94 c0             	sete   %al
   12c18:	0f b6 c0             	movzbl %al,%eax
   12c1b:	c9                   	leave  
   12c1c:	c3                   	ret    

00012c1d <kdecimalToHexadecimal>:
#include "kmath.h"
#include "klib.h"

void kdecimalToHexadecimal(char *hexadecimalNum, int decimalNum)
{
   12c1d:	55                   	push   %ebp
   12c1e:	89 e5                	mov    %esp,%ebp
   12c20:	83 ec 18             	sub    $0x18,%esp
    int i = 0;
   12c23:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    if (decimalNum == 0)
   12c2a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   12c2e:	75 63                	jne    12c93 <kdecimalToHexadecimal+0x76>
    {
        hexadecimalNum[0] = '0';
   12c30:	8b 45 08             	mov    0x8(%ebp),%eax
   12c33:	c6 00 30             	movb   $0x30,(%eax)
        hexadecimalNum[1] = '\0';
   12c36:	8b 45 08             	mov    0x8(%ebp),%eax
   12c39:	83 c0 01             	add    $0x1,%eax
   12c3c:	c6 00 00             	movb   $0x0,(%eax)
        return;
   12c3f:	eb 71                	jmp    12cb2 <kdecimalToHexadecimal+0x95>
    }

    while (decimalNum > 0)
    {
        int remainder = decimalNum % 16;
   12c41:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c44:	99                   	cltd   
   12c45:	c1 ea 1c             	shr    $0x1c,%edx
   12c48:	01 d0                	add    %edx,%eax
   12c4a:	83 e0 0f             	and    $0xf,%eax
   12c4d:	29 d0                	sub    %edx,%eax
   12c4f:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (remainder < 10)
   12c52:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
   12c56:	7f 14                	jg     12c6c <kdecimalToHexadecimal+0x4f>
            hexadecimalNum[i] = remainder + '0'; // Convert to ASCII character 0-9
   12c58:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12c5b:	8d 48 30             	lea    0x30(%eax),%ecx
   12c5e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12c61:	8b 45 08             	mov    0x8(%ebp),%eax
   12c64:	01 d0                	add    %edx,%eax
   12c66:	89 ca                	mov    %ecx,%edx
   12c68:	88 10                	mov    %dl,(%eax)
   12c6a:	eb 12                	jmp    12c7e <kdecimalToHexadecimal+0x61>
        else
            hexadecimalNum[i] = remainder + 55; // Convert to ASCII character A-F
   12c6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12c6f:	8d 48 37             	lea    0x37(%eax),%ecx
   12c72:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12c75:	8b 45 08             	mov    0x8(%ebp),%eax
   12c78:	01 d0                	add    %edx,%eax
   12c7a:	89 ca                	mov    %ecx,%edx
   12c7c:	88 10                	mov    %dl,(%eax)

        i++;
   12c7e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        decimalNum /= 16;
   12c82:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c85:	8d 50 0f             	lea    0xf(%eax),%edx
   12c88:	85 c0                	test   %eax,%eax
   12c8a:	0f 48 c2             	cmovs  %edx,%eax
   12c8d:	c1 f8 04             	sar    $0x4,%eax
   12c90:	89 45 0c             	mov    %eax,0xc(%ebp)
    while (decimalNum > 0)
   12c93:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   12c97:	7f a8                	jg     12c41 <kdecimalToHexadecimal+0x24>
    }
    hexadecimalNum[i] = 0;
   12c99:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12c9c:	8b 45 08             	mov    0x8(%ebp),%eax
   12c9f:	01 d0                	add    %edx,%eax
   12ca1:	c6 00 00             	movb   $0x0,(%eax)
    /* 倒置顺序 */
    kreverse_charstr(hexadecimalNum);
   12ca4:	83 ec 0c             	sub    $0xc,%esp
   12ca7:	ff 75 08             	pushl  0x8(%ebp)
   12caa:	e8 0c fb ff ff       	call   127bb <kreverse_charstr>
   12caf:	83 c4 10             	add    $0x10,%esp
   12cb2:	c9                   	leave  
   12cb3:	c3                   	ret    

00012cb4 <inb>:
{
   12cb4:	55                   	push   %ebp
   12cb5:	89 e5                	mov    %esp,%ebp
   12cb7:	83 ec 14             	sub    $0x14,%esp
   12cba:	8b 45 08             	mov    0x8(%ebp),%eax
   12cbd:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[port], %[rv]"
   12cc1:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   12cc5:	89 c2                	mov    %eax,%edx
   12cc7:	ec                   	in     (%dx),%al
   12cc8:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   12ccb:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   12ccf:	c9                   	leave  
   12cd0:	c3                   	ret    

00012cd1 <outb>:
{
   12cd1:	55                   	push   %ebp
   12cd2:	89 e5                	mov    %esp,%ebp
   12cd4:	83 ec 08             	sub    $0x8,%esp
   12cd7:	8b 55 08             	mov    0x8(%ebp),%edx
   12cda:	8b 45 0c             	mov    0xc(%ebp),%eax
   12cdd:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   12ce1:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[data], %[port]"
   12ce4:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   12ce8:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12cec:	ee                   	out    %al,(%dx)
}
   12ced:	90                   	nop
   12cee:	c9                   	leave  
   12cef:	c3                   	ret    

00012cf0 <log_init>:
/**
 * @brief 初始化串口
 *
 */
void log_init()
{
   12cf0:	55                   	push   %ebp
   12cf1:	89 e5                	mov    %esp,%ebp
    outb(PORT_COM1 + 1, 0x00); // Disable all interrupts
   12cf3:	6a 00                	push   $0x0
   12cf5:	68 f9 03 00 00       	push   $0x3f9
   12cfa:	e8 d2 ff ff ff       	call   12cd1 <outb>
   12cff:	83 c4 08             	add    $0x8,%esp
    outb(PORT_COM1 + 3, 0x80); // Enable DLAB (set baud rate divisor)
   12d02:	68 80 00 00 00       	push   $0x80
   12d07:	68 fb 03 00 00       	push   $0x3fb
   12d0c:	e8 c0 ff ff ff       	call   12cd1 <outb>
   12d11:	83 c4 08             	add    $0x8,%esp
    outb(PORT_COM1 + 0, 0x03); // Set divisor to 3 (lo byte) 38400 baud
   12d14:	6a 03                	push   $0x3
   12d16:	68 f8 03 00 00       	push   $0x3f8
   12d1b:	e8 b1 ff ff ff       	call   12cd1 <outb>
   12d20:	83 c4 08             	add    $0x8,%esp
    outb(PORT_COM1 + 1, 0x00); //                  (hi byte)
   12d23:	6a 00                	push   $0x0
   12d25:	68 f9 03 00 00       	push   $0x3f9
   12d2a:	e8 a2 ff ff ff       	call   12cd1 <outb>
   12d2f:	83 c4 08             	add    $0x8,%esp
    outb(PORT_COM1 + 3, 0x03); // 8 bits, no parity, one stop bit
   12d32:	6a 03                	push   $0x3
   12d34:	68 fb 03 00 00       	push   $0x3fb
   12d39:	e8 93 ff ff ff       	call   12cd1 <outb>
   12d3e:	83 c4 08             	add    $0x8,%esp
    outb(PORT_COM1 + 2, 0xC7); // Enable FIFO, clear them, with 14-byte threshold
   12d41:	68 c7 00 00 00       	push   $0xc7
   12d46:	68 fa 03 00 00       	push   $0x3fa
   12d4b:	e8 81 ff ff ff       	call   12cd1 <outb>
   12d50:	83 c4 08             	add    $0x8,%esp
    outb(PORT_COM1 + 4, 0x0B); // IRQs enabled, RTS/DSR set
   12d53:	6a 0b                	push   $0xb
   12d55:	68 fc 03 00 00       	push   $0x3fc
   12d5a:	e8 72 ff ff ff       	call   12cd1 <outb>
   12d5f:	83 c4 08             	add    $0x8,%esp
    // }

    // // If serial is not faulty set it in normal operation mode
    // // (not-loopback with IRQs enabled and OUT#1 and OUT#2 bits enabled)
    // outb(PORT_COM1 + 4, 0x0F);
    return;
   12d62:	90                   	nop
}
   12d63:	c9                   	leave  
   12d64:	c3                   	ret    

00012d65 <is_transmit_empty>:
 * @brief 判断是否为空
 *
 * @return int
 */
bool is_transmit_empty()
{
   12d65:	55                   	push   %ebp
   12d66:	89 e5                	mov    %esp,%ebp
    return inb(PORT_COM1 + 5) & 0x20;
   12d68:	68 fd 03 00 00       	push   $0x3fd
   12d6d:	e8 42 ff ff ff       	call   12cb4 <inb>
   12d72:	83 c4 04             	add    $0x4,%esp
   12d75:	0f b6 c0             	movzbl %al,%eax
   12d78:	83 e0 20             	and    $0x20,%eax
}
   12d7b:	c9                   	leave  
   12d7c:	c3                   	ret    

00012d7d <write_serial>:
 * @brief 实现写串口的操作
 *
 * @param a
 */
void write_serial(char a)
{
   12d7d:	55                   	push   %ebp
   12d7e:	89 e5                	mov    %esp,%ebp
   12d80:	83 ec 04             	sub    $0x4,%esp
   12d83:	8b 45 08             	mov    0x8(%ebp),%eax
   12d86:	88 45 fc             	mov    %al,-0x4(%ebp)
    while (is_transmit_empty() == false)
   12d89:	90                   	nop
   12d8a:	e8 d6 ff ff ff       	call   12d65 <is_transmit_empty>
   12d8f:	85 c0                	test   %eax,%eax
   12d91:	74 f7                	je     12d8a <write_serial+0xd>
        ;

    outb(PORT_COM1, a);
   12d93:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
   12d97:	0f b6 c0             	movzbl %al,%eax
   12d9a:	50                   	push   %eax
   12d9b:	68 f8 03 00 00       	push   $0x3f8
   12da0:	e8 2c ff ff ff       	call   12cd1 <outb>
   12da5:	83 c4 08             	add    $0x8,%esp
}
   12da8:	90                   	nop
   12da9:	c9                   	leave  
   12daa:	c3                   	ret    

00012dab <write_serial_end>:

void write_serial_end()
{
   12dab:	55                   	push   %ebp
   12dac:	89 e5                	mov    %esp,%ebp
    outb(PORT_COM1, '\r');
   12dae:	6a 0d                	push   $0xd
   12db0:	68 f8 03 00 00       	push   $0x3f8
   12db5:	e8 17 ff ff ff       	call   12cd1 <outb>
   12dba:	83 c4 08             	add    $0x8,%esp
    outb(PORT_COM1, '\n');
   12dbd:	6a 0a                	push   $0xa
   12dbf:	68 f8 03 00 00       	push   $0x3f8
   12dc4:	e8 08 ff ff ff       	call   12cd1 <outb>
   12dc9:	83 c4 08             	add    $0x8,%esp
   12dcc:	90                   	nop
   12dcd:	c9                   	leave  
   12dce:	c3                   	ret    

00012dcf <ltr>:
{
   12dcf:	55                   	push   %ebp
   12dd0:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("ltr %%ax" ::"a"(tss_sel));
   12dd2:	8b 45 08             	mov    0x8(%ebp),%eax
   12dd5:	0f 00 d8             	ltr    %ax
}
   12dd8:	90                   	nop
   12dd9:	5d                   	pop    %ebp
   12dda:	c3                   	ret    

00012ddb <far_jmp>:

static inline void far_jmp(uint32_t selc, uint32_t offset)
{
   12ddb:	55                   	push   %ebp
   12ddc:	89 e5                	mov    %esp,%ebp
   12dde:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[] = {offset, selc};
   12de1:	8b 45 0c             	mov    0xc(%ebp),%eax
   12de4:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12de7:	8b 45 08             	mov    0x8(%ebp),%eax
   12dea:	89 45 fc             	mov    %eax,-0x4(%ebp)
    __asm__ __volatile__("ljmpl *(%[addr])" ::[addr] "r"(addr));
   12ded:	8d 45 f8             	lea    -0x8(%ebp),%eax
   12df0:	ff 28                	ljmp   *(%eax)
}
   12df2:	90                   	nop
   12df3:	c9                   	leave  
   12df4:	c3                   	ret    

00012df5 <tss_task_init>:
extern gdt_entry_t gdt_table[GDT_SIZE];
extern task_manage_t task_manager;
pde_t kernel_table[NPDE] __attribute__((aligned(MEM_PAGE_SIZE)));

void tss_task_init()
{
   12df5:	55                   	push   %ebp
   12df6:	89 e5                	mov    %esp,%ebp
   12df8:	83 ec 18             	sub    $0x18,%esp
    klist_init(&task_manager.ready_list);
   12dfb:	83 ec 0c             	sub    $0xc,%esp
   12dfe:	68 38 80 01 00       	push   $0x18038
   12e03:	e8 50 fc ff ff       	call   12a58 <klist_init>
   12e08:	83 c4 10             	add    $0x10,%esp
    klist_init(&task_manager.sleep_list);
   12e0b:	83 ec 0c             	sub    $0xc,%esp
   12e0e:	68 4c 80 01 00       	push   $0x1804c
   12e13:	e8 40 fc ff ff       	call   12a58 <klist_init>
   12e18:	83 c4 10             	add    $0x10,%esp
    klist_init(&task_manager.general_list);
   12e1b:	83 ec 0c             	sub    $0xc,%esp
   12e1e:	68 24 80 01 00       	push   $0x18024
   12e23:	e8 30 fc ff ff       	call   12a58 <klist_init>
   12e28:	83 c4 10             	add    $0x10,%esp

    irq_status status = irq_enter_protection();
   12e2b:	e8 18 dd ff ff       	call   10b48 <irq_enter_protection>
   12e30:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t *task = (task_t *)kalloc_pages(1);
   12e33:	83 ec 0c             	sub    $0xc,%esp
   12e36:	6a 01                	push   $0x1
   12e38:	e8 c5 df ff ff       	call   10e02 <kalloc_pages>
   12e3d:	83 c4 10             	add    $0x10,%esp
   12e40:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ASSERT(task != NULL);
    task->ticks = task->default_ticks = TASK_TICKS_DEFAULT;
   12e43:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12e46:	c7 80 90 00 00 00 05 	movl   $0x5,0x90(%eax)
   12e4d:	00 00 00 
   12e50:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12e53:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
   12e59:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12e5c:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
    task->pid = alloc_pid();
   12e62:	e8 95 f4 ff ff       	call   122fc <alloc_pid>
   12e67:	89 c2                	mov    %eax,%edx
   12e69:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12e6c:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
    task_manager.cur_task = task;
   12e72:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12e75:	a3 20 80 01 00       	mov    %eax,0x18020
    task->ifkernel = KERNEL_PROC;
   12e7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12e7d:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%eax)
    task->parent = NULL;
   12e84:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12e87:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)

    task_set_general(task);
   12e8e:	83 ec 0c             	sub    $0xc,%esp
   12e91:	ff 75 f0             	pushl  -0x10(%ebp)
   12e94:	e8 61 03 00 00       	call   131fa <task_set_general>
   12e99:	83 c4 10             	add    $0x10,%esp
    task_set_ready(task);
   12e9c:	83 ec 0c             	sub    $0xc,%esp
   12e9f:	ff 75 f0             	pushl  -0x10(%ebp)
   12ea2:	e8 73 03 00 00       	call   1321a <task_set_ready>
   12ea7:	83 c4 10             	add    $0x10,%esp
    task->status = TASK_RUNNING;
   12eaa:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12ead:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    init_tss(task, 0, task->ifkernel);
   12eb3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12eb6:	8b 40 70             	mov    0x70(%eax),%eax
   12eb9:	83 ec 04             	sub    $0x4,%esp
   12ebc:	50                   	push   %eax
   12ebd:	6a 00                	push   $0x0
   12ebf:	ff 75 f0             	pushl  -0x10(%ebp)
   12ec2:	e8 26 00 00 00       	call   12eed <init_tss>
   12ec7:	83 c4 10             	add    $0x10,%esp
    ltr(task->tss_sel);
   12eca:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12ecd:	8b 40 6c             	mov    0x6c(%eax),%eax
   12ed0:	83 ec 0c             	sub    $0xc,%esp
   12ed3:	50                   	push   %eax
   12ed4:	e8 f6 fe ff ff       	call   12dcf <ltr>
   12ed9:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(status);
   12edc:	83 ec 0c             	sub    $0xc,%esp
   12edf:	ff 75 f4             	pushl  -0xc(%ebp)
   12ee2:	e8 74 dc ff ff       	call   10b5b <irq_leave_protection>
   12ee7:	83 c4 10             	add    $0x10,%esp
}
   12eea:	90                   	nop
   12eeb:	c9                   	leave  
   12eec:	c3                   	ret    

00012eed <init_tss>:

int init_tss(task_t *task, uint32_t entry, int ifkernel)
{
   12eed:	55                   	push   %ebp
   12eee:	89 e5                	mov    %esp,%ebp
   12ef0:	83 ec 18             	sub    $0x18,%esp
    /* 获取空闲项 */
    int tss_sel = gdt_alloc_seg();
   12ef3:	e8 47 d5 ff ff       	call   1043f <gdt_alloc_seg>
   12ef8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ASSERT(tss_sel > 0);

    /* 设置选择子 */
    gdt_segment_set(tss_sel, sizeof(tss_t), (uint32_t)&task->tss,
   12efb:	8b 45 08             	mov    0x8(%ebp),%eax
   12efe:	83 c0 04             	add    $0x4,%eax
   12f01:	89 c2                	mov    %eax,%edx
   12f03:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12f06:	0f b7 c0             	movzwl %ax,%eax
   12f09:	68 89 00 00 00       	push   $0x89
   12f0e:	52                   	push   %edx
   12f0f:	6a 68                	push   $0x68
   12f11:	50                   	push   %eax
   12f12:	e8 74 d5 ff ff       	call   1048b <gdt_segment_set>
   12f17:	83 c4 10             	add    $0x10,%esp
                    SEG_S_SYSTEM | SEG_TYPE_TSS | SEG_DPL0 | SEG_P_PRESENT);

    kmemset(&task->tss, 0, sizeof(tss_t));
   12f1a:	8b 45 08             	mov    0x8(%ebp),%eax
   12f1d:	83 c0 04             	add    $0x4,%eax
   12f20:	83 ec 04             	sub    $0x4,%esp
   12f23:	6a 68                	push   $0x68
   12f25:	6a 00                	push   $0x0
   12f27:	50                   	push   %eax
   12f28:	e8 47 f4 ff ff       	call   12374 <kmemset>
   12f2d:	83 c4 10             	add    $0x10,%esp

    uint32_t kernel_stack = kalloc_pages(1);
   12f30:	83 ec 0c             	sub    $0xc,%esp
   12f33:	6a 01                	push   $0x1
   12f35:	e8 c8 de ff ff       	call   10e02 <kalloc_pages>
   12f3a:	83 c4 10             	add    $0x10,%esp
   12f3d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    task->tss.eip = (void *)entry;
   12f40:	8b 55 0c             	mov    0xc(%ebp),%edx
   12f43:	8b 45 08             	mov    0x8(%ebp),%eax
   12f46:	89 50 24             	mov    %edx,0x24(%eax)
    task->tss.esp0 = (uint32_t *)kernel_stack;
   12f49:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12f4c:	8b 45 08             	mov    0x8(%ebp),%eax
   12f4f:	89 50 08             	mov    %edx,0x8(%eax)
    task->tss.ss0 = KERNEL_SELECTOR_DS;
   12f52:	8b 45 08             	mov    0x8(%ebp),%eax
   12f55:	c7 40 0c 10 00 00 00 	movl   $0x10,0xc(%eax)
    if (ifkernel == KERNEL_PROC)
   12f5c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   12f60:	75 66                	jne    12fc8 <init_tss+0xdb>
    {
        task->tss.esp = (uint32_t *)kalloc_pages(1);
   12f62:	83 ec 0c             	sub    $0xc,%esp
   12f65:	6a 01                	push   $0x1
   12f67:	e8 96 de ff ff       	call   10e02 <kalloc_pages>
   12f6c:	83 c4 10             	add    $0x10,%esp
   12f6f:	89 c2                	mov    %eax,%edx
   12f71:	8b 45 08             	mov    0x8(%ebp),%eax
   12f74:	89 50 3c             	mov    %edx,0x3c(%eax)
        task->tss.ss = task->tss.es = task->tss.ds = task->tss.fs = task->tss.gs = KERNEL_SELECTOR_DS;
   12f77:	8b 45 08             	mov    0x8(%ebp),%eax
   12f7a:	c7 40 60 10 00 00 00 	movl   $0x10,0x60(%eax)
   12f81:	8b 45 08             	mov    0x8(%ebp),%eax
   12f84:	8b 50 60             	mov    0x60(%eax),%edx
   12f87:	8b 45 08             	mov    0x8(%ebp),%eax
   12f8a:	89 50 5c             	mov    %edx,0x5c(%eax)
   12f8d:	8b 45 08             	mov    0x8(%ebp),%eax
   12f90:	8b 50 5c             	mov    0x5c(%eax),%edx
   12f93:	8b 45 08             	mov    0x8(%ebp),%eax
   12f96:	89 50 58             	mov    %edx,0x58(%eax)
   12f99:	8b 45 08             	mov    0x8(%ebp),%eax
   12f9c:	8b 50 58             	mov    0x58(%eax),%edx
   12f9f:	8b 45 08             	mov    0x8(%ebp),%eax
   12fa2:	89 50 4c             	mov    %edx,0x4c(%eax)
   12fa5:	8b 45 08             	mov    0x8(%ebp),%eax
   12fa8:	8b 50 4c             	mov    0x4c(%eax),%edx
   12fab:	8b 45 08             	mov    0x8(%ebp),%eax
   12fae:	89 50 54             	mov    %edx,0x54(%eax)
        task->tss.cs = KERNEL_SELECTOR_CS;
   12fb1:	8b 45 08             	mov    0x8(%ebp),%eax
   12fb4:	c7 40 50 08 00 00 00 	movl   $0x8,0x50(%eax)
        task->tss.cr3 = (uint32_t)kernel_table;
   12fbb:	ba 00 90 01 00       	mov    $0x19000,%edx
   12fc0:	8b 45 08             	mov    0x8(%ebp),%eax
   12fc3:	89 50 20             	mov    %edx,0x20(%eax)
   12fc6:	eb 66                	jmp    1302e <init_tss+0x141>
    }
    else
    {
        task->tss.esp = (uint32_t *)ualloc_pages(1);
   12fc8:	83 ec 0c             	sub    $0xc,%esp
   12fcb:	6a 01                	push   $0x1
   12fcd:	e8 7a de ff ff       	call   10e4c <ualloc_pages>
   12fd2:	83 c4 10             	add    $0x10,%esp
   12fd5:	89 c2                	mov    %eax,%edx
   12fd7:	8b 45 08             	mov    0x8(%ebp),%eax
   12fda:	89 50 3c             	mov    %edx,0x3c(%eax)
        task->tss.ss = task->tss.es = task->tss.ds = task->tss.fs = task->tss.gs = USER_SELECTOR_DS;
   12fdd:	8b 45 08             	mov    0x8(%ebp),%eax
   12fe0:	c7 40 60 2b 00 00 00 	movl   $0x2b,0x60(%eax)
   12fe7:	8b 45 08             	mov    0x8(%ebp),%eax
   12fea:	8b 50 60             	mov    0x60(%eax),%edx
   12fed:	8b 45 08             	mov    0x8(%ebp),%eax
   12ff0:	89 50 5c             	mov    %edx,0x5c(%eax)
   12ff3:	8b 45 08             	mov    0x8(%ebp),%eax
   12ff6:	8b 50 5c             	mov    0x5c(%eax),%edx
   12ff9:	8b 45 08             	mov    0x8(%ebp),%eax
   12ffc:	89 50 58             	mov    %edx,0x58(%eax)
   12fff:	8b 45 08             	mov    0x8(%ebp),%eax
   13002:	8b 50 58             	mov    0x58(%eax),%edx
   13005:	8b 45 08             	mov    0x8(%ebp),%eax
   13008:	89 50 4c             	mov    %edx,0x4c(%eax)
   1300b:	8b 45 08             	mov    0x8(%ebp),%eax
   1300e:	8b 50 4c             	mov    0x4c(%eax),%edx
   13011:	8b 45 08             	mov    0x8(%ebp),%eax
   13014:	89 50 54             	mov    %edx,0x54(%eax)
        task->tss.cs = USER_SELECTOR_CS;
   13017:	8b 45 08             	mov    0x8(%ebp),%eax
   1301a:	c7 40 50 23 00 00 00 	movl   $0x23,0x50(%eax)
        task->tss.cr3 = (uint32_t)create_page_table();
   13021:	e8 71 e3 ff ff       	call   11397 <create_page_table>
   13026:	89 c2                	mov    %eax,%edx
   13028:	8b 45 08             	mov    0x8(%ebp),%eax
   1302b:	89 50 20             	mov    %edx,0x20(%eax)
    }

    task->tss.eflags = ELFAGS_MBS | EFLAGS_IF;
   1302e:	8b 45 08             	mov    0x8(%ebp),%eax
   13031:	c7 40 28 02 02 00 00 	movl   $0x202,0x28(%eax)
    task->tss_sel = tss_sel;
   13038:	8b 45 08             	mov    0x8(%ebp),%eax
   1303b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1303e:	89 50 6c             	mov    %edx,0x6c(%eax)

    return 0;
   13041:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13046:	c9                   	leave  
   13047:	c3                   	ret    

00013048 <init_task>:

task_t *init_task(uint32_t entry)
{
   13048:	55                   	push   %ebp
   13049:	89 e5                	mov    %esp,%ebp
   1304b:	83 ec 18             	sub    $0x18,%esp
    irq_status status = irq_enter_protection();
   1304e:	e8 f5 da ff ff       	call   10b48 <irq_enter_protection>
   13053:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t *task = (task_t *)kalloc_pages(1);
   13056:	83 ec 0c             	sub    $0xc,%esp
   13059:	6a 01                	push   $0x1
   1305b:	e8 a2 dd ff ff       	call   10e02 <kalloc_pages>
   13060:	83 c4 10             	add    $0x10,%esp
   13063:	89 45 f0             	mov    %eax,-0x10(%ebp)
    task->ticks = task->default_ticks = TASK_TICKS_DEFAULT;
   13066:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13069:	c7 80 90 00 00 00 05 	movl   $0x5,0x90(%eax)
   13070:	00 00 00 
   13073:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13076:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
   1307c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1307f:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
    task->pid = alloc_pid();
   13085:	e8 72 f2 ff ff       	call   122fc <alloc_pid>
   1308a:	89 c2                	mov    %eax,%edx
   1308c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1308f:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
    task->ifkernel = USER_PROC;
   13095:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13098:	c7 40 70 01 00 00 00 	movl   $0x1,0x70(%eax)
    task->parent = NULL;
   1309f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   130a2:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)

    task_set_general(task);
   130a9:	83 ec 0c             	sub    $0xc,%esp
   130ac:	ff 75 f0             	pushl  -0x10(%ebp)
   130af:	e8 46 01 00 00       	call   131fa <task_set_general>
   130b4:	83 c4 10             	add    $0x10,%esp
    task_set_ready(task);
   130b7:	83 ec 0c             	sub    $0xc,%esp
   130ba:	ff 75 f0             	pushl  -0x10(%ebp)
   130bd:	e8 58 01 00 00       	call   1321a <task_set_ready>
   130c2:	83 c4 10             	add    $0x10,%esp

    ASSERT(task != NULL);
    init_tss(task, entry, task->ifkernel);
   130c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   130c8:	8b 40 70             	mov    0x70(%eax),%eax
   130cb:	83 ec 04             	sub    $0x4,%esp
   130ce:	50                   	push   %eax
   130cf:	ff 75 08             	pushl  0x8(%ebp)
   130d2:	ff 75 f0             	pushl  -0x10(%ebp)
   130d5:	e8 13 fe ff ff       	call   12eed <init_tss>
   130da:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(status);
   130dd:	83 ec 0c             	sub    $0xc,%esp
   130e0:	ff 75 f4             	pushl  -0xc(%ebp)
   130e3:	e8 73 da ff ff       	call   10b5b <irq_leave_protection>
   130e8:	83 c4 10             	add    $0x10,%esp
    return task;
   130eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   130ee:	c9                   	leave  
   130ef:	c3                   	ret    

000130f0 <task_switch_from_to>:

void task_switch_from_to(task_t *from, task_t *to)
{
   130f0:	55                   	push   %ebp
   130f1:	89 e5                	mov    %esp,%ebp
   130f3:	83 ec 08             	sub    $0x8,%esp
    switch_to_tss(to->tss_sel);
   130f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   130f9:	8b 40 6c             	mov    0x6c(%eax),%eax
   130fc:	83 ec 0c             	sub    $0xc,%esp
   130ff:	50                   	push   %eax
   13100:	e8 06 00 00 00       	call   1310b <switch_to_tss>
   13105:	83 c4 10             	add    $0x10,%esp
}
   13108:	90                   	nop
   13109:	c9                   	leave  
   1310a:	c3                   	ret    

0001310b <switch_to_tss>:

void switch_to_tss(int tss_sel)
{
   1310b:	55                   	push   %ebp
   1310c:	89 e5                	mov    %esp,%ebp
    far_jmp(tss_sel, 0);
   1310e:	8b 45 08             	mov    0x8(%ebp),%eax
   13111:	6a 00                	push   $0x0
   13113:	50                   	push   %eax
   13114:	e8 c2 fc ff ff       	call   12ddb <far_jmp>
   13119:	83 c4 08             	add    $0x8,%esp
}
   1311c:	90                   	nop
   1311d:	c9                   	leave  
   1311e:	c3                   	ret    

0001311f <cur_task>:

task_t *cur_task()
{
   1311f:	55                   	push   %ebp
   13120:	89 e5                	mov    %esp,%ebp
    return task_manager.cur_task;
   13122:	a1 20 80 01 00       	mov    0x18020,%eax
}
   13127:	5d                   	pop    %ebp
   13128:	c3                   	ret    

00013129 <task_time_ticks>:

void task_time_ticks()
{
   13129:	55                   	push   %ebp
   1312a:	89 e5                	mov    %esp,%ebp
   1312c:	83 ec 18             	sub    $0x18,%esp
    irq_status state = irq_enter_protection();
   1312f:	e8 14 da ff ff       	call   10b48 <irq_enter_protection>
   13134:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /* 获取进程的信息 */
    task_t *cur = cur_task();
   13137:	e8 e3 ff ff ff       	call   1311f <cur_task>
   1313c:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (--cur->ticks <= 0)
   1313f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13142:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   13148:	8d 50 ff             	lea    -0x1(%eax),%edx
   1314b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1314e:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
   13154:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13157:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   1315d:	85 c0                	test   %eax,%eax
   1315f:	7f 25                	jg     13186 <task_time_ticks+0x5d>
    {
        /* 重新插入就绪队列的尾部 */
        task_set_ready(cur);
   13161:	83 ec 0c             	sub    $0xc,%esp
   13164:	ff 75 f0             	pushl  -0x10(%ebp)
   13167:	e8 ae 00 00 00       	call   1321a <task_set_ready>
   1316c:	83 c4 10             	add    $0x10,%esp

        cur->ticks = cur->default_ticks;
   1316f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13172:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
   13178:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1317b:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

        task_dispatch();
   13181:	e8 11 00 00 00       	call   13197 <task_dispatch>
    }
    irq_leave_protection(state);
   13186:	83 ec 0c             	sub    $0xc,%esp
   13189:	ff 75 f4             	pushl  -0xc(%ebp)
   1318c:	e8 ca d9 ff ff       	call   10b5b <irq_leave_protection>
   13191:	83 c4 10             	add    $0x10,%esp
}
   13194:	90                   	nop
   13195:	c9                   	leave  
   13196:	c3                   	ret    

00013197 <task_dispatch>:

void task_dispatch()
{
   13197:	55                   	push   %ebp
   13198:	89 e5                	mov    %esp,%ebp
   1319a:	83 ec 18             	sub    $0x18,%esp
    task_t *cur = cur_task();
   1319d:	e8 7d ff ff ff       	call   1311f <cur_task>
   131a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t *next = task_schedule();
   131a5:	e8 c7 00 00 00       	call   13271 <task_schedule>
   131aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (next != cur && next->status == TASK_READY)
   131ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
   131b0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   131b3:	74 2f                	je     131e4 <task_dispatch+0x4d>
   131b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   131b8:	8b 00                	mov    (%eax),%eax
   131ba:	83 f8 02             	cmp    $0x2,%eax
   131bd:	75 25                	jne    131e4 <task_dispatch+0x4d>
    {
        task_manager.cur_task = next;
   131bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   131c2:	a3 20 80 01 00       	mov    %eax,0x18020
        next->status = TASK_RUNNING;
   131c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   131ca:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        task_switch_from_to(cur, next);
   131d0:	83 ec 08             	sub    $0x8,%esp
   131d3:	ff 75 f0             	pushl  -0x10(%ebp)
   131d6:	ff 75 f4             	pushl  -0xc(%ebp)
   131d9:	e8 12 ff ff ff       	call   130f0 <task_switch_from_to>
   131de:	83 c4 10             	add    $0x10,%esp
    else if (klist_len(&task_manager.ready_list) == 1)
    {
        /* 只有一个线程则无法切换 */
        return;
    }
    return;
   131e1:	90                   	nop
   131e2:	eb 13                	jmp    131f7 <task_dispatch+0x60>
    else if (klist_len(&task_manager.ready_list) == 1)
   131e4:	83 ec 0c             	sub    $0xc,%esp
   131e7:	68 38 80 01 00       	push   $0x18038
   131ec:	e8 bf f9 ff ff       	call   12bb0 <klist_len>
   131f1:	83 c4 10             	add    $0x10,%esp
   131f4:	83 f8 01             	cmp    $0x1,%eax
    return;
   131f7:	90                   	nop
}
   131f8:	c9                   	leave  
   131f9:	c3                   	ret    

000131fa <task_set_general>:
void task_set_general(task_t *task)
{
   131fa:	55                   	push   %ebp
   131fb:	89 e5                	mov    %esp,%ebp
   131fd:	83 ec 08             	sub    $0x8,%esp
    klist_append(&task_manager.general_list, &task->general_node);
   13200:	8b 45 08             	mov    0x8(%ebp),%eax
   13203:	83 e8 80             	sub    $0xffffff80,%eax
   13206:	83 ec 08             	sub    $0x8,%esp
   13209:	50                   	push   %eax
   1320a:	68 24 80 01 00       	push   $0x18024
   1320f:	e8 b9 f8 ff ff       	call   12acd <klist_append>
   13214:	83 c4 10             	add    $0x10,%esp
}
   13217:	90                   	nop
   13218:	c9                   	leave  
   13219:	c3                   	ret    

0001321a <task_set_ready>:

void task_set_ready(task_t *task)
{
   1321a:	55                   	push   %ebp
   1321b:	89 e5                	mov    %esp,%ebp
   1321d:	83 ec 08             	sub    $0x8,%esp
    klist_remove(&task_manager.ready_list, &task->state_node); /* 如果存在于就绪队列中就重新把其加入队尾 */
   13220:	8b 45 08             	mov    0x8(%ebp),%eax
   13223:	83 c0 78             	add    $0x78,%eax
   13226:	83 ec 08             	sub    $0x8,%esp
   13229:	50                   	push   %eax
   1322a:	68 38 80 01 00       	push   $0x18038
   1322f:	e8 1a f9 ff ff       	call   12b4e <klist_remove>
   13234:	83 c4 10             	add    $0x10,%esp
    task->status = TASK_READY;
   13237:	8b 45 08             	mov    0x8(%ebp),%eax
   1323a:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    klist_append(&task_manager.ready_list, &task->state_node);
   13240:	8b 45 08             	mov    0x8(%ebp),%eax
   13243:	83 c0 78             	add    $0x78,%eax
   13246:	83 ec 08             	sub    $0x8,%esp
   13249:	50                   	push   %eax
   1324a:	68 38 80 01 00       	push   $0x18038
   1324f:	e8 79 f8 ff ff       	call   12acd <klist_append>
   13254:	83 c4 10             	add    $0x10,%esp
}
   13257:	90                   	nop
   13258:	c9                   	leave  
   13259:	c3                   	ret    

0001325a <task_set_block>:

void task_set_block(task_t *task)
{
   1325a:	55                   	push   %ebp
   1325b:	89 e5                	mov    %esp,%ebp
   1325d:	83 ec 08             	sub    $0x8,%esp
    task->status = TASK_BLOCKED;
   13260:	8b 45 08             	mov    0x8(%ebp),%eax
   13263:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    task_dispatch();
   13269:	e8 29 ff ff ff       	call   13197 <task_dispatch>
}
   1326e:	90                   	nop
   1326f:	c9                   	leave  
   13270:	c3                   	ret    

00013271 <task_schedule>:

task_t *task_schedule()
{
   13271:	55                   	push   %ebp
   13272:	89 e5                	mov    %esp,%ebp
   13274:	83 ec 18             	sub    $0x18,%esp
    int sections = SCHEDULE_SECTIONS;
   13277:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    switch (sections)
   1327e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13281:	85 c0                	test   %eax,%eax
   13283:	74 08                	je     1328d <task_schedule+0x1c>
    {
    case THREAD_FIFO:
        return task_FIFO();
        break;
    default:
        break;
   13285:	90                   	nop
    }
    return NULL;
   13286:	b8 00 00 00 00       	mov    $0x0,%eax
   1328b:	eb 05                	jmp    13292 <task_schedule+0x21>
        return task_FIFO();
   1328d:	e8 02 00 00 00       	call   13294 <task_FIFO>
}
   13292:	c9                   	leave  
   13293:	c3                   	ret    

00013294 <task_FIFO>:

task_t *task_FIFO()
{
   13294:	55                   	push   %ebp
   13295:	89 e5                	mov    %esp,%ebp
   13297:	83 ec 18             	sub    $0x18,%esp
    klist_node_t *next_node = klist_get_first_node(&task_manager.ready_list);
   1329a:	83 ec 0c             	sub    $0xc,%esp
   1329d:	68 38 80 01 00       	push   $0x18038
   132a2:	e8 14 f9 ff ff       	call   12bbb <klist_get_first_node>
   132a7:	83 c4 10             	add    $0x10,%esp
   132aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t *next = KLIST_STRUCT_ADDR(next_node, task_t, state_node);
   132ad:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   132b1:	74 08                	je     132bb <task_FIFO+0x27>
   132b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   132b6:	83 e8 78             	sub    $0x78,%eax
   132b9:	eb 05                	jmp    132c0 <task_FIFO+0x2c>
   132bb:	b8 00 00 00 00       	mov    $0x0,%eax
   132c0:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return next;
   132c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   132c6:	c9                   	leave  
   132c7:	c3                   	ret    
