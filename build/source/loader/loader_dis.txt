
F:/OS_lab/little_os/build/source/loader/loader.elf:     file format elf32-i386
F:/OS_lab/little_os/build/source/loader/loader.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00008000

Program Header:
    LOAD off    0x00001000 vaddr 0x00008000 paddr 0x00008000 align 2**12
         filesz 0x00000787 memsz 0x00000787 flags r-x
    LOAD off    0x00002000 vaddr 0x0000a000 paddr 0x0000a000 align 2**12
         filesz 0x00001000 memsz 0x000018a4 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000787  00008000  00008000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00001000  0000a000  0000a000  00002000  2**12
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000008a4  0000b000  0000b000  00003000  2**5
                  ALLOC
  3 .comment      00000011  00000000  00000000  00003000  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000080  00000000  00000000  00003018  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000b8f  00000000  00000000  00003098  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000049f  00000000  00000000  00003c27  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000003e5  00000000  00000000  000040c6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000036c  00000000  00000000  000044ac  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000496  00000000  00000000  00004818  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00008000 l    d  .text	00000000 .text
0000a000 l    d  .data	00000000 .data
0000b000 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    df *ABS*	00000000 gdt16.c
00008018 l     F .text	00000040 lgdt
00000000 l    df *ABS*	00000000 loader16.c
000081b4 l     F .text	0000000b cli
000081bf l     F .text	0000002a inb
000081e9 l     F .text	0000002d outb
00008216 l     F .text	0000001a rcr0
00008230 l     F .text	00000012 wcr0
00008242 l     F .text	0000002b far_jmp
000083a4 l     F .text	0000008b enter_portected
00000000 l    df *ABS*	00000000 loader32.c
00008449 l     F .text	0000001f inw
00008468 l     F .text	0000001d inb
00008485 l     F .text	0000001f outb
000084a4 l     F .text	00000011 rcr0
000084b5 l     F .text	0000000c wcr0
000084c1 l     F .text	0000000c wcr3
0000a000 l     O .data	00001000 page_dir.1941
0000b000 g     O .bss	00000800 gdt_table
00008609 g     F .text	0000011a read_elf
00008358 g     F .text	0000000f detect_method2
00008003 g       .text	00000000 protected_mode_entry
00008376 g     F .text	0000002e detect_memory
0000842f g     F .text	0000001a loader16c_entry
00008723 g     F .text	00000027 enable_page_mode
00008000 g       .text	00000000 _start
0000874a g     F .text	0000003d loader32c_entry
0000b800 g     O .bss	000000a4 mem
00008367 g     F .text	0000000f detect_method3
0000b000 g       .bss	00000000 __bss_start
0000826d g     F .text	000000eb detect_method1
0000811e g     F .text	00000096 gdt16_init
000084cd g     F .text	0000013c load2mem
00008058 g     F .text	000000c6 gdt16_segment_set
0000b000 g       .data	00000000 _edata
0000b8a4 g       .bss	00000000 _end



Disassembly of section .text:

00008000 <_start>:
    .code16
    .text
    .extern loader16c_entry
    .global _start
_start:
    jmp  loader16c_entry
    8000:	e9 2c 04             	jmp    842f <loader16c_entry>

00008003 <protected_mode_entry>:
    .code32
    .text
    .global protected_mode_entry
    .extern loader32c_entry
protected_mode_entry:
    mov $16, %ax
    8003:	66 b8 10 00 8e d8    	mov    $0xd88e0010,%eax
	mov %ax, %ds
	mov %ax, %ss
    8009:	8e d0                	mov    %ax,%ss
	mov %ax, %es
    800b:	8e c0                	mov    %ax,%es
	mov %ax, %fs
    800d:	8e e0                	mov    %ax,%fs
	mov %ax, %gs
    800f:	8e e8                	mov    %ax,%gs

    8011:	ea 4a 87 00 00       	ljmp   $0x0,$0x874a
    8016:	08 00                	or     %al,(%bx,%si)

00008018 <lgdt>:
 *
 * @param start
 * @param offset
 */
static inline void lgdt(uint32_t start, uint16_t offset)
{
    8018:	66 55                	push   %ebp
    801a:	66 89 e5             	mov    %esp,%ebp
    801d:	66 83 ec 14          	sub    $0x14,%esp
    8021:	67 66 8b 45 0c       	mov    0xc(%ebp),%eax
    8026:	67 89 45 ec          	mov    %ax,-0x14(%ebp)
        uint16_t offset;
        uint16_t start15_0;
        uint16_t start32_16;
    } gdt;

    gdt.start32_16 = start >> 16;
    802a:	67 66 8b 45 08       	mov    0x8(%ebp),%eax
    802f:	66 c1 e8 10          	shr    $0x10,%eax
    8033:	67 89 45 fe          	mov    %ax,-0x2(%ebp)
    gdt.start15_0 = start & 0xFFFF;
    8037:	67 66 8b 45 08       	mov    0x8(%ebp),%eax
    803c:	67 89 45 fc          	mov    %ax,-0x4(%ebp)
    gdt.offset = offset - 1;
    8040:	67 66 0f b7 45 ec    	movzwl -0x14(%ebp),%eax
    8046:	66 83 e8 01          	sub    $0x1,%eax
    804a:	67 89 45 fa          	mov    %ax,-0x6(%ebp)

    __asm__ __volatile__("lgdt %[gdt]" ::[gdt] "m"(gdt));
    804e:	67 0f 01 55 fa       	lgdtw  -0x6(%ebp)
}
    8053:	90                   	nop
    8054:	66 c9                	leavel 
    8056:	66 c3                	retl   

00008058 <gdt16_segment_set>:
 * @param limit 段界限  20位
 * @param base 段基址  32位
 * @param attr 段属性 16位
 */
void gdt16_segment_set(uint16_t selector, uint32_t limit, uint32_t base, uint16_t attr)
{
    8058:	66 55                	push   %ebp
    805a:	66 89 e5             	mov    %esp,%ebp
    805d:	66 83 ec 18          	sub    $0x18,%esp
    8061:	67 66 8b 55 08       	mov    0x8(%ebp),%edx
    8066:	67 66 8b 45 14       	mov    0x14(%ebp),%eax
    806b:	67 89 55 ec          	mov    %dx,-0x14(%ebp)
    806f:	67 89 45 e8          	mov    %ax,-0x18(%ebp)
    gdt_entry_t *desc = gdt_table + (selector >> 3);
    8073:	67 66 0f b7 45 ec    	movzwl -0x14(%ebp),%eax
    8079:	c1 e8 03             	shr    $0x3,%ax
    807c:	66 0f b7 c0          	movzwl %ax,%eax
    8080:	66 c1 e0 03          	shl    $0x3,%eax
    8084:	66 05 00 b0 00 00    	add    $0xb000,%eax
    808a:	67 66 89 45 fc       	mov    %eax,-0x4(%ebp)

    if (limit > 0xFFFFF)
    808f:	67 66 81 7d 0c ff ff 	cmpl   $0xfffff,0xc(%ebp)
    8096:	0f 00 
    8098:	76 14                	jbe    80ae <gdt16_segment_set+0x56>
    {
        attr |= 0x8000;
    809a:	67 81 4d e8 00 80    	orw    $0x8000,-0x18(%ebp)
        limit /= 0x1000;
    80a0:	67 66 8b 45 0c       	mov    0xc(%ebp),%eax
    80a5:	66 c1 e8 0c          	shr    $0xc,%eax
    80a9:	67 66 89 45 0c       	mov    %eax,0xc(%ebp)
    }

    desc->limit_low = limit & 0xFFFF;
    80ae:	67 66 8b 45 0c       	mov    0xc(%ebp),%eax
    80b3:	66 89 c2             	mov    %eax,%edx
    80b6:	67 66 8b 45 fc       	mov    -0x4(%ebp),%eax
    80bb:	67 89 10             	mov    %dx,(%eax)
    desc->base_low = base & 0xFFFF;
    80be:	67 66 8b 45 10       	mov    0x10(%ebp),%eax
    80c3:	66 89 c2             	mov    %eax,%edx
    80c6:	67 66 8b 45 fc       	mov    -0x4(%ebp),%eax
    80cb:	67 89 50 02          	mov    %dx,0x2(%eax)
    desc->base_middle = (base >> 16) & 0xFF;
    80cf:	67 66 8b 45 10       	mov    0x10(%ebp),%eax
    80d4:	66 c1 e8 10          	shr    $0x10,%eax
    80d8:	66 89 c2             	mov    %eax,%edx
    80db:	67 66 8b 45 fc       	mov    -0x4(%ebp),%eax
    80e0:	67 88 50 04          	mov    %dl,0x4(%eax)
    desc->attributes = attr | (((limit >> 16) & 0xF) << 8);
    80e4:	67 66 8b 45 0c       	mov    0xc(%ebp),%eax
    80e9:	66 c1 e8 10          	shr    $0x10,%eax
    80ed:	66 c1 e0 08          	shl    $0x8,%eax
    80f1:	25 00 0f             	and    $0xf00,%ax
    80f4:	67 0b 45 e8          	or     -0x18(%ebp),%ax
    80f8:	66 89 c2             	mov    %eax,%edx
    80fb:	67 66 8b 45 fc       	mov    -0x4(%ebp),%eax
    8100:	67 89 50 05          	mov    %dx,0x5(%eax)
    desc->base_high = (base >> 24) & 0xFF;
    8104:	67 66 8b 45 10       	mov    0x10(%ebp),%eax
    8109:	66 c1 e8 18          	shr    $0x18,%eax
    810d:	66 89 c2             	mov    %eax,%edx
    8110:	67 66 8b 45 fc       	mov    -0x4(%ebp),%eax
    8115:	67 88 50 07          	mov    %dl,0x7(%eax)
}
    8119:	90                   	nop
    811a:	66 c9                	leavel 
    811c:	66 c3                	retl   

0000811e <gdt16_init>:
/**
 * @brief 初始化GDT
 *
 */
void gdt16_init()
{
    811e:	66 55                	push   %ebp
    8120:	66 89 e5             	mov    %esp,%ebp
    8123:	66 83 ec 10          	sub    $0x10,%esp
    for (int i = 0; i < GDT_SIZE; i++)
    8127:	67 66 c7 45 fc 00 00 	movl   $0x0,-0x4(%ebp)
    812e:	00 00 
    8130:	eb 28                	jmp    815a <gdt16_init+0x3c>
    {
        gdt16_segment_set(i << 3, 0, 0, 0);
    8132:	67 66 8b 45 fc       	mov    -0x4(%ebp),%eax
    8137:	66 c1 e0 03          	shl    $0x3,%eax
    813b:	66 0f b7 c0          	movzwl %ax,%eax
    813f:	66 6a 00             	pushl  $0x0
    8142:	66 6a 00             	pushl  $0x0
    8145:	66 6a 00             	pushl  $0x0
    8148:	66 50                	push   %eax
    814a:	66 e8 08 ff ff ff    	calll  8058 <gdt16_segment_set>
    8150:	66 83 c4 10          	add    $0x10,%esp
    for (int i = 0; i < GDT_SIZE; i++)
    8154:	67 66 83 45 fc 01    	addl   $0x1,-0x4(%ebp)
    815a:	67 66 81 7d fc ff 00 	cmpl   $0xff,-0x4(%ebp)
    8161:	00 00 
    8163:	7e cd                	jle    8132 <gdt16_init+0x14>
    }

    gdt16_segment_set(KERNEL_SELECTOR_DS, 0xFFFFFFFF, 0x00000000, SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);
    8165:	66 68 92 40 00 00    	pushl  $0x4092
    816b:	66 6a 00             	pushl  $0x0
    816e:	66 6a ff             	pushl  $0xffffffff
    8171:	66 6a 10             	pushl  $0x10
    8174:	66 e8 de fe ff ff    	calll  8058 <gdt16_segment_set>
    817a:	66 83 c4 10          	add    $0x10,%esp
    gdt16_segment_set(KERNEL_SELECTOR_CS, 0xFFFFFFFF, 0x00000000, SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);
    817e:	66 68 9a 40 00 00    	pushl  $0x409a
    8184:	66 6a 00             	pushl  $0x0
    8187:	66 6a ff             	pushl  $0xffffffff
    818a:	66 6a 08             	pushl  $0x8
    818d:	66 e8 c5 fe ff ff    	calll  8058 <gdt16_segment_set>
    8193:	66 83 c4 10          	add    $0x10,%esp

    lgdt((uint32_t)gdt_table, sizeof(gdt_table));
    8197:	66 b8 00 b0 00 00    	mov    $0xb000,%eax
    819d:	66 68 00 08 00 00    	pushl  $0x800
    81a3:	66 50                	push   %eax
    81a5:	66 e8 6d fe ff ff    	calll  8018 <lgdt>
    81ab:	66 83 c4 08          	add    $0x8,%esp
    81af:	90                   	nop
    81b0:	66 c9                	leavel 
    81b2:	66 c3                	retl   

000081b4 <cli>:
{
    81b4:	66 55                	push   %ebp
    81b6:	66 89 e5             	mov    %esp,%ebp
    __asm__ __volatile__("cli");
    81b9:	fa                   	cli    
}
    81ba:	90                   	nop
    81bb:	66 5d                	pop    %ebp
    81bd:	66 c3                	retl   

000081bf <inb>:
{
    81bf:	66 55                	push   %ebp
    81c1:	66 89 e5             	mov    %esp,%ebp
    81c4:	66 83 ec 14          	sub    $0x14,%esp
    81c8:	67 66 8b 45 08       	mov    0x8(%ebp),%eax
    81cd:	67 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[port], %[rv]"
    81d1:	67 66 0f b7 45 ec    	movzwl -0x14(%ebp),%eax
    81d7:	66 89 c2             	mov    %eax,%edx
    81da:	ec                   	in     (%dx),%al
    81db:	67 88 45 ff          	mov    %al,-0x1(%ebp)
    return rv;
    81df:	67 66 0f b6 45 ff    	movzbl -0x1(%ebp),%eax
}
    81e5:	66 c9                	leavel 
    81e7:	66 c3                	retl   

000081e9 <outb>:
{
    81e9:	66 55                	push   %ebp
    81eb:	66 89 e5             	mov    %esp,%ebp
    81ee:	66 83 ec 08          	sub    $0x8,%esp
    81f2:	67 66 8b 55 08       	mov    0x8(%ebp),%edx
    81f7:	67 66 8b 45 0c       	mov    0xc(%ebp),%eax
    81fc:	67 89 55 fc          	mov    %dx,-0x4(%ebp)
    8200:	67 88 45 f8          	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[data], %[port]"
    8204:	67 66 0f b6 45 f8    	movzbl -0x8(%ebp),%eax
    820a:	67 66 0f b7 55 fc    	movzwl -0x4(%ebp),%edx
    8210:	ee                   	out    %al,(%dx)
}
    8211:	90                   	nop
    8212:	66 c9                	leavel 
    8214:	66 c3                	retl   

00008216 <rcr0>:
{
    8216:	66 55                	push   %ebp
    8218:	66 89 e5             	mov    %esp,%ebp
    821b:	66 83 ec 10          	sub    $0x10,%esp
    __asm__ __volatile__("mov %%cr0, %[rv]"
    821f:	0f 20 c0             	mov    %cr0,%eax
    8222:	67 66 89 45 fc       	mov    %eax,-0x4(%ebp)
    return rv;
    8227:	67 66 8b 45 fc       	mov    -0x4(%ebp),%eax
}
    822c:	66 c9                	leavel 
    822e:	66 c3                	retl   

00008230 <wcr0>:
{
    8230:	66 55                	push   %ebp
    8232:	66 89 e5             	mov    %esp,%ebp
    __asm__ __volatile__("mov %[data], %%cr0" ::[data] "r"(data));
    8235:	67 66 8b 45 08       	mov    0x8(%ebp),%eax
    823a:	0f 22 c0             	mov    %eax,%cr0
}
    823d:	90                   	nop
    823e:	66 5d                	pop    %ebp
    8240:	66 c3                	retl   

00008242 <far_jmp>:

    __asm__ __volatile__("ltr %%ax" ::"a"(tss_sel));
}

static inline void far_jmp(uint32_t selc, uint32_t offset)
{
    8242:	66 55                	push   %ebp
    8244:	66 89 e5             	mov    %esp,%ebp
    8247:	66 83 ec 10          	sub    $0x10,%esp
    uint32_t addr[] = {offset, selc};
    824b:	67 66 8b 45 0c       	mov    0xc(%ebp),%eax
    8250:	67 66 89 45 f8       	mov    %eax,-0x8(%ebp)
    8255:	67 66 8b 45 08       	mov    0x8(%ebp),%eax
    825a:	67 66 89 45 fc       	mov    %eax,-0x4(%ebp)
    __asm__ __volatile__("ljmpl *(%[addr])" ::[addr] "r"(addr));
    825f:	67 66 8d 45 f8       	lea    -0x8(%ebp),%eax
    8264:	67 66 ff 28          	ljmpl  *(%eax)
}
    8268:	90                   	nop
    8269:	66 c9                	leavel 
    826b:	66 c3                	retl   

0000826d <detect_method1>:
 *
 * @return true
 * @return false
 */
bool detect_method1()
{
    826d:	66 55                	push   %ebp
    826f:	66 89 e5             	mov    %esp,%ebp
    8272:	66 57                	push   %edi
    8274:	66 56                	push   %esi
    8276:	66 53                	push   %ebx
    8278:	66 83 ec 30          	sub    $0x30,%esp
    ARDS_entry_t ARDS;
    uint32_t countID;
    uint32_t signature, blength;

    for (int i = 0; i < MAX_MEM_LENGTH; i++)
    827c:	67 66 c7 45 ec 00 00 	movl   $0x0,-0x14(%ebp)
    8283:	00 00 
    8285:	e9 b8 00             	jmp    8340 <detect_method1+0xd3>
    {
        ARDS_entry_t *entry = &ARDS;
    8288:	67 66 8d 45 cc       	lea    -0x34(%ebp),%eax
    828d:	67 66 89 45 e8       	mov    %eax,-0x18(%ebp)
        // 每次从其中写入并调出内存的信息
        __asm__ __volatile__("int  $0x15"
    8292:	66 b8 20 e8 00 00    	mov    $0xe820,%eax
    8298:	67 66 8b 5d f0       	mov    -0x10(%ebp),%ebx
    829d:	66 b9 14 00 00 00    	mov    $0x14,%ecx
    82a3:	66 ba 50 41 4d 53    	mov    $0x534d4150,%edx
    82a9:	67 66 8b 75 e8       	mov    -0x18(%ebp),%esi
    82ae:	66 89 f7             	mov    %esi,%edi
    82b1:	cd 15                	int    $0x15
    82b3:	66 89 da             	mov    %ebx,%edx
    82b6:	67 66 89 45 e4       	mov    %eax,-0x1c(%ebp)
    82bb:	67 66 89 4d e0       	mov    %ecx,-0x20(%ebp)
    82c0:	67 66 89 55 f0       	mov    %edx,-0x10(%ebp)
                             : "=a"(signature), "=c"(blength), "=b"(countID)
                             : "a"(0xE820), "b"(countID), "c"(20), "d"(0x534D4150), "D"(entry));

        // 对返回出的信息进行处理
        if (signature != 0x534d4150)
    82c5:	67 66 81 7d e4 50 41 	cmpl   $0x534d4150,-0x1c(%ebp)
    82cc:	4d 53 
    82ce:	74 08                	je     82d8 <detect_method1+0x6b>
        {
            return false;
    82d0:	66 b8 00 00 00 00    	mov    $0x0,%eax
    82d6:	eb 72                	jmp    834a <detect_method1+0xdd>
        }

        if (entry->Type == 1)
    82d8:	67 66 8b 45 e8       	mov    -0x18(%ebp),%eax
    82dd:	67 66 8b 40 10       	mov    0x10(%eax),%eax
    82e2:	66 83 f8 01          	cmp    $0x1,%eax
    82e6:	75 39                	jne    8321 <detect_method1+0xb4>
        {
            mem.info[mem.count].start = entry->BaseL;
    82e8:	66 a1 a0 b8          	mov    0xb8a0,%eax
    82ec:	67 66 8b 55 e8       	mov    -0x18(%ebp),%edx
    82f1:	67 66 8b 12          	mov    (%edx),%edx
    82f5:	67 66 89 14 c5 00 b8 	mov    %edx,0xb800(,%eax,8)
    82fc:	00 00 
            mem.info[mem.count].offset = entry->LengthL;
    82fe:	66 a1 a0 b8          	mov    0xb8a0,%eax
    8302:	67 66 8b 55 e8       	mov    -0x18(%ebp),%edx
    8307:	67 66 8b 52 08       	mov    0x8(%edx),%edx
    830c:	67 66 89 14 c5 04 b8 	mov    %edx,0xb804(,%eax,8)
    8313:	00 00 
            mem.count++;
    8315:	66 a1 a0 b8          	mov    0xb8a0,%eax
    8319:	66 83 c0 01          	add    $0x1,%eax
    831d:	66 a3 a0 b8          	mov    %eax,0xb8a0
        }

        if (blength == 20)
    8321:	67 66 83 7d e0 14    	cmpl   $0x14,-0x20(%ebp)
    8327:	74 10                	je     8339 <detect_method1+0xcc>
        {
            continue;
        }

        if (countID == 0)
    8329:	67 66 83 7d f0 00    	cmpl   $0x0,-0x10(%ebp)
    832f:	75 09                	jne    833a <detect_method1+0xcd>
        {
            return true;
    8331:	66 b8 01 00 00 00    	mov    $0x1,%eax
    8337:	eb 11                	jmp    834a <detect_method1+0xdd>
            continue;
    8339:	90                   	nop
    for (int i = 0; i < MAX_MEM_LENGTH; i++)
    833a:	67 66 83 45 ec 01    	addl   $0x1,-0x14(%ebp)
    8340:	67 66 83 7d ec 13    	cmpl   $0x13,-0x14(%ebp)
    8346:	0f 8e 3e ff          	jle    8288 <detect_method1+0x1b>
        }
    }
}
    834a:	66 83 c4 30          	add    $0x30,%esp
    834e:	66 5b                	pop    %ebx
    8350:	66 5e                	pop    %esi
    8352:	66 5f                	pop    %edi
    8354:	66 5d                	pop    %ebp
    8356:	66 c3                	retl   

00008358 <detect_method2>:
 *
 * @return true
 * @return false
 */
bool detect_method2()
{
    8358:	66 55                	push   %ebp
    835a:	66 89 e5             	mov    %esp,%ebp
    return false;
    835d:	66 b8 00 00 00 00    	mov    $0x0,%eax
}
    8363:	66 5d                	pop    %ebp
    8365:	66 c3                	retl   

00008367 <detect_method3>:
 *
 * @return true
 * @return false
 */
bool detect_method3()
{
    8367:	66 55                	push   %ebp
    8369:	66 89 e5             	mov    %esp,%ebp
    return false;
    836c:	66 b8 00 00 00 00    	mov    $0x0,%eax
}
    8372:	66 5d                	pop    %ebp
    8374:	66 c3                	retl   

00008376 <detect_memory>:
/**
 * @brief 内存检测
 *
 */
void detect_memory()
{
    8376:	66 55                	push   %ebp
    8378:	66 89 e5             	mov    %esp,%ebp
    if (detect_method1() == true)
    837b:	66 e8 ec fe ff ff    	calll  826d <detect_method1>
    8381:	66 83 f8 01          	cmp    $0x1,%eax
    8385:	74 14                	je     839b <detect_memory+0x25>
        goto end;

    if (detect_method2() == true)
    8387:	66 e8 cb ff ff ff    	calll  8358 <detect_method2>
    838d:	66 83 f8 01          	cmp    $0x1,%eax
    8391:	74 0b                	je     839e <detect_memory+0x28>
        goto end;

    detect_method3();
    8393:	66 e8 ce ff ff ff    	calll  8367 <detect_method3>
end:
    return;
    8399:	eb 04                	jmp    839f <detect_memory+0x29>
        goto end;
    839b:	90                   	nop
    839c:	eb 01                	jmp    839f <detect_memory+0x29>
        goto end;
    839e:	90                   	nop
    return;
    839f:	90                   	nop
}
    83a0:	66 5d                	pop    %ebp
    83a2:	66 c3                	retl   

000083a4 <enter_portected>:
/**
 * @brief 进入保护模式
 *
 */
static void enter_portected()
{
    83a4:	66 55                	push   %ebp
    83a6:	66 89 e5             	mov    %esp,%ebp
    83a9:	66 83 ec 18          	sub    $0x18,%esp
    // 关中断
    cli();
    83ad:	66 e8 01 fe ff ff    	calll  81b4 <cli>
    // 打开A20总线
    uint8_t a20 = inb(0x92); // 进入南桥芯片并读出数据
    83b3:	66 68 92 00 00 00    	pushl  $0x92
    83b9:	66 e8 00 fe ff ff    	calll  81bf <inb>
    83bf:	66 83 c4 04          	add    $0x4,%esp
    83c3:	67 88 45 f7          	mov    %al,-0x9(%ebp)
    outb(0x92, 0x2 | a20);   // 打开南桥芯片的A20控制位
    83c7:	67 66 0f b6 45 f7    	movzbl -0x9(%ebp),%eax
    83cd:	66 83 c8 02          	or     $0x2,%eax
    83d1:	66 0f b6 c0          	movzbl %al,%eax
    83d5:	66 50                	push   %eax
    83d7:	66 68 92 00 00 00    	pushl  $0x92
    83dd:	66 e8 06 fe ff ff    	calll  81e9 <outb>
    83e3:	66 83 c4 08          	add    $0x8,%esp

    // 加载GDT表
    gdt16_init();
    83e7:	66 e8 31 fd ff ff    	calll  811e <gdt16_init>

    // 开启cr0中的PE位（打开页表也需要将此位置1）
    uint32_t cr0 = rcr0();
    83ed:	66 e8 23 fe ff ff    	calll  8216 <rcr0>
    83f3:	67 66 89 45 f0       	mov    %eax,-0x10(%ebp)
    wcr0(cr0 | (1 << 0));
    83f8:	67 66 8b 45 f0       	mov    -0x10(%ebp),%eax
    83fd:	66 83 c8 01          	or     $0x1,%eax
    8401:	66 83 ec 0c          	sub    $0xc,%esp
    8405:	66 50                	push   %eax
    8407:	66 e8 23 fe ff ff    	calll  8230 <wcr0>
    840d:	66 83 c4 10          	add    $0x10,%esp
    // 跳入保护模式的汇编代码部分
    far_jmp(8, (uint32_t)protected_mode_entry);
    8411:	66 b8 03 80 00 00    	mov    $0x8003,%eax
    8417:	66 83 ec 08          	sub    $0x8,%esp
    841b:	66 50                	push   %eax
    841d:	66 6a 08             	pushl  $0x8
    8420:	66 e8 1c fe ff ff    	calll  8242 <far_jmp>
    8426:	66 83 c4 10          	add    $0x10,%esp
}
    842a:	90                   	nop
    842b:	66 c9                	leavel 
    842d:	66 c3                	retl   

0000842f <loader16c_entry>:
/**
 * @brief 16位loader的C入口
 *
 */
void loader16c_entry(void)
{
    842f:	66 55                	push   %ebp
    8431:	66 89 e5             	mov    %esp,%ebp
    8434:	66 83 ec 08          	sub    $0x8,%esp
    // 内存检测
    detect_memory();
    8438:	66 e8 38 ff ff ff    	calll  8376 <detect_memory>
    // 进入保护模式
    enter_portected();
    843e:	66 e8 60 ff ff ff    	calll  83a4 <enter_portected>
    8444:	90                   	nop
    8445:	66 c9                	leavel 
    8447:	66 c3                	retl   

00008449 <inw>:
{
    8449:	55                   	push   %bp
    844a:	89 e5                	mov    %sp,%bp
    844c:	83 ec 14             	sub    $0x14,%sp
    844f:	8b 45 08             	mov    0x8(%di),%ax
    8452:	66 89 45 ec          	mov    %eax,-0x14(%di)
    __asm__ __volatile__("in %[port], %[rv]"
    8456:	0f b7 45 ec          	movzww -0x14(%di),%ax
    845a:	89 c2                	mov    %ax,%dx
    845c:	66 ed                	in     (%dx),%eax
    845e:	66 89 45 fe          	mov    %eax,-0x2(%di)
    return rv;
    8462:	0f b7 45 fe          	movzww -0x2(%di),%ax
}
    8466:	c9                   	leave  
    8467:	c3                   	ret    

00008468 <inb>:
{
    8468:	55                   	push   %bp
    8469:	89 e5                	mov    %sp,%bp
    846b:	83 ec 14             	sub    $0x14,%sp
    846e:	8b 45 08             	mov    0x8(%di),%ax
    8471:	66 89 45 ec          	mov    %eax,-0x14(%di)
    __asm__ __volatile__("inb %[port], %[rv]"
    8475:	0f b7 45 ec          	movzww -0x14(%di),%ax
    8479:	89 c2                	mov    %ax,%dx
    847b:	ec                   	in     (%dx),%al
    847c:	88 45 ff             	mov    %al,-0x1(%di)
    return rv;
    847f:	0f b6 45 ff          	movzbw -0x1(%di),%ax
}
    8483:	c9                   	leave  
    8484:	c3                   	ret    

00008485 <outb>:
{
    8485:	55                   	push   %bp
    8486:	89 e5                	mov    %sp,%bp
    8488:	83 ec 08             	sub    $0x8,%sp
    848b:	8b 55 08             	mov    0x8(%di),%dx
    848e:	8b 45 0c             	mov    0xc(%di),%ax
    8491:	66 89 55 fc          	mov    %edx,-0x4(%di)
    8495:	88 45 f8             	mov    %al,-0x8(%di)
    __asm__ __volatile__("outb %[data], %[port]"
    8498:	0f b6 45 f8          	movzbw -0x8(%di),%ax
    849c:	0f b7 55 fc          	movzww -0x4(%di),%dx
    84a0:	ee                   	out    %al,(%dx)
}
    84a1:	90                   	nop
    84a2:	c9                   	leave  
    84a3:	c3                   	ret    

000084a4 <rcr0>:
{
    84a4:	55                   	push   %bp
    84a5:	89 e5                	mov    %sp,%bp
    84a7:	83 ec 10             	sub    $0x10,%sp
    __asm__ __volatile__("mov %%cr0, %[rv]"
    84aa:	0f 20 c0             	mov    %cr0,%eax
    84ad:	89 45 fc             	mov    %ax,-0x4(%di)
    return rv;
    84b0:	8b 45 fc             	mov    -0x4(%di),%ax
}
    84b3:	c9                   	leave  
    84b4:	c3                   	ret    

000084b5 <wcr0>:
{
    84b5:	55                   	push   %bp
    84b6:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("mov %[data], %%cr0" ::[data] "r"(data));
    84b8:	8b 45 08             	mov    0x8(%di),%ax
    84bb:	0f 22 c0             	mov    %eax,%cr0
}
    84be:	90                   	nop
    84bf:	5d                   	pop    %bp
    84c0:	c3                   	ret    

000084c1 <wcr3>:
{
    84c1:	55                   	push   %bp
    84c2:	89 e5                	mov    %sp,%bp
    __asm__ __volatile__("mov %[data], %%cr3" ::[data] "r"(data));
    84c4:	8b 45 08             	mov    0x8(%di),%ax
    84c7:	0f 22 d8             	mov    %eax,%cr3
}
    84ca:	90                   	nop
    84cb:	5d                   	pop    %bp
    84cc:	c3                   	ret    

000084cd <load2mem>:
// #include "loader32.h"
#include "loader.h"
#include "comm/elf.h"

void load2mem(uint32_t sector, uint16_t sector_count, uint8_t *buf)
{
    84cd:	55                   	push   %bp
    84ce:	89 e5                	mov    %sp,%bp
    84d0:	53                   	push   %bx
    84d1:	83 ec 14             	sub    $0x14,%sp
    84d4:	8b 45 0c             	mov    0xc(%di),%ax
    84d7:	66 89 45 e8          	mov    %eax,-0x18(%di)
    outb(0x1F6, (uint8_t)(0xE0));
    84db:	68 e0 00             	push   $0xe0
    84de:	00 00                	add    %al,(%bx,%si)
    84e0:	68 f6 01             	push   $0x1f6
    84e3:	00 00                	add    %al,(%bx,%si)
    84e5:	e8 9b ff             	call   8483 <inb+0x1b>
    84e8:	ff                   	(bad)  
    84e9:	ff 83 c4 08          	incw   0x8c4(%bp,%di)

    outb(0x1F2, (uint8_t)(sector_count >> 8));
    84ed:	0f b7 45 e8          	movzww -0x18(%di),%ax
    84f1:	66 c1 e8 08          	shr    $0x8,%eax
    84f5:	0f b6 c0             	movzbw %al,%ax
    84f8:	50                   	push   %ax
    84f9:	68 f2 01             	push   $0x1f2
    84fc:	00 00                	add    %al,(%bx,%si)
    84fe:	e8 82 ff             	call   8483 <inb+0x1b>
    8501:	ff                   	(bad)  
    8502:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(0x1F3, (uint8_t)(sector >> 24));
    8506:	8b 45 08             	mov    0x8(%di),%ax
    8509:	c1 e8 18             	shr    $0x18,%ax
    850c:	0f b6 c0             	movzbw %al,%ax
    850f:	50                   	push   %ax
    8510:	68 f3 01             	push   $0x1f3
    8513:	00 00                	add    %al,(%bx,%si)
    8515:	e8 6b ff             	call   8483 <inb+0x1b>
    8518:	ff                   	(bad)  
    8519:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(0x1F4, (uint8_t)(0));
    851d:	6a 00                	push   $0x0
    851f:	68 f4 01             	push   $0x1f4
    8522:	00 00                	add    %al,(%bx,%si)
    8524:	e8 5c ff             	call   8483 <inb+0x1b>
    8527:	ff                   	(bad)  
    8528:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(0x1F5, (uint8_t)(0));
    852c:	6a 00                	push   $0x0
    852e:	68 f5 01             	push   $0x1f5
    8531:	00 00                	add    %al,(%bx,%si)
    8533:	e8 4d ff             	call   8483 <inb+0x1b>
    8536:	ff                   	(bad)  
    8537:	ff 83 c4 08          	incw   0x8c4(%bp,%di)

    outb(0x1F2, (uint8_t)(sector_count));
    853b:	0f b7 45 e8          	movzww -0x18(%di),%ax
    853f:	0f b6 c0             	movzbw %al,%ax
    8542:	50                   	push   %ax
    8543:	68 f2 01             	push   $0x1f2
    8546:	00 00                	add    %al,(%bx,%si)
    8548:	e8 38 ff             	call   8483 <inb+0x1b>
    854b:	ff                   	(bad)  
    854c:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(0x1F3, (uint8_t)(sector));
    8550:	8b 45 08             	mov    0x8(%di),%ax
    8553:	0f b6 c0             	movzbw %al,%ax
    8556:	50                   	push   %ax
    8557:	68 f3 01             	push   $0x1f3
    855a:	00 00                	add    %al,(%bx,%si)
    855c:	e8 24 ff             	call   8483 <inb+0x1b>
    855f:	ff                   	(bad)  
    8560:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(0x1F4, (uint8_t)(sector >> 8));
    8564:	8b 45 08             	mov    0x8(%di),%ax
    8567:	c1 e8 08             	shr    $0x8,%ax
    856a:	0f b6 c0             	movzbw %al,%ax
    856d:	50                   	push   %ax
    856e:	68 f4 01             	push   $0x1f4
    8571:	00 00                	add    %al,(%bx,%si)
    8573:	e8 0d ff             	call   8483 <inb+0x1b>
    8576:	ff                   	(bad)  
    8577:	ff 83 c4 08          	incw   0x8c4(%bp,%di)
    outb(0x1F5, (uint8_t)(sector >> 16));
    857b:	8b 45 08             	mov    0x8(%di),%ax
    857e:	c1 e8 10             	shr    $0x10,%ax
    8581:	0f b6 c0             	movzbw %al,%ax
    8584:	50                   	push   %ax
    8585:	68 f5 01             	push   $0x1f5
    8588:	00 00                	add    %al,(%bx,%si)
    858a:	e8 f6 fe             	call   8483 <inb+0x1b>
    858d:	ff                   	(bad)  
    858e:	ff 83 c4 08          	incw   0x8c4(%bp,%di)

    outb(0x1F7, (uint8_t)0x24);
    8592:	6a 24                	push   $0x24
    8594:	68 f7 01             	push   $0x1f7
    8597:	00 00                	add    %al,(%bx,%si)
    8599:	e8 e7 fe             	call   8483 <inb+0x1b>
    859c:	ff                   	(bad)  
    859d:	ff 83 c4 08          	incw   0x8c4(%bp,%di)

    // 读取数据
    uint16_t *data_buf = (uint16_t *)buf;
    85a1:	8b 45 10             	mov    0x10(%di),%ax
    85a4:	89 45 f8             	mov    %ax,-0x8(%di)
    while (sector_count-- > 0)
    85a7:	eb 4a                	jmp    85f3 <load2mem+0x126>
    {
        // 判断是否忙并且数据是否准备就绪
        while ((inb(0x1F7) & 0x88) != 0x8)
    85a9:	90                   	nop
    85aa:	68 f7 01             	push   $0x1f7
    85ad:	00 00                	add    %al,(%bx,%si)
    85af:	e8 b4 fe             	call   8466 <inw+0x1d>
    85b2:	ff                   	(bad)  
    85b3:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
    85b7:	0f b6 c0             	movzbw %al,%ax
    85ba:	25 88 00             	and    $0x88,%ax
    85bd:	00 00                	add    %al,(%bx,%si)
    85bf:	83 f8 08             	cmp    $0x8,%ax
    85c2:	75 e6                	jne    85aa <load2mem+0xdd>
            ;

        // 每次读取一个word
        for (int i = 0; i < SECTOR_SIZE / 2; i++)
    85c4:	c7 45 f4 00 00       	movw   $0x0,-0xc(%di)
    85c9:	00 00                	add    %al,(%bx,%si)
    85cb:	eb 1d                	jmp    85ea <load2mem+0x11d>
        {
            *data_buf++ = inw(0x1F0);
    85cd:	8b 5d f8             	mov    -0x8(%di),%bx
    85d0:	8d 43 02             	lea    0x2(%bp,%di),%ax
    85d3:	89 45 f8             	mov    %ax,-0x8(%di)
    85d6:	68 f0 01             	push   $0x1f0
    85d9:	00 00                	add    %al,(%bx,%si)
    85db:	e8 69 fe             	call   8447 <loader16c_entry+0x18>
    85de:	ff                   	(bad)  
    85df:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
    85e3:	66 89 03             	mov    %eax,(%bp,%di)
        for (int i = 0; i < SECTOR_SIZE / 2; i++)
    85e6:	83 45 f4 01          	addw   $0x1,-0xc(%di)
    85ea:	81 7d f4 ff 00       	cmpw   $0xff,-0xc(%di)
    85ef:	00 00                	add    %al,(%bx,%si)
    85f1:	7e da                	jle    85cd <load2mem+0x100>
    while (sector_count-- > 0)
    85f3:	0f b7 45 e8          	movzww -0x18(%di),%ax
    85f7:	8d 50 ff             	lea    -0x1(%bx,%si),%dx
    85fa:	66 89 55 e8          	mov    %edx,-0x18(%di)
    85fe:	66 85 c0             	test   %eax,%eax
    8601:	75 a6                	jne    85a9 <load2mem+0xdc>
        }
    }
}
    8603:	90                   	nop
    8604:	8b 5d fc             	mov    -0x4(%di),%bx
    8607:	c9                   	leave  
    8608:	c3                   	ret    

00008609 <read_elf>:

uint32_t read_elf(uint8_t *file_buffer)
{
    8609:	55                   	push   %bp
    860a:	89 e5                	mov    %sp,%bp
    860c:	83 ec 20             	sub    $0x20,%sp
    Elf32_Ehdr *elf_hdr = (Elf32_Ehdr *)file_buffer;
    860f:	8b 45 08             	mov    0x8(%di),%ax
    8612:	89 45 e8             	mov    %ax,-0x18(%di)
    // 判定魔数是否正确
    if ((elf_hdr->e_ident[0] != 0x7F) || (elf_hdr->e_ident[1] != 'E') ||
    8615:	8b 45 e8             	mov    -0x18(%di),%ax
    8618:	0f b6 00             	movzbw (%bx,%si),%ax
    861b:	3c 7f                	cmp    $0x7f,%al
    861d:	75 21                	jne    8640 <read_elf+0x37>
    861f:	8b 45 e8             	mov    -0x18(%di),%ax
    8622:	0f b6 40 01          	movzbw 0x1(%bx,%si),%ax
    8626:	3c 45                	cmp    $0x45,%al
    8628:	75 16                	jne    8640 <read_elf+0x37>
        (elf_hdr->e_ident[2] != 'L') || (elf_hdr->e_ident[3] != 'F'))
    862a:	8b 45 e8             	mov    -0x18(%di),%ax
    862d:	0f b6 40 02          	movzbw 0x2(%bx,%si),%ax
    if ((elf_hdr->e_ident[0] != 0x7F) || (elf_hdr->e_ident[1] != 'E') ||
    8631:	3c 4c                	cmp    $0x4c,%al
    8633:	75 0b                	jne    8640 <read_elf+0x37>
        (elf_hdr->e_ident[2] != 'L') || (elf_hdr->e_ident[3] != 'F'))
    8635:	8b 45 e8             	mov    -0x18(%di),%ax
    8638:	0f b6 40 03          	movzbw 0x3(%bx,%si),%ax
    863c:	3c 46                	cmp    $0x46,%al
    863e:	74 0a                	je     864a <read_elf+0x41>
    {
        return 0;
    8640:	b8 00 00             	mov    $0x0,%ax
    8643:	00 00                	add    %al,(%bx,%si)
    8645:	e9 d7 00             	jmp    871f <read_elf+0x116>
    8648:	00 00                	add    %al,(%bx,%si)
    }

    // 循环解析每一个program header的信息
    for (int i = 0; i < elf_hdr->e_phnum; i++)
    864a:	c7 45 fc 00 00       	movw   $0x0,-0x4(%di)
    864f:	00 00                	add    %al,(%bx,%si)
    8651:	e9 b2 00             	jmp    8706 <read_elf+0xfd>
    8654:	00 00                	add    %al,(%bx,%si)
    {
        // 拿到program header条目
        Elf32_Phdr *phdr = (Elf32_Phdr *)(file_buffer + elf_hdr->e_phoff) + i;
    8656:	8b 45 e8             	mov    -0x18(%di),%ax
    8659:	8b 50 1c             	mov    0x1c(%bx,%si),%dx
    865c:	8b 45 08             	mov    0x8(%di),%ax
    865f:	01 c2                	add    %ax,%dx
    8661:	8b 45 fc             	mov    -0x4(%di),%ax
    8664:	c1 e0 05             	shl    $0x5,%ax
    8667:	01 d0                	add    %dx,%ax
    8669:	89 45 e4             	mov    %ax,-0x1c(%di)
        // 检查程序是否可加载
        if (phdr->p_type != PT_LOAD)
    866c:	8b 45 e4             	mov    -0x1c(%di),%ax
    866f:	8b 00                	mov    (%bx,%si),%ax
    8671:	83 f8 01             	cmp    $0x1,%ax
    8674:	0f 85 89 00          	jne    8701 <read_elf+0xf8>
    8678:	00 00                	add    %al,(%bx,%si)
        {
            continue;
        }
        // 拿到相应的section的地址
        uint8_t *src = file_buffer + phdr->p_offset;
    867a:	8b 45 e4             	mov    -0x1c(%di),%ax
    867d:	8b 50 04             	mov    0x4(%bx,%si),%dx
    8680:	8b 45 08             	mov    0x8(%di),%ax
    8683:	01 d0                	add    %dx,%ax
    8685:	89 45 f8             	mov    %ax,-0x8(%di)
        // 拿到将要存放到的内存地址
        uint8_t *dest = (uint8_t *)phdr->p_paddr;
    8688:	8b 45 e4             	mov    -0x1c(%di),%ax
    868b:	8b 40 0c             	mov    0xc(%bx,%si),%ax
    868e:	89 45 f4             	mov    %ax,-0xc(%di)
        // 开始将section的信息放到相应的地址处
        for (int j = 0; j < phdr->p_filesz; j++)
    8691:	c7 45 f0 00 00       	movw   $0x0,-0x10(%di)
    8696:	00 00                	add    %al,(%bx,%si)
    8698:	eb 1b                	jmp    86b5 <read_elf+0xac>
        {
            *dest++ = *src++;
    869a:	8b 55 f8             	mov    -0x8(%di),%dx
    869d:	8d 42 01             	lea    0x1(%bp,%si),%ax
    86a0:	89 45 f8             	mov    %ax,-0x8(%di)
    86a3:	8b 45 f4             	mov    -0xc(%di),%ax
    86a6:	8d 48 01             	lea    0x1(%bx,%si),%cx
    86a9:	89 4d f4             	mov    %cx,-0xc(%di)
    86ac:	0f b6 12             	movzbw (%bp,%si),%dx
    86af:	88 10                	mov    %dl,(%bx,%si)
        for (int j = 0; j < phdr->p_filesz; j++)
    86b1:	83 45 f0 01          	addw   $0x1,-0x10(%di)
    86b5:	8b 45 e4             	mov    -0x1c(%di),%ax
    86b8:	8b 50 10             	mov    0x10(%bx,%si),%dx
    86bb:	8b 45 f0             	mov    -0x10(%di),%ax
    86be:	39 c2                	cmp    %ax,%dx
    86c0:	77 d8                	ja     869a <read_elf+0x91>
        }

        // 剩余区域填充为0
        dest = (uint8_t *)phdr->p_paddr + phdr->p_filesz;
    86c2:	8b 45 e4             	mov    -0x1c(%di),%ax
    86c5:	8b 50 10             	mov    0x10(%bx,%si),%dx
    86c8:	8b 45 e4             	mov    -0x1c(%di),%ax
    86cb:	8b 40 0c             	mov    0xc(%bx,%si),%ax
    86ce:	01 d0                	add    %dx,%ax
    86d0:	89 45 f4             	mov    %ax,-0xc(%di)
        for (int j = 0; j < phdr->p_memsz - phdr->p_filesz; j++)
    86d3:	c7 45 ec 00 00       	movw   $0x0,-0x14(%di)
    86d8:	00 00                	add    %al,(%bx,%si)
    86da:	eb 10                	jmp    86ec <read_elf+0xe3>
        {
            *dest++ = 0;
    86dc:	8b 45 f4             	mov    -0xc(%di),%ax
    86df:	8d 50 01             	lea    0x1(%bx,%si),%dx
    86e2:	89 55 f4             	mov    %dx,-0xc(%di)
    86e5:	c6 00 00             	movb   $0x0,(%bx,%si)
        for (int j = 0; j < phdr->p_memsz - phdr->p_filesz; j++)
    86e8:	83 45 ec 01          	addw   $0x1,-0x14(%di)
    86ec:	8b 45 e4             	mov    -0x1c(%di),%ax
    86ef:	8b 50 14             	mov    0x14(%bx,%si),%dx
    86f2:	8b 45 e4             	mov    -0x1c(%di),%ax
    86f5:	8b 40 10             	mov    0x10(%bx,%si),%ax
    86f8:	29 c2                	sub    %ax,%dx
    86fa:	8b 45 ec             	mov    -0x14(%di),%ax
    86fd:	39 c2                	cmp    %ax,%dx
    86ff:	77 db                	ja     86dc <read_elf+0xd3>
    8701:	eb 01                	jmp    8704 <read_elf+0xfb>
            continue;
    8703:	90                   	nop
    for (int i = 0; i < elf_hdr->e_phnum; i++)
    8704:	83 45 fc 01          	addw   $0x1,-0x4(%di)
    8708:	8b 45 e8             	mov    -0x18(%di),%ax
    870b:	0f b7 40 2c          	movzww 0x2c(%bx,%si),%ax
    870f:	0f b7 c0             	movzww %ax,%ax
    8712:	39 45 fc             	cmp    %ax,-0x4(%di)
    8715:	0f 8c 3b ff          	jl     8654 <read_elf+0x4b>
    8719:	ff                   	(bad)  
    871a:	ff 8b 45 e8          	decw   -0x17bb(%bp,%di)
        }
    }
    return elf_hdr->e_entry;
    871e:	8b 40 18             	mov    0x18(%bx,%si),%ax
}
    8721:	c9                   	leave  
    8722:	c3                   	ret    

00008723 <enable_page_mode>:

void enable_page_mode()
{
    8723:	55                   	push   %bp
    8724:	89 e5                	mov    %sp,%bp
    static uint32_t page_dir[1024] __attribute__((aligned(4096))) = {
        [0] = PDE_P | PDE_W,
    };

    // wcr4(rcr4() | CR4_PSE);
    wcr3((uint32_t)page_dir);
    8726:	b8 00 a0             	mov    $0xa000,%ax
    8729:	00 00                	add    %al,(%bx,%si)
    872b:	50                   	push   %ax
    872c:	e8 90 fd             	call   84bf <wcr0+0xa>
    872f:	ff                   	(bad)  
    8730:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
    wcr0(rcr0() | CR0_PG);
    8734:	e8 6b fd             	call   84a2 <outb+0x1d>
    8737:	ff                   	(bad)  
    8738:	ff 0d                	decw   (%di)
    873a:	00 00                	add    %al,(%bx,%si)
    873c:	00 80 50 e8          	add    %al,-0x17b0(%bx,%si)
    8740:	71 fd                	jno    873f <enable_page_mode+0x1c>
    8742:	ff                   	(bad)  
    8743:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
}
    8747:	90                   	nop
    8748:	c9                   	leave  
    8749:	c3                   	ret    

0000874a <loader32c_entry>:

void loader32c_entry(void)
{
    874a:	55                   	push   %bp
    874b:	89 e5                	mov    %sp,%bp
    874d:	83 ec 18             	sub    $0x18,%sp
    // 加载内核的二进制文件到内存中
    load2mem(100, 500, (uint8_t *)KERNEL_ENTRY);
    8750:	68 00 00             	push   $0x0
    8753:	10 00                	adc    %al,(%bx,%si)
    8755:	68 f4 01             	push   $0x1f4
    8758:	00 00                	add    %al,(%bx,%si)
    875a:	6a 64                	push   $0x64
    875c:	e8 6c fd             	call   84cb <wcr3+0xa>
    875f:	ff                   	(bad)  
    8760:	ff 83 c4 0c          	incw   0xcc4(%bp,%di)
    // 解析ELF文件，将各个段放置到相应的位置
    uint32_t kernel_entry = read_elf((uint8_t *)KERNEL_ENTRY);
    8764:	68 00 00             	push   $0x0
    8767:	10 00                	adc    %al,(%bx,%si)
    8769:	e8 9b fe             	call   8607 <load2mem+0x13a>
    876c:	ff                   	(bad)  
    876d:	ff 83 c4 04          	incw   0x4c4(%bp,%di)
    8771:	89 45 f4             	mov    %ax,-0xc(%di)
    // 跳跃到内核区
    // enable_page_mode();
    // ((void (*)(mem_info_t *, gdt_entry_t *))kernel_entry)(&mem, gdt_table);
    ((void (*)(mem_info_t *))kernel_entry)(&mem);
    8774:	8b 45 f4             	mov    -0xc(%di),%ax
    8777:	83 ec 0c             	sub    $0xc,%sp
    877a:	68 00 b8             	push   $0xb800
    877d:	00 00                	add    %al,(%bx,%si)
    877f:	ff d0                	call   *%ax
    8781:	83 c4 10             	add    $0x10,%sp
    // ((void (*)(mem_info_t *))KERNEL_ENTRY)(&mem);
    8784:	90                   	nop
    8785:	c9                   	leave  
    8786:	c3                   	ret    
